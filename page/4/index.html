<!doctype html>
<html class="theme-next use-motion theme-next-mist">
<head>
  

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






  <link rel="stylesheet" type="text/css" href="../../vendors/fancybox/source/jquery.fancybox.css?v=2.1.5"/>


<link rel="stylesheet" type="text/css" href="../../css/main.css?v=0.4.2"/>


    <meta name="description" content="在码农炼成之路不断挣扎……stay hungry……keep learning……" />



  <meta name="keywords" content="java,android,life,CharlesXiao" />





  <link rel="shorticon icon" type="image/x-icon" href="../..//favicon.ico?v=0.4.2" />



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?6749450";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>


  <title> CharlesXiao‘s Blog </title>
</head>

<body>
<!--[if lte IE 8]> <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'> <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode"><img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820" alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari." style='margin-left:auto;margin-right:auto;display: block;'/></a></div> <![endif]-->
  <div class="container one-column 
   page-home 
">
    <div class="headband"></div>

    <div id="header" class="header">
      <div class="header-inner">
        <h1 class="site-meta">
  <span class="logo-line-before"><i></i></span>
  <a href="/" class="brand">
      <span class="logo">
        <i class="icon-logo"></i>
      </span>
      <span class="site-title">CharlesXiao‘s Blog</span>
  </a>
  <span class="logo-line-after"><i></i></span>
</h1>


  <ul id="menu" class="menu">
     
    <!--增加swiftype搜索功能-->
    <form class="menu-item menu-item-search">
      <input type="text" id="st-search-input" class="st-search-input st-default-search-input" />
    </form>
    
    <script type="text/javascript">
      (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
      (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
      e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
      })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

      _st('install','yxUhPQ2aHyszT_1btxX9','2.0.0');
    </script>
    <!--增加swiftype搜索功能end-->
    
    
      
      <li class="menu-item menu-item-home">
        <a href="../..//">
          <i class="menu-item-icon icon-home"></i> <br />
          首页
        </a>
      </li>
    
      
      <li class="menu-item menu-item-categories">
        <a href="../..//categories">
          <i class="menu-item-icon icon-categories"></i> <br />
          分类
        </a>
      </li>
    
      
      <li class="menu-item menu-item-about">
        <a href="../..//about">
          <i class="menu-item-icon icon-about"></i> <br />
          关于
        </a>
      </li>
    
      
      <li class="menu-item menu-item-archives">
        <a href="../..//archives">
          <i class="menu-item-icon icon-archives"></i> <br />
          归档
        </a>
      </li>
    
      
      <li class="menu-item menu-item-tags">
        <a href="../..//tags">
          <i class="menu-item-icon icon-tags"></i> <br />
          标签
        </a>
      </li>
    
  </ul>


      </div>
    </div>

    <div id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content">
          
  <div id="posts" class="posts-expand">
    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="../../2015/05/15/Mac设置Path环境变量(adb+NDK+sdk)/">
                Mac设置环境变量(adb+NDK+sdk)
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2015-05-15
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分类于
            
              <a href="../../categories/Mac系统/">Mac系统</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="../../2015/05/15/Mac设置Path环境变量(adb+NDK+sdk)/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/05/15/Mac设置Path环境变量(adb+NDK+sdk)/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <p>无论是在windows还是mac系统下，对于程序猿而言，在terminal中输入命令进行一些常用操作是比用鼠标更为快捷的方式。那么为了能够打开terminal就可以直接输入并执行命令，就需要进行环境变量的设置，这样就不必进入命令文件所在目录下执行该命令了。windows下配置环境变量较为简单，在此讲一下mac下配置环境变量的方法和注意事项。</p>
<p><strong>1. 打开terminal，输入<code>cd ~</code>, 进入当前用户home目录</strong></p>
<p><strong>2. 输入<code>touch .bash_profile</code>, 创建bash_profile文件(如果该文件已经存在则可以直接进入第3步)</strong></p>
<p><strong>3. 打开记事本编辑bash_profile文件，示例如下</strong></p>
<pre><code>方式一：用<span class="constant">SDK_HOME指</span>代一个通用路径，一处设置，多处使用，结构明晰，然后设置到<span class="constant">PATH</span>

export <span class="constant">SDK_HOME=</span>“/usr/sdk”             
export <span class="constant">PATH=</span><span class="variable">${</span><span class="constant">PATH}</span><span class="symbol">:</span><span class="variable">${</span><span class="constant">SDK_HOME}</span><span class="symbol">:</span><span class="variable">${</span><span class="constant">SDK_HOME}</span>/<span class="symbol">tools:</span>/usr/ndk


方式二：直接将各个命令的路径用<span class="symbol">:</span>连接起来设置到<span class="constant">PATH </span>形如--- export <span class="constant">PATH=</span><span class="variable">${</span><span class="constant">PATH}</span><span class="symbol">:</span>路径<span class="number">1</span><span class="symbol">:</span>路径<span class="number">2</span><span class="symbol">:</span>路径<span class="number">3</span>

export <span class="constant">PATH=</span><span class="variable">${</span><span class="constant">PATH}</span><span class="symbol">:/usr/sdk</span><span class="symbol">:/usr/sdk/tools</span><span class="symbol">:/usr/ndk</span>
</code></pre><p><strong>4. 保存修改，输入更新命令<code>source .bash_profile</code>,PATH变量配置完成</strong></p>
<p><a href="http://blog.csdn.net/zf135792468/article/details/11926995" target="_blank" rel="external">参考链接</a></p>

        
      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="../../tags/Android/"> #Android </a>
          
            <a href="../../tags/Mac/"> #Mac </a>
          
        </div>
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="../../2015/05/12/如何阅读一本书/">
                如何阅读一本书
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2015-05-12
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分类于
            
              <a href="../../categories/读书札记/">读书札记</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="../../2015/05/12/如何阅读一本书/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/05/12/如何阅读一本书/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <p>书籍使人进步！阅读使人明智！如何阅读一本书也是一门学问，读懂不同类型的书也是一件不容易的事情。美国教育家查尔斯-范多伦还特地写了一本《如何阅读一本书》来讲述读书的“方法论”，此文为部分书摘，闲来无事翻书，翻到哪儿写到哪儿，未完待续……
          <div class="post-more-link text-center">
            <a class="btn" href="../../2015/05/12/如何阅读一本书/#more">
              阅读全文 &raquo;
            </a>
          </div>
        
      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="../../tags/阅读/"> #阅读 </a>
          
        </div>
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="../../2015/04/13/Java多线程同步方法/">
                Java多线程同步方法
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2015-04-13
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分类于
            
              <a href="../../categories/java学习笔记/">java学习笔记</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="../../2015/04/13/Java多线程同步方法/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/04/13/Java多线程同步方法/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <h3 id="Synchronized代码块和方法">Synchronized代码块和方法</h3><p>synchronized关键字强制实施一个互斥锁，使得被保护的代码块在同一时间只能有一个线程进入并执行，防止多线程访问临界共享资源出现数据不一致性；同步是一种高开销的操作，因此应该尽量减少同步的内容;通常没有必要同步整个方法，使用synchronized代码块同步关键代码；Synchronized锁住的是对象或者类,对象被锁住时，该对象所有的其他同步方法和代码块不能被执行；类被锁住时，该类所有的其他同步静态方法和代码块不能被执行</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">Bank</span> </span>{
        <span class="keyword">private</span> <span class="keyword">int</span> account = <span class="number">100</span>;

        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAccount</span><span class="params">()</span> </span>{
            <span class="keyword">return</span> account;
        }

        <span class="javadoc">/**
         * 用同步方法实现
         * 
         *<span class="javadoctag"> @param</span> money
         */</span>
        <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(<span class="keyword">int</span> money)</span> </span>{
            account += money;
        }

        <span class="javadoc">/**
         * 用同步代码块实现
         * 
         *<span class="javadoctag"> @param</span> money
         */</span>
        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save1</span><span class="params">(<span class="keyword">int</span> money)</span> </span>{
            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {
                account += money;
            }
        }
    }
</code></pre><h3 id="ReentrantLock可重入锁">ReentrantLock可重入锁</h3><p>ReentrantLock是可重入、互斥、实现了Lock接口的锁，需要自己手动加锁与释放；要注意及时释放锁，否则会出现死锁，通常在finally代码释放锁；如果synchronized关键字能满足用户的需求，就用synchronized，因为它能简化代码</p>
<pre><code><span class="keyword">class</span> <span class="title">Bank</span> {
        <span class="keyword">private</span> <span class="keyword">int</span> account = <span class="number">100</span>;
        <span class="comment">// 创建一个ReentrantLock锁</span>
        <span class="keyword">private</span> Lock <span class="keyword">lock</span> = <span class="keyword">new</span> ReentrantLock();

        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAccount</span><span class="params">()</span> </span>{
            <span class="keyword">return</span> account;
        }

        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(<span class="keyword">int</span> money)</span> </span>{
            <span class="keyword">lock</span>.<span class="keyword">lock</span>();    <span class="comment">// 获得锁 </span>
            <span class="keyword">try</span> {
                account += money;
            } <span class="keyword">finally</span> {
                <span class="keyword">lock</span>.unlock();    <span class="comment">// 释放锁</span>
            }
        }
}
</code></pre><h3 id="ThreadLocal线程局部变量">ThreadLocal线程局部变量</h3><p><strong>ThreadLocal与同步机制区别</strong>：a.ThreadLocal与同步机制都是为了解决多线程中相同变量的访问冲突问题。b.前者采用以”空间换时间”的方法，后者采用以”时间换空间”的方式<br>每一个使用ThreadLocal变量的线程都获得该变量的副本，副本之间相互独立，这样每一个线程都可以随意修改自己的变量副本，而不会对其他线程产生影响</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Bank</span> {
    <span class="comment">// 使用ThreadLocal类管理共享变量account</span>
    <span class="keyword">private</span> ThreadLocal&lt;Integer&gt; account = <span class="keyword">new</span> ThreadLocal&lt;Integer&gt;() {
        @<span class="function">Override
        <span class="keyword">protected</span> Integer <span class="title">initialValue</span><span class="params">()</span> </span>{
            <span class="keyword">return</span> <span class="number">100</span>;
        }
    };

    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(<span class="keyword">int</span> money)</span> </span>{
        account.<span class="keyword">set</span>(account.<span class="keyword">get</span>() + money);
    }

    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAccount</span><span class="params">()</span> </span>{
        <span class="keyword">return</span> account.<span class="keyword">get</span>();
    }
}
</code></pre><h3 id="volatile变量可见性">volatile变量可见性</h3><p><strong>volatile</strong>: 在需要同步的变量上加上修饰符volatile，例如：private volatile int account = 100;volatile可以保证变量的可见性但是不保证原子性，不能用于修饰final常量，线程每一次对volatile变量的修改都会即时刷新到主存和通知到其他线程，也就是说每一次每个线程读取volatile变量时都会从主存中去取而不会从缓存寄存器中获取，以确保变量的值都是最新获取的;该关键字在JDK1.6开始可以保证指令不被重排序；但是他不能保证原子性，比如n++这种复合型操作;java虚拟机规范（jvm spec）中，规定了声明为volatile的long和double变量的get和set操作是原子的,所以将long和double类型的变量用volatile修饰，就可以保证对他们的赋值操作的原子性。  </p>
<p><strong>CAS比较并交换操作</strong>：CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B). CAS有效地说明了“我认为位置 V 应该包含值 A；如果包含该值，则将 B 放到这个位置；否则，不要更改该位置，只告诉我这个位置现在的值即可。”   </p>
<p>例如，有一个变量i=0，Thread-1和Thread-2都对这个变量执行自增操作。 可能会出现Thread-1与Thread-2同时读取i=0到各自的工作内存中，然后各自执行+1，最后将结果赋予i。这样，虽然两个线程都对i执行了自增操作，但是最后i的值为1，而不是2。<br>解决这个问题使用互斥锁自然可以。但是也可以使用CAS来实现，思路如下：<br>自增操作可以分为两步：（1）从内存中读取这个变量的当前值（2）执行（变量=上一步取到的当前值+1）的赋值操作。</p>
<p>多线程情况下，自增操作出现问题的原因就是执行（2）的时候，变量在主内存中的值已经不等于上一步取到的当前值了，所以赋值时，用CompareAndSet操作代替Set操作：首先比较一下内存中这个变量的值是否等于上一步取到的当前值，如果等于，则说明可以执行+1运算，并赋值；如果不等于，则说明有其他线程在此期间更改了主内存中此变量的值，上一步取出的当前值已经失效，此时，不再执行+1运算及后续的赋值操作，而是返回主内存中此变量的最新值。“比较并交换（CAS）”操作是原子操作，它使用平台提供的用于并发操作的硬件原语。</p>
<p><strong>原子（atom）</strong>本意是“不能被进一步分割的最小粒子”，而原子操作（atomic operation）意为”不可被中断的一个或一系列操作” </p>
<h3 id="Wait_&amp;&amp;_Notify同步(生产者消费者模式实现)">Wait &amp;&amp; Notify同步(生产者消费者模式实现)</h3><ol>
<li><strong>Wait</strong>调用任意对象的wait()方法导致该线程阻塞，并释放该对象上的锁，进入等待对象同步锁的状态;<strong>Notify</strong>随机唤醒一个等待对象同步锁的线程</li>
<li><strong>生产者-消费者（producer-consumer）问题</strong>，也称作有界缓冲区（bounded-buffer）问题，两个进程共享一个公共的固定大小的缓冲区。其中一个是生产者，用于将消息放入缓冲区；另外一个是消费者，用于从缓冲区中取出消息。问题出现在当缓冲区已经满了，而此时生产者还想向其中放入一个新的数据项的情形，其解决方法是让生产者此时进行休眠，等待消费者从缓冲区中取走了一个或者多个数据后再去唤醒它。同样地，当缓冲区已经空了，而消费者还想去取消息，此时也可以让消费者进行休眠，等待生产者放入一个或者多个数据时再唤醒它</li>
<li>代码</li>
</ol>

        
      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="../../tags/Java/"> #Java </a>
          
            <a href="../../tags/多线程/"> #多线程 </a>
          
        </div>
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="../../2015/04/09/Android基础知识总结/">
                Android基础知识总结
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2015-04-09
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分类于
            
              <a href="../../categories/Android开发/">Android开发</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="../../2015/04/09/Android基础知识总结/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/04/09/Android基础知识总结/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <h3 id="Android子线程和UI线程交互的5种方式">Android子线程和UI线程交互的5种方式</h3><ol>
<li><p><strong>handler</strong>: 参考“实习项目总结”</p>
</li>
<li><p><strong>AsyncTask</strong>: 参考“实习项目总结”</p>
</li>
<li><p><strong>Activity.runOnUIThread(Runnable)</strong>  </p>
<p> <strong>子线程更新UI</strong>  </p>
<pre><code><span class="keyword">new</span> Thread() {  
    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{  
        <span class="comment">//这儿是耗时操作，完成之后更新UI；  </span>
        runOnUiThread(<span class="keyword">new</span> Runnable(){  

            <span class="annotation">@Override</span>  
            <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{  
                <span class="comment">//更新UI  </span>
                imageView.setImageBitmap(bitmap);  
            }  

        });  
    }  
}.start(); 
</code></pre><p> <strong>非Activity更新UI</strong></p>
<pre><code>Activity activity = (Activity) imageView.getContext();  
        activity.runOnUiThread(<span class="keyword">new</span> Runnable() {  

            <span class="annotation">@Override</span>  
            <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{  
                imageView.setImageBitmap(bitmap);  
            }  
});  
</code></pre></li>
<li><p><strong>View.Post(Runnable)</strong></p>
<pre><code>imageView.post(<span class="keyword">new</span> Runnable(){  

            <span class="annotation">@Override</span>  
            <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{  
                imageView.setImageBitmap(bitmap);  
            }  

});  
</code></pre></li>
<li><p><strong>View.PostDelayed(Runnabe,long)</strong></p>
</li>
</ol>
<h3 id="Activity四种启动模式，组件和生命周期">Activity四种启动模式，组件和生命周期</h3><ol>
<li><strong>Application</strong>: 应用程序是组件的集合，manifest文件中展现了application中组件的结构,加载app时会根据manifest去加载和实例化组件</li>
<li><strong>Process</strong>: 一个应用程序占据一个进程，一个运行中的dalvik虚拟机实例就占据一个进程; 但是我们可以给组件设置android:process = “name”来让组件运行在独立进程中</li>
<li><strong>Task</strong>: 一组以栈的形式来进行管理的相互关联的activity的集合，它是存在于framework层的一个跨应用的概念，控制界面的跳转和返回；task中所有的activity在一个叫做back stack的栈中进行管理</li>
<li><strong>四种启动模式</strong><ul>
<li><strong>standard</strong>: 默认的lauchmode, 同一个activity可以被实例化多次，在一个task栈中可以同时存在一个activity的多个实例，每次startActivity就新建一个实例入栈<br><img src="https://raw.githubusercontent.com/Charles-Xiao/Charles-Xiao.github.io/master/images/standard.png" class="full-image"></li>
<li><strong>singleTop</strong>: 先检查栈顶是否是该activity的实例，是则重用该实例，并且调用该实例的onNewIntent()方法，否则要新建实例压入栈顶<br><img src="https://raw.githubusercontent.com/Charles-Xiao/Charles-Xiao.github.io/master/images/singleTop.png" class="full-image">  </li>
<li><strong>singleTask</strong>: 先检查栈中是否包含该activity的实例，是则重用该实例，清理该实例上的所有activity并将其显示给用户；否则新建实例压入back stack<br><img src="https://raw.githubusercontent.com/Charles-Xiao/Charles-Xiao.github.io/master/images/singleTask.png" class="full-image"></li>
<li><strong>singleInstance</strong>: 以singleInstance模式启动的Activity具有全局唯一性，即整个系统中只会存在一个这样的实例；而且具备独占性，以该模式启动的Activity不能与其他Activity共存在一个task中<br><img src="https://raw.githubusercontent.com/Charles-Xiao/Charles-Xiao.github.io/master/images/singleInstance.png" class="full-image"></li>
</ul>
</li>
<li><strong>四大组件</strong>: </li>
</ol>

        
      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="../../tags/Android/"> #Android </a>
          
        </div>
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="../../2015/04/08/实习项目总结/">
                实习项目总结
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2015-04-08
        </span>

        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="../../2015/04/08/实习项目总结/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/04/08/实习项目总结/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <h3 id="Kactus">Kactus</h3><ol>
<li><p>ECO餐厅食用油回收系统</p>
<ul>
<li><p>Android端缓存机制的实现，采用二级缓存，从LRUcache到DiskLruCache，同时模拟浏览器缓存机制来分析http请求过程的请求头内容来确定cache-control策略</p>
<ol>
<li>请求流程: 当我们第一次打开应用获取图片时，先到网络去下载图片，然后依次存入内存缓存，磁盘缓存;以后每次加载图片的时候都优先去LRUCache内存缓存当中读取，当读取不到的时候则回去DiskLruCache硬盘缓存中读取，而如果硬盘缓存仍然读取不到的话，就从网络上请求原始数据。</li>
<li><strong>二级缓存</strong>: 变化频繁的小数据都采用LRUCache,稳定的大文件数据采用DiskLruCache;LruCache和DiskLruCache的原理实际上是LinkedHashMap和File；根据请求头里边的expires(缓存过期的时间（绝对时间）),Last-Modified, Cache-Control等内容来确定DiskLruCache中缓存的保留时间以及清理策略；例如用File.lastModified()方法得到文件的最后修改时间，与当前时间相减得到已缓存时间,然后根据时间判断是否过期，从而实现缓存定时清理  </li>
<li><strong>FIFO</strong>First In First Out，先进先出;判断被存储的时间，离目前存储时间最久的数据优先被淘汰。<strong>LFU</strong>：Least Frequently Used，最不经常使用;在一段时间内，数据被使用次数最少的，优先被淘汰。</li>
</ol>
<p>缓存图片举例：</p>
</li>
</ul>
</li>
</ol>
<pre><code><span class="comment">// 获取应用可占内存的1/8作为缓存</span>
<span class="built_in">int</span> maxSize = (<span class="built_in">int</span>) (Runtime.getRuntime().maxMemory() / <span class="number">8</span>);
<span class="comment">// 实例化LruCaceh对象</span>
mLruCache = <span class="keyword">new</span> LruCache&lt;<span class="keyword">String</span>, Bitmap&gt;(maxSize) {
    @Override
    <span class="keyword">protected</span> <span class="built_in">int</span> sizeOf(<span class="keyword">String</span> <span class="variable">key</span>, Bitmap bitmap) {
        <span class="keyword">return</span> bitmap.getRowBytes() * bitmap.getHeight();
    }
};
 mDiskLruCache=DiskLruCache.<span class="built_in">open</span>(getDiskCacheDir(context.getApplicationContext(),
 <span class="string">"xxxxx"</span>),     getAppVersion(context), <span class="number">1</span>, DISKMAXSIZE);
<span class="comment">// 缓存操作</span>
mLruCache.<span class="built_in">get</span>(url);
mLruCache.put(url, bitmap);
bitmap = BitmapFactory.decodeStream(mDiskLruCache.<span class="built_in">get</span>(url).getInputStream(<span class="number">0</span>));
DiskLruCache.Editor editor = mDiskLruCache.edit(<span class="variable">key</span>);
OutputStream outputStream = editor.newOutputStream(<span class="number">0</span>);
editor.commit();
</code></pre><ol>
<li><p>采用Java WebSocket编程取代传统的非实时http请求连接模式</p>
<ul>
<li><p><strong>实现方法</strong>: WebSocket是一个基于TCP连接的双向通道，Web应用的信息交互过程通常是客户端发出一个请求，服务器端接收和审核完请求后进行处理并返回结果给客户端，然后客户端浏览器将信息呈现出来，但是对于那些实时要求比较高的应用来说，比如说在线游戏、新闻在线播报、RSS 订阅推送等等，当客户端浏览器准备呈现这些信息的时候，这些信息在服务器端可能已经过时了;    <strong>常见的模拟实时应用方法</strong> </p>
<p>  <strong>轮询</strong>：最早的一种实现实时 Web 应用的方案。客户端以一定的时间间隔向服务端发出请求，以频繁请求的方式来保持客户端和服务器端的同步。服务器端的数据可能并没有更新但是依然请求，会带来很多无谓的网络传输，所以这是一种非常低效的实时方案。  </p>
<p>  <strong>长轮询</strong>：为了降低无效的网络传输，当服务器端没有数据更新的时候，连接会保持一段时间周期直到数据或状态改变或者时间过期，通过这种机制来减少无效的客户端和服务器间的交互  </p>
<p>  <strong>流</strong>： 流技术方案通常就是在客户端的页面使用一个隐藏的窗口向服务端发出一个长连接的请求。服务器端接到这个请求后作出回应并不断更新连接状态以保证客户端和服务器端的连接不过期。通过这种机制可以将服务器端的信息源源不断地推向客户端。这种机制需要针对不同的浏览器设计不同的方案来改进用户体验，同时这种机制在并发比较大的情况下，对服务器端的资源是一个极大的考验。</p>
<p>  <strong>WebSocket</strong>: 为了建立一个 WebSocket 连接，客户端浏览器首先要向服务器发起一个 HTTP 请求，这个请求和通常的 HTTP 请求不同，包含了一些附加头信息，其中附加头信息”Upgrade: WebSocket”表明这是一个申请协议升级的 HTTP 请求，服务器端解析这些附加的头信息然后产生应答信息返回给客户端，客户端和服务器端的 WebSocket 连接就建立起来了，双方就可以通过这个连接通道自由的传递信息，并且这个连接会持续存在直到客户端或者服务器端的某一方主动的关闭连接。    </p>
<pre><code><span class="annotation">@ServerEndpoint</span>(<span class="string">"/websocket"</span>)
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSocketTest</span> </span>{

  <span class="annotation">@OnMessage</span>
  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(String message, Session session)</span>
    <span class="keyword">throws</span> IOException, InterruptedException </span>{

    System.out.println(<span class="string">"Received: "</span> + message);

    <span class="comment">// Send the first message to the client</span>
    session.getBasicRemote().sendText(<span class="string">"This is the first server message"</span>);

    <span class="comment">// Send 3 messages to the client every 5 seconds</span>
    <span class="keyword">int</span> sentMessages = <span class="number">0</span>;
    <span class="keyword">while</span>(sentMessages &lt; <span class="number">3</span>){
      Thread.sleep(<span class="number">5000</span>);
      session.getBasicRemote().
        sendText(<span class="string">"This is an intermediate server message. Count: "</span>
          + sentMessages);
      sentMessages++;
    }

    <span class="comment">// Send a final message to the client</span>
    session.getBasicRemote().sendText(<span class="string">"This is the last server message"</span>);
  }

  <span class="annotation">@OnOpen</span>
  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onOpen</span><span class="params">()</span> </span>{
    System.out.println(<span class="string">"Client connected"</span>);
  }

  <span class="annotation">@OnClose</span>
  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClose</span><span class="params">()</span> </span>{
    System.out.println(<span class="string">"Connection closed"</span>);
  }

}
</code></pre><p>  <strong>如何使用Encoder和Decoder传输更复杂的数据</strong>：Websocket使用Decoder将文本消息转换成Java对象，然后传给@OnMessage方法处理; 而当对象写入到session中时，Websocket将使用Encoder将Java对象转换成文本，再发送给客户端。</p>
</li>
<li><p>整个项目从简单的多线程优化到采用线程池来实现xml数据文件的获取</p>
</li>
</ul>
</li>
</ol>
<h3 id="Baidu">Baidu</h3><ol>
<li><p>Duwear项目短信管理模块: 目的是将手机短信库的变化情况通知到wear端</p>
<ol>
<li><strong>SMSObserver</strong>继承ContentProvider类实现观察者模式，注册了一个短信数据库的观察者，发生变化该类都会被通知；在重载函数onChange中进行操作比对判断数据库变化情况，只知道变化，但是不知道具体操作？如何判断用户是标为已读还是删除，新建短信</li>
<li><strong>SmsReceivedListener接口</strong>：两个回调函数，作为一个接口参数传到SMSObserver的构造函数中，然后一旦判断是新短信还是短信已读，就调用其回调函数</li>
<li><strong>SmsRpcService类</strong>：继承自上边的接口，在回调函数中将这个操作判断出来发送给手表</li>
<li><strong>SmsUtils</strong>: 4个函数，查询短信数据库，标为已读的数据库操作函数</li>
<li><p>SMSObserver类中的具体的判断方式和优化过程</p>
<ul>
<li>从维护所有信息的set到只维护未读信息的内容，信息实体占用内存很大，内存优化；</li>
<li><p>ArrayList到HashSet对比与区别：防止出现重复信息，去重速度很快因为使用HashTable中的hashCode()以及equals进行查找去重；</p>
</li>
<li><p>多次读取unreadSet并对两个set进行比对，removeAll和AddAll求补集并集来比对两个未读信息集合;两个方法都用到了hashCode和equals，所以SmsEntity对象中hashcode和equals方法的同时重载；直接removeAll新set可以判断出哪些信息被标为已读，AddAll新set再removeAll旧set可以判断得到新增加的短信；比如1，2，3和1，2，4，5</p>
</li>
<li><p><strong>java集合中的浅复制和深复制，clone集合不影响原集合</strong></p>
<ol>
<li><p><strong>浅复制</strong>: 复制后的对象与原对象所有变量的值相同，包括引用变量，浅复制时只会复制引用变量本身，不会复制它指向的对象本身</p>
</li>
<li><p><strong>深复制</strong>: 复制后的对象与原对象所有变量的值相同，但是不包括引用变量，深复制时会复制引用变量指向的对象本身，所以引用值发生改变</p>
</li>
<li><p><strong>Clone()方法和Cloneable接口</strong>: Cloneable接口是一个不包含方法的标志接口，一个类必须先继承它才能在其内部调用super.clone()方法，否则会抛出不支持clone的异常;clone()方法是一个native方法，拷贝对象时已经包括一部分原对象信息，效率优于使用新建对象再一一复制变量的方式;重写clone()方法需要先调用super.clone()方法，该方法会开辟一块新的内存用于拷贝原对象，将原对象的内容一一复制到新对象的内存空间中，它是一种浅复制;如果要实现深复制，需要对复制的对象中的所有引用变量对应的对象也进行复制(具体操作:重写引用对象的clone方法，在其中调用super.clone，然后在上层对象的重载clone方法中调用该对象的clone方法)</p>
</li>
<li><p><strong>序列化实现深复制</strong>: 序列化主要用于将内存中对象状态写入数据库或者文件，以及利用Socket在网络中传输对象;一个对象要能够被序列化需要该类实现Serializable接口，可序列化类的子类默认也是可以被序列化的，不需要再次实现Serializable接口；利用序列化进行深复制的前提是该对象及其内部的引用到的对象都是可序列化的，这样对对象序列化时才能递归地保存对象及其引用对象的数据</p>
<pre><code>deepClone() {    
   <span class="comment">//序列化:将内存中对象状态转化为字节流，写入目标输出流</span>
   ByteArrayOutoutStream bo=<span class="keyword">new</span> ByteArrayOutputStream();    
   ObjectOutputStream oo=<span class="keyword">new</span> ObjectOutputStream(bo);
   <span class="comment">//    </span>
   oo.writeObject(<span class="keyword">this</span>);    
   <span class="comment">//反序列化:读取源输入流中的字节流重建一个内存中相同状态的对象     </span>
   ByteArrayInputStream bi=<span class="keyword">new</span> ByteArrayInputStream(bo.toByteArray());    
   ObjectInputStream oi=<span class="keyword">new</span> ObjectInputStream(bi);    
   <span class="keyword">return</span>(oi.readObject());    
}
</code></pre></li>
<li><p>当一个类声明要实现Serializable接口时，只是表明该类参加序列化协议;Java提供的ObjectInputStream和ObjectOutputStream将数据流功能扩展至可读写对象 。在ObjectInputStream中用readObject()方法可以直接读取一个对象，ObjectOutputStream中用writeObject()方法可以直接将对象保存到输出流中; 序列化只能保存对象的非静态成员变量，不能保存任何的成员方法和静态成员变量，而且序列化保存的只是变量的值，对于变量的任何修饰符都不能保存。          </p>
</li>
</ol>
</li>
</ul>
</li>
<li><strong>工厂模式</strong>生产手表View：需要生成许多不同的CardView，利用CardFactory中的BuildPage函数<ul>
<li>简单工厂模式:工程类+抽象产品类+具体产品类；根据参数的不同返回不同类的实例。专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类</li>
<li>工厂方法模式: 抽象产品角色，具体产品角色，抽象工厂角色，具体工厂角色;工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类;一个抽象产品类，可以派生出多个具体产品类。一个抽象工厂类，可以派生出多个具体工厂类。每个具体工厂类只能创建一个具体产品类的实例。</li>
<li>抽象工厂模式: 多个抽象产品类，每个抽象产品类可以派生出多个具体产品类。一个抽象工厂类，可以派生出多个具体工厂类。每个具体工厂类可以创建多个具体产品类的实例。</li>
</ul>
</li>
</ol>
</li>
<li><p>百度锁屏项目</p>
<ul>
<li><p>View的自定义绘制与组合原理过程</p>
<ol>
<li><p><strong>KeyguardPacketLayout</strong></p>
</li>
<li><p><strong>PacketMultiWaveView</strong></p>
<ul>
<li><strong>measure</strong> 过程由measure(int, int)方法发起，从上到下有序的测量 View，在 measure 过程的最后，每个视图存储了自己的尺寸大小和测量规格(三种测量规格MeasureSpec 类);measure 过程会为一个 View 及所有子节点的 mMeasuredWidth 和 mMeasuredHeight 变量赋值；onMeasure方法中调用setMeasuredDimension方法来设置自定义视图的尺寸</li>
<li><strong>layout</strong>子视图的具体位置都是相对于父视图而言的。View 的 onLayout 方法为空实现，而 ViewGroup 的 onLayout 为 abstract 的，因此，如果自定义的 View 要继承 ViewGroup 时，必须实现 onLayout 函数。在 layout 过程中，子视图会调用getMeasuredWidth()和getMeasuredHeight()方法获取到 measure 过程得到的 mMeasuredWidth 和mMeasuredHeight，作为自己的 width 和 height。然后调用每一个子视图的layout(l, t, r, b)函数，来确定每个子视图在父视图中的位置。</li>
<li><strong>Draw</strong>所有的视图最终都是调用 View 的 draw 方法进行绘制的。在自定义的视图复写onDraw(Canvas) 方法进行绘制， 操作canvas对象对一个bitmap对象进行绘制;View 的onDraw（Canvas）默认是空实现，复写该方法绘制自身的内容; <em>过程：绘制背景—-绘制自身—-绘制子视图—-绘制Layer和ScrollBar</em></li>
<li><strong>invalidate()</strong>请求重绘 View 树，即 draw 过程，假如视图发生大小没有变化就不会调用layout()过程，并且只绘制那些调用了invalidate()方法的 View</li>
<li><strong>requestLayout()</strong>当布局变化的时候，比如方向变化，尺寸的变化，会调用该方法，在自定义的视图中，如果某些情况下希望重新测量尺寸大小，应该手动去调用该方法，它会触发measure()和layout()过程，但不会进行 draw。</li>
<li><strong>onTouchEvent()</strong>：监听触摸事件的回调  </li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ol>
<ol>
<li><p><strong>网络通信的优化和实现过程</strong>http从同步的主线程发送get请求优化为异步的子线程发送post请求, 加强了数据传输的安全性和长度，解决了应用程序无响应的应用体验问题; httpClient和HttpUrlConnection的区别对比;最后学习和使用Volley以及OkHttp通信库<br><a href="http://www.jianshu.com/p/3141d4e46240#Volley&amp;OkHttp" target="_blank" rel="external">参考链接</a></p>
<ol>
<li><p>异步的get和post请求实现过程(HttpUrlConnection)</p>
</li>
<li><p><strong>httpClient和httpUrlConnection, OKHttp对比</strong>：</p>
<ul>
<li>httpClient是apache的开源实现，API数量多，非常稳定</li>
<li>httpUrlConnection是java自带的模块: ①可以直接支持GZIP压缩,而HttpClient虽然也支持GZIP，但要自己写代码处理 ②httpUrlConnection直接在系统层面做了缓存策略处理，加快重复请求的速度 ③API简单，体积较小,而且直接支持系统级连接池，即打开的连接不会直接关闭，在一段时间内所有程序可共用</li>
<li>HttpURLConnection在Android2.2之前有个重大Bug，调用close()函数会影响连接池，导致连接复用失效，需要关闭keepAlive;因此在2.2之前http请求都是用httpClient，2.2之后则是使用HttpURLConnection</li>
<li>但是!!!现在!!!Android不再推荐这两种方式！二是直接使用OKHttp这种成熟方案！支持Android 2.3及其以上版本; 什么是OKHttp?</li>
</ul>
</li>
<li><p>Volley原理和OkHttp实现原理和应用方法以及优缺点  </p>
<ul>
<li><strong>Volley的调用过程</strong>，通过 newRequestQueue(…) 函数新建并启动一个请求队列RequestQueue后，只需要往这个RequestQueue不断 add Request 即可</li>
<li><strong>Volley</strong>：Volley 对外暴露的 API，通过 newRequestQueue(…) 函数新建并启动一个请求队列RequestQueue。</li>
<li><strong>Request</strong>：表示一个请求的抽象类。StringRequest、JsonRequest、ImageRequest 都是它的子类，表示某种类型的请求。</li>
<li><strong>RequestQueue</strong>：表示请求队列，里面包含一个CacheDispatcher(用于处理走缓存请求的调度线程)、NetworkDispatcher数组(用于处理走网络请求的调度线程)，一个ResponseDelivery(返回结果分发接口)，通过 start() 函数启动时会启动CacheDispatcher和NetworkDispatchers。        <em> <em>*HttpStack</em></em>：处理 Http 请求，返回请求结果。目前 Volley 中有基于 HttpURLConnection 的HurlStack和 基于 Apache HttpClient 的HttpClientStack  </li>
</ul>
<p><img src="https://raw.githubusercontent.com/Charles-Xiao/Charles-Xiao.github.io/master/images/Volley.png" class="full-image"></p>
<p><a href="http://a.codekk.com/detail/Android/grumoon/Volley%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90" target="_blank" rel="external">Volley源码分析</a></p>
<p><strong>Volley用法</strong>  </p>
<pre><code> RequestQueue mQueue <span class="subst">=</span> Volley<span class="built_in">.</span>newRequestQueue(context);
 StringRequest stringRequest <span class="subst">=</span> <span class="literal">new</span> StringRequest
 (Method<span class="built_in">.</span>POST, <span class="string">"http://www.baidu.com"</span>,  
<span class="literal">new</span> Response<span class="built_in">.</span>Listener<span class="subst">&lt;</span><span class="built_in">String</span><span class="subst">&gt;</span>() {  
    @Override  
    <span class="keyword">public</span> <span class="literal">void</span> onResponse(<span class="built_in">String</span> response) {  
        <span class="keyword">Log</span><span class="built_in">.</span>d(<span class="string">"TAG"</span>, response);  
    }  
}, <span class="literal">new</span> Response<span class="built_in">.</span>ErrorListener() {  
    @Override  
    <span class="keyword">public</span> <span class="literal">void</span> onErrorResponse(VolleyError error) {  
        <span class="keyword">Log</span><span class="built_in">.</span>e(<span class="string">"TAG"</span>, error<span class="built_in">.</span>getMessage(), error);  
    }  
}){
@Override  
 <span class="keyword">protected</span> <span class="built_in">Map</span><span class="subst">&lt;</span><span class="built_in">String</span>, <span class="built_in">String</span><span class="subst">&gt;</span> getParams() throws AuthFailureError {  
     <span class="built_in">Map</span><span class="subst">&lt;</span><span class="built_in">String</span>, <span class="built_in">String</span><span class="subst">&gt;</span> <span class="built_in">map</span> <span class="subst">=</span> <span class="literal">new</span> HashMap<span class="subst">&lt;</span><span class="built_in">String</span>, <span class="built_in">String</span><span class="subst">&gt;</span>();  
     <span class="built_in">map</span><span class="built_in">.</span>put(<span class="string">"params1"</span>, <span class="string">"value1"</span>);  
     <span class="built_in">map</span><span class="built_in">.</span>put(<span class="string">"params2"</span>, <span class="string">"value2"</span>);  
     <span class="keyword">return</span> <span class="built_in">map</span>;  
 }  
}; 
 mQueue<span class="built_in">.</span>add(stringRequest); 
</code></pre></li>
</ol>
</li>
</ol>
<p><strong>OkHttp用法</strong><a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0326/2643.html" target="_blank" rel="external">源码分析</a></p>
<p><img src="https://raw.githubusercontent.com/Charles-Xiao/Charles-Xiao.github.io/master/images/OkHttp.png" class="full-image"></p>
<pre><code>OkHttpClient mOkHttpClient = <span class="keyword">new</span> OkHttpClient();
FormEncodingBuilder builder = <span class="keyword">new</span> FormEncodingBuilder();   
builder.add(<span class="string">"username"</span>,<span class="string">"value"</span>);

Request request = <span class="keyword">new</span> Request.Builder()
                   .url(url)
                .post(builder.build())
                .build();
mOkHttpClient.newCall(request).enqueue(<span class="keyword">new</span> Callback(){
    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Request request, IOException e)</span>
    </span>{
    }

    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(<span class="keyword">final</span> Response response)</span> <span class="keyword">throws</span> IOException
    </span>{
            <span class="comment">//String htmlStr =  response.body().string();</span>
    }
});
</code></pre><h3 id="佳学">佳学</h3><ol>
<li><strong>网络请求交互</strong>：参见百度锁屏项目</li>
<li><strong>Android AsynTask实现多任务下载管理</strong>:</li>
</ol>
<pre><code><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoAsyncTask</span> <span class="keyword">extends</span> <span class="title">AsyncTask</span>&lt;<span class="title">String</span>, <span class="title">Integer</span>, <span class="title">Bitmap</span>&gt; </span>{
    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPreExecute</span><span class="params">()</span> </span>{
        <span class="keyword">super</span>.onPreExecute();
    }

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">protected</span> Bitmap <span class="title">doInBackground</span><span class="params">(String... params)</span> </span>{
        <span class="keyword">return</span> <span class="keyword">null</span>;
    }   

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPostExecute</span><span class="params">(Bitmap result)</span> </span>{
        <span class="keyword">super</span>.onPostExecute(result);
    }

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onProgressUpdate</span><span class="params">(Integer... progress)</span> </span>{
        <span class="keyword">super</span>.onProgressUpdate(progress);
    }

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCancelled</span><span class="params">()</span> </span>{
        <span class="keyword">super</span>.onCancelled();
    }
}
</code></pre><ul>
<li><strong>AsyncTask<string,integer,bitmap>参数解析</string,integer,bitmap></strong><ol>
<li>params 启动任务执行的输入参数，比如HTTP请求的URL(doInBackground函数的参数类型)</li>
<li>progress 后台任务执行的百分比（onProgressUpdate函数的参数类型）</li>
<li>result 后台执行任务最终返回的结果，比如String(doInBackground返回的参数类型</li>
<li>new AsynTask.execute(url);</li>
<li>使用AsyncTask类，以下是几条必须遵守的准则：Task的实例必须在UI thread中创建; execute方法必须在UI thread中调用</li>
</ol>
</li>
<li><strong>execute方法执行的整个流程</strong><ol>
<li>AsyncTask的本质是一个静态的线程池，AsyncTask在构造函数中新建一个继承Callable接口的WorkerRunnable类对象，重载call方法，在call方法中封装了doInBackground中的异步任务；然后新建FutureTask接受WorkerRunnable作为参数，提交到线程池执行；在FutureTask的重载done函数中接收线程执行的返回结果并定义任务状态变化后的操作（包括失败和成功），发送message给UI </li>
<li>AsyncTask派生出的子类可以实现不同的异步任务，这些任务都是提交到静态的线程池中执行; 线程池中的工作线程执行doInBackground(mParams)方法执行异步任务</li>
<li>当任务状态改变(例如进度更新，执行成功，取消)之后，线程池中的工作线程会向UI线程发送消息，AsyncTask内部的InternalHandler响应这些消息，并调用相关的回调函数</li>
</ol>
</li>
<li><strong>AsyncTask和Handler,Looper之间的区别联系</strong><ol>
<li>AsyncTask是对Handler与Thread的封装。</li>
<li>AsyncTask在代码上比Handler要轻量级别，但实际上比Handler更耗资源，因为AsyncTask底层是一个线程池，而Handler仅仅就是发送了一个消息队列。但是，如果异步任务的数据特别庞大，AsyncTask线程池比Handler节省开销，因为Handler需要不停的new Thread执行。</li>
<li>AsyncTask的实例化只能在主线程，Handler可以随意，只和Looper有关系</li>
</ol>
</li>
</ul>
<ol>
<li><p><strong>Handler+Looper+MessageQueue异步信息处理系统模型</strong></p>
<ul>
<li>Android系统中耗时操作不能放在主线程进行，所以一般放在AsyncTask或者新建子线程进行，然后通过Handler发送消息通知主线程；如果这些耗时操作涉及到UI界面的更新，可以借助于(Android系统UI的更新必须放在主线程进行)Handler发送消息给UI线程更新UI</li>
<li><p><strong>Handler更新UI实例</strong>：</p>
<pre><code> <span class="comment">// UI线程新建的Handler，在handleMessage()中更新UI</span>
 <span class="keyword">private</span> Handler mHandler = <span class="keyword">new</span> Handler() {
    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">handleMessage</span> <span class="params">(Message msg)</span> </span>{
        <span class="keyword">switch</span>(msg.what) {
        <span class="keyword">case</span> MSG_SUCCESS:
            mImageView.setImageBitmap((Bitmap) msg.obj);
            <span class="keyword">break</span>;
        <span class="keyword">case</span> MSG_FAILURE:
            <span class="keyword">break</span>;
        }
    }
};

<span class="comment">// 子线程中获取网络图片并发送message通知UI线程更新显示图片</span>
Runnable runnable = <span class="keyword">new</span> Runnable() {

    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
        HttpClient hc = <span class="keyword">new</span> DefaultHttpClient();
        HttpGet hg = <span class="keyword">new</span> HttpGet(<span class="string">"http://www.oschina.net/img/logo.gif"</span>);
        <span class="keyword">final</span> Bitmap bm;

        <span class="keyword">try</span> {
            HttpResponse hr = hc.execute(hg);
            bm = BitmapFactory.decodeStream(hr.getEntity().getContent());
        } <span class="keyword">catch</span> (Exception e) {
            mHandler.obtainMessage(MSG_FAILURE).sendToTarget();
            <span class="keyword">return</span>;
        }

        mHandler.obtainMessage(MSG_SUCCESS,bm).sendToTarget();
        }
};

<span class="keyword">new</span> Thread(runnable).start();                    
</code></pre></li>
<li><p>Looper本质是一个ThreadLocal变量，每一个线程调用Looper.prepare时，都会创建为其唯一的Looper，它持有一个MessageQueue消息队列，实现Thread的消息循环和消息派发; Handler负责收发Message以及Runnable对象(post和sendMessage),包括push新消息到MessageQueue或者接收Looper从MessageQueue取出来的消息; MessageQueue是一个FIFO消息队列</p>
<p>  <img src="https://raw.githubusercontent.com/Charles-Xiao/Charles-Xiao.github.io/master/images/Looper.jpg" class="full-image" width="100%"></p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">LooperThread</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Thread</span> {</span>
      public <span class="type">Handler</span> mHandler;
      public void run() {
             <span class="type">Looper</span>.prepare();

             mHandler = <span class="keyword">new</span> <span class="type">Handler</span>() {
                      public void handleMessage(<span class="type">Message</span> msg) {

                      }                                                                                                                                                                                                                     };

             <span class="type">Looper</span>.loop();

      }
}
</code></pre></li>
<li><p>一个线程只能拥有一个Looper实例(该Looper对象可以通过Looper.myLooper()来获取)，对应着一个MessageQueue消息队列，但是可以拥有多个Handler; 主线程初始化时默认创建一个Looper对象，可以通过Looper.getMainLooper()来获取他；主线程中可以直接新建Handler，但是子线程中新建Handler需要先调用Looper.prepare()</p>
</li>
<li><p><strong>handler可能引发的内存泄露和解决方案</strong></p>
<ol>
<li>当使用内部类（包括匿名类）来创建Handler的时候，Handler对象会隐式地持有一个外部类对象（通常是一个Activity）的引用。而Handler通常会伴随着一个耗时的后台线程一起出现，这个后台线程在任务执行完毕之后，通过消息机制通知Handler，然后Handler把消息发送到UI线程。然而，如果用户在耗时线程执行过程中关闭了Activity（正常情况下Activity不再被使用，它就有可能在GC检查时被回收掉），由于这时线程尚未执行完，而该线程持有Handler的引用，这个Handler又持有Activity的引用，就导致该Activity暂时无法被回收（即内存泄露）</li>
<li><p>解决方案:</p>
<ul>
<li><p>Handler声明为静态内部类,不再持有外部类Activity,在其内部声明一个Activity的弱引用来操作Activity中的对象</p>
<pre><code>static <span class="class"><span class="keyword">class</span> <span class="title">TestHandler</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Handler</span> {</span>
    <span class="type">WeakReference</span>&lt;<span class="type">Activity</span> &gt; mActivityReference;

    <span class="type">TestHandler</span>(<span class="type">Activity</span> activity) {
        mActivityReference= <span class="keyword">new</span> <span class="type">WeakReference</span>&lt;<span class="type">Activity</span>&gt;(activity);
    }

    <span class="annotation">@Override</span>
    public void handleMessage(<span class="type">Message</span> msg) {
        <span class="keyword">final</span> <span class="type">Activity</span> activity = mActivityReference.get();
        <span class="keyword">if</span> (activity != <span class="literal">null</span>) {
            mImageView.setImageBitmap(mBitmap);
        }
    }
}
</code></pre></li>
<li><p>①在关闭Activity的时候停掉你的后台线程。线程停掉了，就相当于切断了Handler和外部连接的线，Activity自然会在合适的时候被回收；②如果你的Handler是被delay的Message持有了引用，那么使用相应的Handler的removeCallbacks()方法，把消息对象从消息队列移除        </p>
</li>
</ul>
</li>
</ol>
</li>
<li>HandlerThread是一个Looper,Handler,Thread的组合实现；在其构造函数中对Looper进行初始化，并提供一个Looper对象给新创建的Handler对象，使得Handler处理消息事件在子线程中处理</li>
</ul>
</li>
</ol>
<h3 id="毕设-WebCrawler项目">毕设-WebCrawler项目</h3><p>java优先级队列；Java多线程处理，线程池，html页面解析等</p>
<p>单例模式enum实现对MySQL数据库操作的优势</p>
<h3 id="QA">QA</h3><ol>
<li><p>如果在贵司移动开发部门做开发，主要用到哪些技术栈，我需要补充哪些技术站</p>
</li>
<li><p>跨平台应用研发，web轻应用和native app的开发前景比较看法</p>
</li>
<li><p>面试过程中有没有什么地方讲得太快或者不清楚的地方，我可以补充的，评价一下面试表现</p>
</li>
</ol>

        
      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="../../tags/实习/"> #实习 </a>
          
            <a href="../../tags/项目/"> #项目 </a>
          
        </div>
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="../../2015/03/10/Linux操作和计算机网络/">
                Linux操作和计算机网络
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2015-03-10
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分类于
            
              <a href="../../categories/编程知识/">编程知识</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="../../2015/03/10/Linux操作和计算机网络/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/03/10/Linux操作和计算机网络/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <h3 id="Http/Https/UDP/TCP/Socket区别与联系">Http/Https/UDP/TCP/Socket区别与联系</h3><p><img src="https://raw.githubusercontent.com/Charles-Xiao/Charles-Xiao.github.io/master/images/http0.png" class="full-image"></p>
<p><img src="https://raw.githubusercontent.com/Charles-Xiao/Charles-Xiao.github.io/master/images/http1.png" class="full-image"></p>
<p><img src="https://raw.githubusercontent.com/Charles-Xiao/Charles-Xiao.github.io/master/images/HttpRequest.jpeg" class="full-image"></p>
<p><img src="https://raw.githubusercontent.com/Charles-Xiao/Charles-Xiao.github.io/master/images/HttpResponse.png" class="full-image"></p>

        
      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="../../tags/Linux/"> #Linux </a>
          
            <a href="../../tags/Network/"> #Network </a>
          
        </div>
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="../../2015/03/09/Java多线程编程总结/">
                Java多进程和多线程编程总结
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2015-03-09
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分类于
            
              <a href="../../categories/java学习笔记/">java学习笔记</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="../../2015/03/09/Java多线程编程总结/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/03/09/Java多线程编程总结/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <h3 id="进程与线程之间关系">进程与线程之间关系</h3><p>一个进程对应一个程序的执行，而一个线程则是进程执行过程中的一个单独的执行序列，一个进程可以包含多个线程。线程有时候也被称为轻量级进程.  </p>
<p>首先我们明确一点，就是我们创建的每一个Java程序都是运行在一个单独的Java虚拟机进程中的，每启动一个java程序就会同时开启一个单独对应的JVM进程(也叫做JVM实例)，然后JVM进程会开始初始化类，包括初始化静态变量和静态代码块，普通变量，构造器等；然后再去寻找main()主线程作为程序执行入口,继续执行其他线程直至结束.(Android应用程序和dalvik虚拟机的关系也一样如此)</p>
<h3 id="常见的进程间通信方式">常见的进程间通信方式</h3><ol>
<li>管道与命名管道：管道允许一个进程和另一个与它有共同祖先的进程之间进行通信，命名管道允许无亲缘关系的进程间的通信,命名管道在文件系统中有对应的文件名,通过命令mkfifo或系统调用mkfifo来创建</li>
<li>套接字：可用于不同机器之间的进程间通信</li>
<li>共享内存：多个进程可以访问同一块内存空间，是最快的可用IPC形式</li>
<li>内存映射：内存映射允许任何多个进程间通信，每一个使用该机制的进程通过把一个共享的文件映射到自己的进程地址空间来实现它。</li>
<li>信号量：主要作为进程间以及同一进程不同线程之间的同步手段</li>
</ol>
<h3 id="多线程之间通信方式">多线程之间通信方式</h3><ol>
<li>“共享变量”：实现Runnable接口实现线程的共享变量或者内部类共享外围类的变量</li>
<li><p>“管道流”：</p>
<pre><code><span class="comment">/* 管道输出流和生产者线程绑定, 管道输入流和消费者线程绑定,输入输出流绑定，启动两个线程互相之间通过write和read函数就行通信 */</span>
<span class="type">PipedOutputStream</span> pos = <span class="keyword">new</span> <span class="type">PipedOutputStream</span>();
<span class="type">Producer</span> p = <span class="keyword">new</span> <span class="type">Producer</span>(pos);
<span class="type">PipedInputStream</span> pis = <span class="keyword">new</span> <span class="type">PipedInputStream</span>();
<span class="type">Consumer</span> c = <span class="keyword">new</span> <span class="type">Consumer</span>(pis);
pos.connect(pis);
p.start();
c.start();

<span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Thread</span> {</span>
    <span class="keyword">private</span> <span class="type">PipedOutputStream</span> pos;
    public <span class="type">Producer</span>(<span class="type">PipedOutputStream</span> pos) {
        <span class="keyword">this</span>.pos = pos;
    }
    public void run() {
        int i = <span class="number">8</span>;
        <span class="keyword">try</span> {
            pos.write(i);
            <span class="comment">// pis.read()</span>
        } <span class="keyword">catch</span> (<span class="type">IOException</span> e) {
            e.printStackTrace();
        }
    }
}
</code></pre></li>
</ol>
<h3 id="线程的四种创建方式">线程的四种创建方式</h3><ol>
<li>定义<strong>Thread类</strong>的子类，并重写该类的run()方法；创建Thread子类的实例，即创建了线程对象，调用线程对象的start()方法来启动该线程</li>
<li>定义<strong>Runnable接口</strong>的实现类，并重写该接口的run()方法，创建Runnable实现类的实例，并以此实例作为Thread的参数来创建Thread对象，该Thread对象才是真正的线程对象；然后调用线程对象的start()方法来启动线程</li>
<li><p>创建<strong>Callable接口</strong>的实现类，并实现call()方法，该call()方法有返回值；创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值，使用FutureTask对象作为Thread对象的target创建并启动新线程，调用FutureTask对象的get()方法来获得子线程执行结束后的返回值</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> MyCallableTest <span class="keyword">implements</span> Callable&lt;Integer&gt;{
    <span class="comment">// 实现call方法，作为线程执行体</span>
    <span class="keyword">public</span> Integer <span class="keyword">call</span>(){
        <span class="keyword">int</span> i = <span class="number">0</span>;
        <span class="keyword">for</span> ( ; i &lt; <span class="number">100</span> ; i++ ){
            System.out.<span class="keyword">println</span>(Thread.currentThread().getName()+ <span class="string">"\t"</span> + i);
        }
        <span class="comment">// call()方法可以有返回值，而且可以抛出异常</span>
        <span class="keyword">return</span> i;
    }
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) {
        <span class="comment">// 创建Callable对象</span>
        MyCallableTest myCallableTest = <span class="keyword">new</span> MyCallableTest();
        <span class="comment">// 使用FutureTask来包装Callable对象</span>
        FutureTask&lt;Integer&gt; <span class="keyword">task</span> = <span class="keyword">new</span> FutureTask&lt;Integer&gt;(myCallableTest);
        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">100</span> ; i++){
            System.out.<span class="keyword">println</span>(Thread.currentThread().getName()+ <span class="string">" \t"</span> + i);
            <span class="keyword">if</span> (i == <span class="number">20</span>){
                <span class="comment">// 实质还是以Callable对象来创建、并启动线程</span>
                <span class="keyword">new</span> Thread(<span class="keyword">task</span> , <span class="string">"callable"</span>).start();
                <span class="comment">// 线程池执行FutureTask</span>
                Executor executor = Executors.newSingleThreadExecutor();
                executor.execute(<span class="keyword">task</span>);
            }
        }
        <span class="keyword">try</span>{
            <span class="comment">// 获取线程返回值</span>
            System.out.<span class="keyword">println</span>(<span class="string">"callable返回值："</span> + <span class="keyword">task</span>.get());
        }
        <span class="keyword">catch</span> (Exception ex){
            ex.printStackTrace();
        }
    }
}
</code></pre></li>
<li><p><strong>线程池</strong>: </p>
<ul>
<li>线程池的好处在于可以更好地控制并发线程数目，提高资源利用率并防止阻塞</li>
<li>可以更好地重用线程, 减少线程创建和销毁带来的系统开销,可以设置线程定时定期执行</li>
<li>核心构造函数ThreadPoolExecutor,可以在参数中设置核心池大小，最大线程数等</li>
<li>ExecutorService接口用于实现和管理线程池,其生命周期包括三种状态：运行、关闭、终止。</li>
<li><p>四种Executors接口提供的通过ThreadFactory新建的线程池</p>
<ol>
<li><p>newFixedThreadPool(): 固定数目线程池，任意时间点，最多只能有固定数目的活动线程存在；有新任务到达时创建线程，只能放在另外的队列中等待，直到达到线程池最大大小为止，有异常则补充    </p>
<pre><code>ExecutorService threadPool = Executor.newFixedThreadPool(<span class="number">3</span>);
Runnable r = <span class="keyword">new</span> Runnable() {
    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{

    }
};
<span class="comment">// 参数可以是Thread以及Runnable对象</span>
threadPool.execute(r);
</code></pre></li>
<li><p>newCachedThreadPool：缓存型线程池，新任务到达则新建线程，线程数目大于处理需要出现闲置则回收，无大小限制</p>
</li>
<li>newSingleThreadExecutor: 单线程池，保证任务被顺序执行</li>
<li>newScheduledThreadPool: 调度型线程池，提供任务被定时和周期性执行的功能</li>
</ol>
<ul>
<li><p>自定义线程池</p>
<pre><code> ThreadPoolExecutor(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span> keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler <span class="keyword">handler</span>)

<span class="comment">/*
corePoolSize - 核心池中所保存的线程数，包括空闲线程。
maximumPoolSize-线程池中允许的最大线程数
keepAliveTime - 当线程池的工作线程空闲后，保持存活的时间
unit - keepAliveTime 参数的时间单位
workQueue - 执行前用于保持任务的队列。此队列仅保持由 execute方法提交的 Runnable任务
threadFactory - 执行程序创建新线程时使用的工厂
handler - 由于超出线程范围和队列容量而使新到达的任务被阻塞时采取的处理策略，
默认为AbortPolicy，表示无法处理新任务时抛出异常；DiscardPolicy：不能执行的任务将被删除
ThreadPoolExecutor是Executors类的底层实现
*/</span>
</code></pre></li>
</ul>
</li>
</ul>
</li>
</ol>
<pre><code>         <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolTest</span></span>{   
            <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>{   
                <span class="comment">//创建等待队列   </span>
                BlockingQueue&lt;Runnable&gt; bqueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="number">20</span>);   
                <span class="comment">//创建线程池，池中保存的线程数为3，允许的最大线程数为5  </span>
                ThreadPoolExecutor pool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">3</span>,<span class="number">5</span>,<span class="number">50</span>,TimeUnit.MILLISECONDS,bqueue);   
                <span class="comment">//创建七个任务   </span>
                Runnable t1 = <span class="keyword">new</span> MyThread();   
                Runnable t2 = <span class="keyword">new</span> MyThread();   
                Runnable t3 = <span class="keyword">new</span> MyThread();   
                Runnable t4 = <span class="keyword">new</span> MyThread();   
                Runnable t5 = <span class="keyword">new</span> MyThread();   
                Runnable t6 = <span class="keyword">new</span> MyThread();   
                Runnable t7 = <span class="keyword">new</span> MyThread();   
                <span class="comment">//每个任务会在一个线程上执行  </span>
                pool.execute(t1);   
                pool.execute(t2);   
                pool.execute(t3);   
                pool.execute(t4);   
                pool.execute(t5);   
                pool.execute(t6);   
                pool.execute(t7);   
                <span class="comment">//关闭线程池   </span>
                pool.shutdown();   
            }   
        }   

        <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>{   
            <span class="annotation">@Override</span>   
            <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>{   
                System.out.println(Thread.currentThread().getName() + <span class="string">"正在执行。。。"</span>);   
                <span class="keyword">try</span>{   
                    Thread.sleep(<span class="number">100</span>);   
                }<span class="keyword">catch</span>(InterruptedException e){   
                    e.printStackTrace();   
                }   
            }   
        }  


 * **线程池工作流程**

     &lt;img src=<span class="string">"https://raw.githubusercontent.com/Charles-Xiao/Charles-Xiao.github.io/master/images/threadpool-procedure.jpg"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"full-image"</span> /&gt;

 * **线程池的排队策略**

 <span class="number">1.</span> 默认选项是SynchronousQueue，它将任务直接提交给线程而不保持它们，一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态
 <span class="number">2.</span> 无界队列。使用无界队列（例如，不具有预定义容量的 LinkedBlockingQueue）将导致在所有 corePoolSize 线程都忙时新任务在队列中等待。这样，创建的线程就不会超过corePoolSize。（因此，maximumPoolSize的值也就无效了。）当每个任务完全独立于其他任务，即任务执行互不影响时，适合于使用无界队列；例如，在 Web页服务器中。这种排队可用于处理瞬态突发请求，当命令以超过队列所能处理的平均数连续到达时，此策略允许无界线程具有增长的可能性。
<span class="number">3.</span> 有界队列。当使用有限的 maximumPoolSizes时，有界队列（如 ArrayBlockingQueue）有助于防止资源耗尽，但是可能较难调整和控制。队列大小和最大池大小可能需要相互折衷：使用大型队列和小型池可以最大限度地降低 CPU 使用率、操作系统资源和上下文切换开销，但是可能导致人工降低吞吐量。如果任务频繁阻塞（例如，如果它们是 I/O边界），则系统可能为超过您许可的更多线程安排时间。使用小型队列通常要求较大的池大小，CPU使用率较高，但是可能遇到不可接受的调度开销，这样也会降低吞吐量。 
<span class="number">4.</span> PriorityBlockingQueue: 一个具有优先级的无限阻塞队列

 * **线程池的风险**
     1. 死锁: 死锁的产生是因为一组线程或者进程互相等待资源的释放而永远互相等待;线程池中容易产生一种新的死锁: 当核心池中所有线程都在等待阻塞队列中的某个线程的执行结果，但是该线程却因为池中没有空闲线程而没有办法执行，这样就导致互相等待的死锁.
     2. 并发错误: 线程池和其它排队机制依靠使用 wait() 和 notify() 方法,易出现问题

 * **线程池的关闭**

 1. 通过调用线程池的shutdown或shutdownNow方法来关闭线程池，它们的原理是遍历线程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程，所以无法响应中断的任务可能永远无法终止。但是它们存在一定的区别，shutdownNow首先将线程池的状态设置成STOP，然后尝试停止所有的正在执行或暂停任务的线程，并返回等待执行任务的列表，而shutdown只是将线程池的状态设置成SHUTDOWN状态，然后中断所有没有正在执行任务的线程。

2. 只要调用了这两个关闭方法的其中一个，isShutdown方法就会返回<span class="keyword">true</span>。当所有的任务都已关闭后,才表示线程池关闭成功，这时调用isTerminaed方法会返回<span class="keyword">true</span>。至于我们应该调用哪一种方法来关闭线程池，应该由提交到线程池的任务特性决定，通常调用shutdown来关闭线程池，如果任务不一定要执行完，则可以调用shutdownNow。

 * **合理配置线程池** 

     1. 任务的性质：CPU密集型任务，IO密集型任务和混合型任务；CPU密集型任务配置尽可能小的线程，如配置Ncpu+1个线程的线程池。IO密集型任务则由于线程并不是一直在执行任务，则配置尽可能多的线程，如2*Ncpu
    2. 任务的优先级：高，中和低；PriorityBlockingQueue会导致优先级低得线程永远不被执行
    3. 任务的执行时间：长，中和短；
    4. 任务的依赖性：是否依赖其他系统资源，如数据库连接：依赖数据库连接池的任务，因为线程提交SQL后需要等待数据库返回结果，如果等待的时间越长CPU空闲时间就越长，那么线程数应该设置越大，这样才能更好的利用CPU。

 * execute和submit两个方法都可以向线程池提交任务， execute()方法的返回类型是<span class="keyword">void</span>，它定义在Executor接口中；submit()方法可以返回持有计算结果的Future对象，它定义在ExecutorService接口中，它扩展了Executor接口 
</code></pre><h3 id="线程的状态变化">线程的状态变化</h3><p><img src="https://raw.githubusercontent.com/Charles-Xiao/Charles-Xiao.github.io/master/images/multiThread.png" class="full-image"></p>
<h3 id="死锁及其解决办法">死锁及其解决办法</h3><pre><code><span class="comment">/**
 * 一个简单的死锁类 当DeadLock类的对象flag==1时（td1），先锁定o1,睡眠500毫秒
 * 而td1在睡眠的时候另一个flag==0的对象（td2）线程启动，先锁定o2,睡眠500毫秒
 * td1睡眠结束后需要锁定o2才能继续执行，而此时o2已被td2锁定； td2睡眠结束后需要锁定o1才能继续执行，而此时o1已被td1锁定；
 * td1、td2相互等待，都需要得到对方锁定的资源才能继续执行，从而死锁
 */</span>
<span class="keyword">public</span> class DeadLock implements Runnable {
    <span class="keyword">public</span> <span class="built_in">int</span> flag = <span class="number">1</span>;
    <span class="comment">// 静态对象是类的所有对象共享的</span>
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">Object</span> o1 = <span class="keyword">new</span> <span class="keyword">Object</span>(), o2 = <span class="keyword">new</span> <span class="keyword">Object</span>();

    <span class="keyword">public</span> <span class="keyword">void</span> run() {
        System.out.<span class="built_in">println</span>(<span class="string">"flag="</span> + flag);
        <span class="keyword">if</span> (flag == <span class="number">1</span>) {
            <span class="keyword">synchronized</span> (o1) {
                System.out.<span class="built_in">println</span>(<span class="string">"thread1锁定 o1"</span>);
                <span class="keyword">try</span> {
                    Thread.sleep(<span class="number">500</span>);
                } <span class="keyword">catch</span> (Exception e) {
                    e.printStackTrace();
                }
                <span class="comment">// thread1等待资源o2释放</span>
                <span class="keyword">synchronized</span> (o2) {
                    System.out.<span class="built_in">println</span>(<span class="string">"1"</span>);
                }
            }
        }
        <span class="keyword">if</span> (flag == <span class="number">2</span>) {
            <span class="keyword">synchronized</span> (o2) {
                System.out.<span class="built_in">println</span>(<span class="string">"thread2锁定 o2"</span>);
                <span class="keyword">try</span> {
                    Thread.sleep(<span class="number">500</span>);
                } <span class="keyword">catch</span> (Exception e) {
                    e.printStackTrace();
                }
                <span class="comment">// thread2等待资源o1释放</span>
                <span class="keyword">synchronized</span> (o1) {
                    System.out.<span class="built_in">println</span>(<span class="string">"2"</span>);
                }
            }
        }
    }

    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) {

        DeadLock td1 = <span class="keyword">new</span> DeadLock();
        DeadLock td2 = <span class="keyword">new</span> DeadLock();
        td1.flag = <span class="number">1</span>;
        td2.flag = <span class="number">2</span>;
        <span class="comment">// td1,td2都处于可执行状态，但JVM线程调度先执行哪个线程是不确定的。</span>
        <span class="comment">// td2的run()可能在td1的run()之前运行</span>
        <span class="keyword">new</span> Thread(td1).start();
        <span class="keyword">new</span> Thread(td2).start();

    }
}
</code></pre><h3 id="多线程相关问题">多线程相关问题</h3><ol>
<li><strong>yield</strong>，表示暂停当前线程，执行其他线程(包括自身线程) 由cpu决定</li>
<li><strong>join</strong>：阻塞所在线程，等调用它的线程执行完毕，再向下执行</li>
<li><strong>sleep()方法</strong>属于Thread类中的，而<strong>wait()方法</strong>则是属于Object类；sleep()方法导致了程序暂停执行指定的时间，让出cpu给其他线程，但是他的监控状态依然保持，当指定的时间到了又会自动恢复运行状态，线程不会释放对象锁；而当调用wait()方法的时候，线程会放弃对象锁，只有针对此对象调用notify()方法后本线程才进入对象锁定池准备就绪</li>
</ol>
<h3 id="多线程同步的方法">多线程同步的方法</h3><ol>
<li>Synchronized代码块</li>
<li>Synchronized方法</li>
<li>RetrantLock可重入锁</li>
<li>ThreadLocal线程局部变量</li>
<li>Volatile可见变量</li>
</ol>

        
      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="../../tags/java/"> #java </a>
          
            <a href="../../tags/多线程/"> #多线程 </a>
          
        </div>
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
  </div>

  
  <div class="pagination">
    <a class="extend prev" rel="prev" href="../3/">&laquo;</a><a class="page-number" href="../..//">1</a><span class="space">&hellip;</span><a class="page-number" href="../3/">3</a><span class="page-number current">4</span>
  </div>


        </div>

        
      </div>


      
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <div id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      <div class="site-overview">
        <div class="site-author motion-element">
          <img class="site-author-image" src="/images/avatar.jpg" alt="CharlesXiao" />
          <p class="site-author-name">CharlesXiao</p>
        </div>
        <p class="site-description motion-element">在码农炼成之路不断挣扎……stay hungry……keep learning……</p>
        <div class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="../..//archives">
              <span class="site-state-item-count">31</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            <a href="../..//categories">
              <span class="site-state-item-count">14</span>
              <span class="site-state-item-name">分类</span>
              </a>
          </div>

          <div class="site-state-item site-state-tags">
            <a href="../..//tags">
              <span class="site-state-item-count">37</span>
              <span class="site-state-item-name">标签</span>
              </a>
          </div>

        </div>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
              <a href="https://github.com/Charles-Xiao" target="_blank">github</a>
            </span>
            
              <span class="links-of-author-item">
              <a href="http://weibo.com/2262300105/profile?topnav=1&wvr=6" target="_blank">weibo</a>
            </span>
            
              <span class="links-of-author-item">
              <a href="http://daijiale.github.io/" target="_blank">Daijiale的个人站点</a>
            </span>
            
          
        </div>

        
        

      </div>

      

    </div>
  </div>


    </div>

    <div id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; &nbsp;  2015.05.16 - 
  2016
  <span class="with-love">
    <i class="icon-heart"></i>
  </span>
  <span class="author">CharlesXiao</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>



      </div>
    </div>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="../../vendors/jquery/index.js?v=2.1.3"></script>

  
  

  
  <script type="text/javascript" src="../../vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript">
    $(document).ready(function() {
      $('.content img').each(function () {
        var $image = $(this);
        var $imageWrapLink = $image.parent('a');

        if ($imageWrapLink.size() < 1) {
          $imageWrapLink = $image.wrap('<a href="' + this.getAttribute('src') + '"></a>').parent('a');
        }
        $imageWrapLink.addClass('fancybox');
      });
    });
    $('.fancybox').fancybox({
      helpers: {
        overlay: {
          locked: false
        }
      }
    });
  </script>


  <script type="text/javascript">
  function hasMobileUA () {
    var nav = window.navigator;
    var ua = nav.userAgent;
    var pa = /iPad|iPhone|Android|Opera Mini|BlackBerry|webOS|UCWEB|Blazer|PSP|IEMobile|Symbian/g;

    return pa.test(ua);
  }

  function isDesktop () {
    return screen.width > 991 && !hasMobileUA();
  }

  function isTablet () {
    return screen.width < 992 && screen.width > 767 && hasMobileUA();
  }

  function isMobile () {
    return screen.width < 767 && hasMobileUA();
  }

  function escapeSelector (selector) {
    return selector.replace(/[!"$%&'()*+,.\/:;<=>?@[\\\]^`{|}~]/g, "\\$&")
  }
</script>

  

  <script type="text/javascript" src="../../vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="../../vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" id="motion.global">
  $(document).ready(function () {
    var body = $('body');
    var isSidebarVisible = false;
    var sidebarToggle = $('.sidebar-toggle');
    var sidebarToggleLine1st = $('.sidebar-toggle-line-first')
    var sidebarToggleLine2nd = $('.sidebar-toggle-line-middle');
    var sidebarToggleLine3rd = $('.sidebar-toggle-line-last');
    var sidebar = $('.sidebar');

    var SIDEBAR_WIDTH = '320px';
    var SIDEBAR_DISPLAY_DURATION = 300;

    var sidebarToogleLineStatusInit = {width: '100%', opacity: 1, left: 0, rotateZ: 0, top: 0};

    var sidebarToggleLine1stStatusInit = sidebarToogleLineStatusInit;
    var sidebarToggleLine1stStatusArrow = {width: '50%', rotateZ: '-45deg', top: '2px'};
    var sidebarToogleLine1stStatusClose = {width: '100%', rotateZ: '-45deg', top: '5px'};

    var sidebarToggleLine2ndStatusInit = sidebarToogleLineStatusInit;
    var sidebarToggleLine2ndStatusArrow = {width: '90%'};
    var sidebarToogleLine2ndStatusClose = {opacity: 0};

    var sidebarToggleLine3rdStatusInit = sidebarToogleLineStatusInit;
    var sidebarToggleLine3rdStatusArrow = {width: '50%', rotateZ: '45deg', top: '-2px'};
    var sidebarToogleLine3rdStatusClose = {width: '100%', rotateZ: '45deg', top: '-5px'};

    LogoAndMenuMotion();
    sidebatToggleMotion();
    postsListMotion();
    backToTopMotion();


    $(document)
      .on('sidebar.isShowing', function () {
        isDesktop() && body.velocity(
          {paddingRight: SIDEBAR_WIDTH},
          SIDEBAR_DISPLAY_DURATION
        );
        sidebarContentMotion();
      })
      .on('sidebar.isHiding', function () {});

    function LogoAndMenuMotion() {
      $.Velocity.RunSequence([
        { e: $('.brand'), p: { opacity: 1 }, o: { duration: 100 } },
        { e: $('.logo'), p: { opacity: 1, top: 0 }, o: { duration: 50} },
        
        { e: $('.logo-line-before i'), p: { translateX: "100%" }, o: { duration: 500, sequenceQueue: false } },
        { e: $('.logo-line-after i'), p: { translateX: "-100%" }, o: { duration: 500, sequenceQueue: false } },
        
        { e: $('.site-title'), p: { opacity: 1, top: 0 }, o: { duration: 200 } }
      ]);
      $('.menu-item').velocity('transition.slideDownIn', {display: null});
    }


    function backToTopMotion () {
      var b2top = $('.back-to-top');
      b2top.on('click', function () {
        body.velocity('scroll');
      });
    }

    function sidebarShowMotion () {

      sidebarToggleLine1st.velocity(sidebarToogleLine1stStatusClose);
      sidebarToggleLine2nd.velocity(sidebarToogleLine2ndStatusClose);
      sidebarToggleLine3rd.velocity(sidebarToogleLine3rdStatusClose);

      sidebar.velocity({width: SIDEBAR_WIDTH}, {
        display: 'block',
        duration: SIDEBAR_DISPLAY_DURATION,
        complete: function () {
          sidebar.addClass('sidebar-active');
          sidebar.trigger('sidebar.didShow');
        }
      });
      sidebar.trigger('sidebar.isShowing');
    }

    function sidebarHideMotion () {
      isDesktop() && body.velocity({paddingRight: 0});
      sidebar.velocity('reverse');

      sidebarToggleLine1st.velocity(sidebarToggleLine1stStatusInit);
      sidebarToggleLine2nd.velocity(sidebarToggleLine2ndStatusInit);
      sidebarToggleLine3rd.velocity(sidebarToggleLine3rdStatusInit);

      sidebar.removeClass('sidebar-active');
      sidebar.trigger('sidebar.isHiding');
    };

    function sidebarContentMotion () {
      $('.sidebar .motion-element').velocity(
        'transition.slideRightIn',
        {stagger: 50, drag: true}
      );
    }

    function postsListMotion () {
      var postMotionOptions = window.postMotionOptions || {stagger: 300, drag: true};
      $('.post').velocity('transition.slideDownIn', postMotionOptions);
    }

    function sidebatToggleMotion () {
      sidebarToggle.on('click', function () {
        isSidebarVisible ? sidebarHideMotion() : sidebarShowMotion();
        isSidebarVisible = !isSidebarVisible;
      });

      sidebarToggle.hover(function () {
        if (isSidebarVisible) {return}
        sidebarToggleLine1st.velocity('stop').velocity(sidebarToggleLine1stStatusArrow);
        sidebarToggleLine2nd.velocity('stop').velocity(sidebarToggleLine2ndStatusArrow);
        sidebarToggleLine3rd.velocity('stop').velocity(sidebarToggleLine3rdStatusArrow);
      }, function () {
        if (isSidebarVisible) {return}
        sidebarToggleLine1st.velocity('stop').velocity(sidebarToggleLine1stStatusInit);
        sidebarToggleLine2nd.velocity('stop').velocity(sidebarToggleLine2ndStatusInit);
        sidebarToggleLine3rd.velocity('stop').velocity(sidebarToggleLine3rdStatusInit);
      });
    }
  });

</script>





  

  
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
  });
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for (i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>


  
  
  


  

  
</body>
</html>
