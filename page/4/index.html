<!doctype html>
<html class="theme-next use-motion theme-next-mist">
<head><meta name="generator" content="Hexo 3.8.0">
  

<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">






  <link rel="stylesheet" type="text/css" href="../../vendors/fancybox/source/jquery.fancybox.css?v=2.1.5">


<link rel="stylesheet" type="text/css" href="../../css/main.css?v=0.4.2">


    <meta name="description" content="在码农炼成之路不断挣扎……stay hungry……keep learning……">



  <meta name="keywords" content="java,android,life,CharlesXiao">





  <link rel="shorticon icon" type="image/x-icon" href="../../favicon.ico?v=0.4.2">



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?6749450";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>


  <title> CharlesXiao‘s Blog </title>
</head>

<body>
<!--[if lte IE 8]> <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'> <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode"><img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820" alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari." style='margin-left:auto;margin-right:auto;display: block;'/></a></div> <![endif]-->
  <div class="container one-column 
  
">
    <div class="headband"></div>

    <div id="header" class="header">
      <div class="header-inner">
        <h1 class="site-meta">
  <span class="logo-line-before"><i></i></span>
  <a href="/" class="brand">
      <span class="logo">
        <i class="icon-logo"></i>
      </span>
      <span class="site-title">CharlesXiao‘s Blog</span>
  </a>
  <span class="logo-line-after"><i></i></span>
</h1>


  <ul id="menu" class="menu">
     
    <!--增加swiftype搜索功能-->
    <form class="menu-item menu-item-search">
      <input type="text" id="st-search-input" class="st-search-input st-default-search-input">
    </form>
    
    <script type="text/javascript">
      (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
      (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
      e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
      })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

      _st('install','yxUhPQ2aHyszT_1btxX9','2.0.0');
    </script>
    <!--增加swiftype搜索功能end-->
    
    
      
      <li class="menu-item menu-item-home">
        <a href="//home">
          <i class="menu-item-icon icon-home"></i> <br>
          首页
        </a>
      </li>
    
      
      <li class="menu-item menu-item-categories">
        <a href="categories">
          <i class="menu-item-icon icon-categories"></i> <br>
          分类
        </a>
      </li>
    
      
      <li class="menu-item menu-item-about">
        <a href="about">
          <i class="menu-item-icon icon-about"></i> <br>
          关于
        </a>
      </li>
    
      
      <li class="menu-item menu-item-archives">
        <a href="archives">
          <i class="menu-item-icon icon-archives"></i> <br>
          归档
        </a>
      </li>
    
      
      <li class="menu-item menu-item-tags">
        <a href="tags">
          <i class="menu-item-icon icon-tags"></i> <br>
          标签
        </a>
      </li>
    
  </ul>


      </div>
    </div>

    <div id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content">
          
  <div id="posts" class="posts-expand">
    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              从Raft到Paxos
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2018-01-04
        </span>

        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="../../2018/01/04/从Paxos到Raft/#comments">
              <span class="post-comments-count ds-thread-count" data-thread-key="2018/01/04/从Paxos到Raft/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        <h2 id="分布式一致性算法">分布式一致性算法</h2><p>一致性算法解决分布式系统里的什么问题？分布式系统有两个point：Placement和Replication。基于Raft解决数据的Replication和Recovery问题，在其上构建一些分布式系统。比如分布式消息队列、分布式日志服务、分布式锁服务、分布式块系统、分布式文件系统、分布式表格系统等。例如：</p>
<ul>
<li>将rocksdb构建在raft之上，就是一个分布式KV系统</li>
<li>使用rocksdb的kv和全局有序，可以实现类似zookeeper的全局锁服务器</li>
<li>使用rocksdb的全局有序特性，可以实现文件系统目录树，也就是分布式文件系统的NameNode</li>
<li>使用类似DI的引擎构建在raft之上，可以做一个分布式消息队列</li>
<li>基于上面的分布式消息队列，如果提供类似zookeeper的临时节点功能，可以做一个分布式journal服务</li>
</ul>
<h2 id="Paxos">Paxos</h2><h2 id="Raft">Raft</h2><h2 id="BPFT">BPFT</h2><h2 id="POW/POS">POW/POS</h2>
      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="../../tags/分布式系统/"> #分布式系统 </a>
          
            <a href="../../tags/阅读/"> #阅读 </a>
          
        </div>
      

      

      
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              常用Linux网络/内存/磁盘分析工具
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2018-01-04
        </span>

        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="../../2018/01/04/常用Linux网络:内存:磁盘分析工具/#comments">
              <span class="post-comments-count ds-thread-count" data-thread-key="2018/01/04/常用Linux网络:内存:磁盘分析工具/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        <h3 id="网络IO">网络IO</h3><ol>
<li>sar -n DEV 1 3 监控网卡IO</li>
<li><code>ethtool 网卡名</code> 查看网卡的最大速率等参数信息</li>
<li><code>netstat -nat | awk &#39;FNR&gt;2{print $NF}&#39; | sort | uniq -c</code> 查看系统TIME_WAIT状态连接数</li>
<li>查看DND信息dig命令<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dig baidu.com # 输出host的cname记录与A记录，可以看到ip地址和使用的DNS服务器信息，添加` +short`可以简化输出</span><br><span class="line">dig -x 204.152.184.167 +short # 用 -x的选项查找IP地址的主机名</span><br><span class="line">dig @ns1.google.com www.google.com 指定查询的DNS server</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="tcpdump">tcpdump</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">   tcpdump -D # 显示可以抓取的所有网络接口</span><br><span class="line"># 抓取9100端口，网卡xgbe0的TCP网络包信息，保存到aaa.pcap</span><br><span class="line">tcpdump tcp port 9100 -i xgbe0 -nn -s 0 -XX -w aaa.pcap</span><br><span class="line"></span><br><span class="line"># 指定目的或者源ip，可以使用and，or</span><br><span class="line">tcpdump -i eth0 src and dst 172.16.11.1 and port 80 -nn -s 0 -XX -w aaa.pcap</span><br><span class="line"></span><br><span class="line"># 指定主机</span><br><span class="line">tcpdump -i eth0 host 172.16.11.1 and port 80 -nn -s 0 -XX -w aaa.pcap</span><br><span class="line"></span><br><span class="line"># 抓取http包，一般是eth0，xgbe0，可以加上port 80作为条件，这里是指本机接收http请求的80端口，发出端口为随机</span><br><span class="line">tcpdump -i xgbe0 -nn -s 0 -XX -w yq41.pcap</span><br></pre></td></tr></table></figure>
<h4 id="wireshark分析网络包">wireshark分析网络包</h4><ol>
<li>tcpdump保存的文件是二进制的文件，需要下载到本地用wireshark查看</li>
<li>过滤器:tcp.stream</li>
<li><a href="https://linux.cn/article-10191-1.html" target="_blank" rel="noopener">抓包参数和结果解析</a></li>
</ol>
<h3 id="CPU">CPU</h3><ol>
<li><code>mpstat -P ALL 1 1</code> 查看cpu占用率波动情况；也可以<code>top</code>，然后1</li>
<li><p>taskset绑定进程或者线程到指定CPU的核</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">taskset -cp pid   查看进程所属核</span><br><span class="line">taskset -acp pid   查看进程及所有线程的所属核</span><br><span class="line">taskset -pc 3 pid   表示将进程pid绑定到第3个核上</span><br><span class="line">taskset -a -pc 3 pid  表示将进程pid(包括所有线程)绑定到第3个核上</span><br><span class="line">taskset -cp 1,2,3 pid</span><br></pre></td></tr></table></figure>
</li>
<li><p>pidstat 用于监控全部或指定进程的cpu、内存、线程、设备IO等系统资源的占用情况</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 查看CPU</span><br><span class="line">pidstat -p pid 3 3</span><br><span class="line"># 查看进程内存状态，用ps效果一样，RSS单位为KB</span><br><span class="line">pidstat -r -p 26716 3 3</span><br><span class="line"># 查看进程磁盘IO</span><br><span class="line">pidstat -d -p 26716 3 3</span><br><span class="line"># 查看进程上下文切换</span><br><span class="line">pidstat -wt -p 26716 3 3</span><br><span class="line"># 查看进程中的线程信息</span><br><span class="line">pidstat -t -p 26716 3 3</span><br></pre></td></tr></table></figure>
</li>
<li><p>vmstat 2 1 查看系统上下文切换</p>
</li>
</ol>
<h3 id="内存">内存</h3><h4 id="top">top</h4><ol>
<li><a href="http://blog.csdn.net/heizistudio/article/details/25125061" target="_blank" rel="noopener">top命令常用参数</a></li>
<li>P，M分别是按cpu和内存排序；mac系统使用o + 列名</li>
<li><code>sar -u 1 3</code> 监控CPU状态</li>
<li><code>top -p 345</code> 查看指定pid=345的进程,在mac中用-pid代替-p</li>
<li>%cpu参数不可靠，需要1查看每个CPU的使用率才可靠</li>
</ol>
<h4 id="free">free</h4><figure class="highlight plain"><figcaption><span>-g```：以GB为显示单位，也可以-m以MB为显示单位</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">name |    total   |    used    |   free  |   shared  |  buffers |cached </span><br><span class="line">--- | --- | --- | --- | --- | --- | ---   </span><br><span class="line">Mem: | 125 | 125 | 0 | 0 | 0 | 109 |</span><br><span class="line">-/+ buffers/cache: | | 15(上一行的used - buffers - cached) | 110(上一行的 free + buffers + cached)</span><br><span class="line">Swap: | 0 | 0 | 0</span><br><span class="line"></span><br><span class="line">对操作系统来讲，为了内存利用率最大化，会把剩余内存申请为cached，所以系统运行时间长了，cached就会比较大，对于频繁读写的系统就更加明显。used 和 free都是Mem的参数，所以 buffers/cached这两项对于操作系统来讲都是已经被使用的内存，所以呢 free的就比较少；</span><br><span class="line"></span><br><span class="line">而对于应用程序来说呢，buffers/cached等同于可用的内存，因为buffers/cached可提高程序执行的性能，当程序使用内存时，buffers/cached很快就会被使用。</span><br><span class="line"></span><br><span class="line">所以从应用程序的角度来看，应以（-/+ buffers/cached）的free 和 used为主，即我们主要与他相关的free和used就可以了  </span><br><span class="line"></span><br><span class="line">我们在观察Linux的内存使用情况时，只要没发现用swap的交换空间，就不必担心自己的内存太少。如果常常看到swap用了很多，那么你就要考虑加物理内存了，可以用`vmstat`查看swap IO状况。这也是在Linux服务器上看内存是否够用的标准。因为swap用的多，说明OS把本应该存在物理内存中的部分内存页调度到了磁盘，腾出空间给当前进程使用，等到其他进程运行时才会把这部分内存页再次调度到物理内存。</span><br><span class="line"></span><br><span class="line">#### buffer/cache/shared memory区别与联系</span><br><span class="line"></span><br><span class="line">#### pmap</span><br><span class="line">1. 查看进程内存分布状况，可以用来分析线程堆栈:`pmap -d 12345 # 12345 是进程号`</span><br><span class="line"></span><br><span class="line">#### 清理linux cache</span><br><span class="line">Kernels 2.6.16 and newer provide a mechanism to have the kernel drop the page cache and/or inode and dentry caches on command, which can help free up a lot of memory.  </span><br><span class="line"></span><br><span class="line">This is a non-destructive operation and will only free things that are completely unused. Dirty objects will continue to be in use until written out to disk and are not freeable. If you run &quot;sync&quot; first to flush them out to disk, these drop operations will tend to free more memory.</span><br><span class="line"></span><br><span class="line">	To free pagecache:</span><br><span class="line">	# echo 1 &gt; /proc/sys/vm/drop_caches</span><br><span class="line">	</span><br><span class="line">	To free dentries and inodes:</span><br><span class="line">	# echo 2 &gt; /proc/sys/vm/drop_caches</span><br><span class="line">	</span><br><span class="line">	To free pagecache, dentries and inodes:</span><br><span class="line">	echo 3 &gt; /proc/sys/vm/drop_caches</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt; 遇到报错： ```tcpdump: can&apos;t create rx ring on packet socket: cannot allocate memory```, 可以使用该命令清除cache</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 磁盘IO</span><br><span class="line"></span><br><span class="line">#### 磁盘IOPS和Throughput</span><br><span class="line"></span><br><span class="line">1. 磁盘的 IOPS，也就是在一秒内磁盘进行多少次 I/O 读写。磁盘的吞吐量，也就是每秒磁盘 I/O 的流量，即磁盘写入加上读出的数据的大小。每秒 I/O 吞吐量＝ IOPS* 平均 I/O SIZE</span><br><span class="line">2. 随机读写频繁的应用，如OLTP(Online Transaction Processing)，IOPS是关键衡量指标；对于大量顺序读写的应用，如VOD(Video On Demand)，则更关注吞吐量指标。</span><br><span class="line"></span><br><span class="line">#### 影响IOPS的因素</span><br><span class="line"></span><br><span class="line">1. 第一个**寻址时间**，考虑到被读写的数据可能在磁盘的任意一个磁道，既有可能在磁盘的最内圈(寻址时间最短)，也可能在磁盘的最外圈(寻址时间最长)，所以在计算中我们只考虑平均寻址时间，也就是磁盘参数中标明的那个平均寻址时间，这里就采用当前最多的10krmp硬盘的5ms。</span><br><span class="line">2. 第二个**旋转延时**，和寻址一样，当磁头定位到磁道之后有可能正好在要读写扇区之上，这时候是不需要额外额延时就可以立刻读写到数据，但是最坏的情况确实要磁盘旋转整整一圈之后磁头才能读取到数据，所以这里我们也考虑的是平均旋转延时，对于10krpm的磁盘就是(60s/10k)*(1/2) = 2ms。</span><br><span class="line">3. 第三个**传送时间**，磁盘参数提供我们的最大的传输速度，当然要达到这种速度是很有难度的，但是这个速度却是磁盘纯读写磁盘的速度，因此只要给定了单次 IO的大小，我们就知道磁盘需要花费多少时间在数据传送上，这个时间就是IO Chunk Size / Max Transfer Rate。</span><br><span class="line"></span><br><span class="line">#### I/O 读写的类型</span><br><span class="line"></span><br><span class="line">大体上讲，I/O 的类型可以分为：读 / 写 I/O、大 / 小块 I/O、连续 / 随机 I/O, 顺序 / 并发 I/O。在这几种类型中，我们主要讨论一下：大 / 小块 I/O、连续 / 随机 I/O, 顺序 / 并发 I/O。</span><br><span class="line"></span><br><span class="line">##### 大 / 小块 I/O</span><br><span class="line"></span><br><span class="line">这个数值指的是控制器指令中给出的连续读出扇区数目的多少。如果数目较多，如 64，128 等，我们可以认为是大块 I/O；反之，如果很小，比如 4，8，我们就会认为是小块 I/O，实际上，在大块和小块 I/O 之间，没有明确的界限。</span><br><span class="line"></span><br><span class="line">##### 连续 / 随机 I/O</span><br><span class="line"></span><br><span class="line">连续 I/O 指的是本次 I/O 给出的初始扇区地址和上一次 I/O 的结束扇区地址是完全连续或者相隔不多的。反之，如果相差很大，则算作一次随机 I/O</span><br><span class="line"></span><br><span class="line">连续 I/O 比随机 I/O 效率高的原因是：在做连续 I/O 的时候，磁头几乎不用换道，或者换道的时间很短；而对于随机 I/O，如果这个 I/O 很多的话，会导致磁头不停地换道，造成效率的极大降低。</span><br><span class="line"></span><br><span class="line">##### 顺序 / 并发 I/O</span><br><span class="line"></span><br><span class="line">从概念上讲，并发 I/O 就是指向一块磁盘发出一条 I/O 指令后，不必等待它回应，接着向另外一块磁盘发 I/O 指令。对于具有条带性的 RAID（LUN），对其进行的 I/O 操作是并发的，例如：raid 0+1(1+0),raid5 等。反之则为顺序 I/O。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### [磁盘I/O那些事](https://tech.meituan.com/about_desk_io.html)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### [Linux下的IO监控与分析](https://www.cnblogs.com/quixotic/p/3258730.html)</span><br><span class="line"></span><br><span class="line">1. `iostat -xdm 3`：磁盘IO状态</span><br><span class="line">2. `iostat -x 1 1`: 监控CPU和磁盘</span><br><span class="line">3. [iostat命令输出详解](http://www.cnblogs.com/peida/archive/2012/12/28/2837345.html)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 系统端口占用信息和进程信息</span><br><span class="line"></span><br><span class="line">- ```ps aux```只能看到pid等信息，不能看到端口号</span><br><span class="line">- ```lsof | grep pid/pname``` 查看进程信息</span><br><span class="line">- ```lsof -i:port```查看端口号port使用的进程号和连接情况</span><br><span class="line">- ```lsof -i@ip:port```使用@host:port来显示指定到指定主机的连接</span><br><span class="line">- ```lsof -iTCP```显示TCP连接</span><br><span class="line">- ```lsof -c abc``` 显示 abc 进程现在打开的文件</span><br><span class="line">- ```lsof -p 12``` 看进程号为 12 的进程打开了哪些文件</span><br><span class="line">- ```netstat -np/c/atux | grep pid/port/pname```查看进程号所占用的端口号和端口占用情况</span><br><span class="line">- `netstat -n | grep tcp | grep 侦听端口 | wc -l` : 监听端口连接数</span><br><span class="line">- `ps -eLf | grep java | wc -l`: 监控java进程的线程数</span><br><span class="line">- 远程登录 `telnet hostname`</span><br><span class="line"></span><br><span class="line">### sar命令查看网络、磁盘、CPU、内存信息</span><br><span class="line">sar - Collect, report, or save system activity information.</span><br></pre></td></tr></table></figure>
<h1 id="参数说明">参数说明</h1><p>-A 汇总所有的报告<br>-a 报告文件读写使用情况<br>-B 报告附加的缓存的使用情况<br>-b 报告缓存的使用情况<br>-c 报告系统调用的使用情况<br>-d 报告磁盘的使用情况<br>-g 报告串口的使用情况<br>-h 报告关于buffer使用的统计数据<br>-m 报告IPC消息队列和信号量的使用情况<br>-n 报告命名cache的使用情况<br>-p 报告调页活动的使用情况<br>-q 报告运行队列和交换队列的平均长度<br>-R 报告进程的活动情况<br>-r 报告没有使用的内存页面和硬盘块<br>-u 报告CPU的利用率<br>-v 报告进程、i节点、文件和锁表状态<br>-w 报告系统交换活动状况<br>-y 报告TTY设备活动状况</p>
<h1 id="系统平均load负载">系统平均load负载</h1><p>sar -q 2 2</p>
<p>参数：<br>runq-sz：运行队列的长度（等待CPU时间片来运行的进程数）<br>plist-sz：进程列表中进程（processes）和线程（threads）的数量<br>ldavg-1：最后1分钟的系统平均负载 ldavg-5：过去5分钟的系统平均负载<br>ldavg-15：过去15分钟的系统平均负载</p>
<h1 id="查看内存信息">查看内存信息</h1><p>sar -r 1 3</p>
<p>参数解释：<br>kbmemfree：剩余可用内存、单位K<br>kbmemused：已用内存、以K 为单位、该值不考虑内核自身所使用的内存<br>%memused：已用内存百分比<br>kbbuffers：已用buffer(内核所用)、单位K<br>kbcached：已用cache（内核所用）、单位K<br>kbswpfree：剩余Swap、单位K<br>kbswpused：已用Swap、单位K<br>%swpused：已用Swap百分比<br>kbswpcad：被缓存的Swap、单位K</p>
<h1 id="内存分页统计">内存分页统计</h1><p>sar -B 5 3</p>
<p>参数解释：  </p>
<p>pgpgin/s：表示每秒从磁盘或SWAP置换到内存的字节数(KB)<br>pgpgout/s：表示每秒从内存置换到磁盘或SWAP的字节数(KB)<br>fault/s：每秒钟系统产生的缺页数,即主缺页与次缺页之和(major + minor)<br>majflt/s：每秒钟产生的主缺页数. </p>
<h1 id="系统交换活动状况">系统交换活动状况</h1><p>sar -w  1 3</p>
<p>参数：<br>pswpin/s：每秒系统换入的交换页面（swap page）数量<br>pswpout/s：每秒系统换出的交换页面（swap page）数量</p>
<h1 id="CPU信息">CPU信息</h1><p>sar -u 3 5</p>
<p>参数解释：  </p>
<p>%user：显示在用户级别(application)运行使用 CPU 总时间的百分比<br>%nice：显示在用户级别，通过nice改变了进程调度优先级的进程，在用户模式下消耗的CPU时间的比例<br>%system：在内核级别(kernel)运行所使用 CPU 总时间的百分比<br>%iowait：显示用于等待I/O操作占用 CPU 总时间的百分比<br>%idle：显示 CPU 空闲时间占用 CPU 总时间的百分比 </p>
<p> 1）若 %iowait 的值过高(大于0的长时间值)，表示硬盘或者网络存在I/O瓶颈<br> 2）若 %idle 的值高但系统响应慢时，有可能是 CPU 等待分配内存，此时应加大内存容量<br> 3）若 %idle 的值持续低于1，则系统的 CPU 处理能力相对较低，表明系统中最需要解决的资源是 CPU</p>
<h1 id="磁盘信息">磁盘信息</h1><p>sar -b 3 5 </p>
<p>tps：每秒磁盘的 I/O 传输总量<br>rtps：每秒从磁盘读出的数据总量<br>wtps：每秒向磁盘写入的数据总量<br>bread/s：每秒从磁盘读出的数据量，单位为 块/s<br>bwrtn/s：每秒向磁盘写入的数据量，单位为 块/s </p>
<h1 id="网络IO-1">网络IO</h1><p>sar -n DEV 2 3<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### Linux /proc目录</span><br><span class="line">在Linux系统“一切都是文件”的思想贯彻指导下，所有进程的运行状态都可以用文件来获取。系统根目录/proc中，每一个数字子目录的名字都是运行中的进程的PID，进入任一个进程目录，可通过其中文件或目录来观察进程的各项运行指标，例如task目录就是用来描述进程中线程的</span><br></pre></td></tr></table></figure></p>
<h1 id="可以通过下面的方法获取某进程中运行中的线程数量（PID指的是进程ID)">可以通过下面的方法获取某进程中运行中的线程数量（PID指的是进程ID)</h1><p>ls /proc/PID/task | wc -l</p>
<h1 id="获取进程相关信息">获取进程相关信息</h1><p>cat /proc/PID/status</p>
<h1 id="获取内存信息">获取内存信息</h1><p>vmstat -s -S M<br>cat /proc/meminfo</p>
<h1 id="CPU信息-1">CPU信息</h1><p>cat /proc/cpuinfo<br>```</p>
<h3 id="Linux单机性能评估和优化">Linux单机性能评估和优化</h3><ol>
<li><a href="https://blog.csdn.net/hguisu/article/details/39373311" target="_blank" rel="noopener">Linux服务器性能评估与优化(一)</a></li>
<li><a href="https://blog.csdn.net/hguisu/article/details/39249775" target="_blank" rel="noopener">Linux服务器性能评估与优化(二)</a></li>
</ol>
<p>单机性能主要包括CPU、内存、网络IO、磁盘IO几个方面，互相依赖，互相影响。例如，网卡巨量吞吐或者磁盘频繁读写都可能导致CPU系统调用过高而占用率很高。CPU一般认为user%+sys%&lt;70%为良好状态，内存一般认为si和swap out都为0为良好状态，磁盘认为iowait%&lt;20%为良好状态</p>

      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="../../tags/Linux/"> #Linux </a>
          
            <a href="../../tags/阅读/"> #阅读 </a>
          
        </div>
      

      

      
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              Mysql 长连接与短连接
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2017-12-09
        </span>

        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="../../2017/12/09/Mysql 长连接与短连接/#comments">
              <span class="post-comments-count ds-thread-count" data-thread-key="2017/12/09/Mysql 长连接与短连接/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        <h4 id="概念说明">概念说明</h4><ol>
<li><strong>短连接</strong>：是指程序和数据库通信时需要建立连接，执行操作后，连接关闭。短连接简单来说就是每一次操作数据库，都要打开和关闭数据库连接，基本步骤是：连接→数据传输→关闭连接。</li>
<li><strong>长连接</strong>：是指程序之间的连接在建立之后，就一直打开，被后续程序重用，基本步骤是：连接→数据传输→保持连接→数据传输……。使用长连接的初衷是减少连接的开销，尽管MySQL的连接比其他数据库要快得多。长连接在没有数据通信时，定时发送数据包，以维持连接状态。</li>
<li><strong>数据库连接池</strong>：是一些网络代理服务或应用服务器实现的特性，如J2EE服务器，它实现了一个持久连接的“池”，允许其他程序、客户端来连接，这个连接池将被所有连接的客户端共享使用，连接池可以节省打开数据库的时间，加速连接，也可以减少数据库连接，降低数据库服务器的负载；它是预先打开N个数据库连接，把它们缓存起来，当需要使用数据库的时候就直接使用这些已经打开的连接，节省时间</li>
<li><strong>J2EE数据库连接池的原理</strong>：<ul>
<li>J2EE服务器启动时会建立一定数量的池连接，并一直维持不少于此数目的池连接。</li>
<li>客户端程序需要连接时，池驱动程序会返回一个未使用的池连接并将其表记为忙。</li>
<li>如果当前没有空闲连接，池驱动程序就新建一定数量的连接，新建连接的数量由配置参数决定。</li>
<li>当使用的池连接调用完成后，池驱动程序将此连接表记为空闲，其他调用就可以使用这个连接。</li>
</ul>
</li>
</ol>
<h4 id="适用场景">适用场景</h4><ol>
<li><strong>长连接优劣势</strong><ul>
<li>从客户端的角度来说，使用长连接可以不用每次创建新连接，若客户端对MySQL服务器的连接请求很频繁，永久连接将更加高效。</li>
<li>从服务器的角度来看，情况则略有不同，它可以节省创建连接的开销，但维持连接也是需要内存的。如果滥用长连接的话，可能会使用过多的MySQL服务器连接。现代的操作系统可以拥有几千个MySQL连接，但很有可能绝大部分都是睡眠（sleep）状态的，这样的工作方式不够高效，而且连接占据内存，也会导致内存的浪费。</li>
</ul>
</li>
<li><strong>长连接主要用于在少数客户端与服务端的频繁通信</strong>，因为这时候如果用短连接频繁通信常会发生Socket出错，并且频繁创建Socket连接也是对资源的浪费；但是对于服务端来说，长连接也会耗费一定的资源，需要专门的线程（unix下可以用进程管理）来负责维护连接状态。</li>
<li><strong>长连接</strong>是一些驱动、驱动框架、ORM工具的特性，由驱动来保持连接句柄的打开，以便后续的数据库操作可以重用连接，从而减少数据库的连接开销。而<strong>连接池</strong>是应用服务器的组件，它可以通过参数来配置连接数、连接检测、连接的生命周期等。</li>
</ol>
<h4 id="注意事项">注意事项</h4><ol>
<li>我们一般使用mysql -uroot -p只不过是使用了管理员的身份来创建一个connection，从而登录mysql，mysql的连接过程，内部实际上是经过tcp/ip协议的，当然mysql封装了tcp/ip有自己的一套协议。mysql是会创建一个线程来处理到来的连接的，我们可以在mysql中show status;然后在连接mysql，再次show status就可以看到Thread_connected的数量会增加1</li>
<li>在生产繁忙的系统中，连接也可能会受到系统端口数的限制，如果要每秒建立几千个连接，那么连接断开后，端口不会被马上回收利用，必须经历一个“FIN”阶段的等待，直到可被回收利用为止，这样就可能会导致端口资源不够用。</li>
<li>如果客户端和MySQL数据库之间有连接池或Proxy代理，一般在客户端推荐使用短连接。对于长连接的使用一定要慎重，不可滥用</li>
<li>如果使用了长连接而长期没有对数据库进行任何操作，那么在timeout值(默认8小时)后，mysql server就会关闭此连接，而客户端在执行查询的时候就会得到一个类似于“MySQL server has gone away“这样的错误。在使用mysql_real_connect连接数据库之后，再使用mysql_options( &amp;mysql, MYSQL_OPT_RECONNECT, … ) 来设置为自动重连。</li>
</ol>
<h4 id="常用工具">常用工具</h4><ol>
<li>查看mysql连接数：<code>mysqladmin -uroot -p  processlist</code></li>
</ol>

      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="../../tags/Mysql/"> #Mysql </a>
          
            <a href="../../tags/databse/"> #databse </a>
          
        </div>
      

      

      
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              如何实现多个数据库分片的list_objects操作
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2017-12-09
        </span>

        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="../../2017/12/09/如何实现多个数据库分片的list_objects操作/#comments">
              <span class="post-comments-count ds-thread-count" data-thread-key="2017/12/09/如何实现多个数据库分片的list_objects操作/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        <h4 id="业务场景">业务场景</h4><p>我们需要实现一个类似于Linux中ls命令的功能，用户可以用该功能来查看的bucket里边object列表，这些object信息存储在mysql meta表和shard meta表中；正常情况下一个bucket中的所有object存储在一张meta表中；然而当一个bucket中的object数量十分庞大时，我们采用了水平分表的方式，将这些object通过哈希方式分散到了1024个shard meta表中，以避免单表行数过大带来的性能问题。  </p>
<p>因此，ls功能的实现需要考虑以上两种情景，分别是单表和多表的list；list功能需要支持delimiter来折叠文件夹(类似于linux中ls命令，根据该参数来决定是否展开当前目录下的子目录)，marker来指定每次查询的起始位置，maxKeys来指定每次返回数目，prefix来筛选出以前缀开头的object。单表list我们可以直接采用mysql order来保证结果有序；如果object分散在了1024个shard meta表中，要每次拿出前n个就比较困难了，因为数据只是单表有序的，要想全局有序，就还得做一些处理。</p>
<h4 id="分表hash方式">分表hash方式</h4><p>如何把很多object通过哈希方式分散到了1024个shard meta表中？如下代码所示，我们根据bucket和object构建一个url字符串，然后求MD5值，然后按4位做异或操作，最后对shard数目取模，就可以把object都随机分散到1024个表里了；MD5算法对原信息进行数学变换后得到的一个128位(bit)的特征码作为数据摘要，具有高度的离散性，原信息的一点点变化就会导致MD5的巨大变化。</p>
<pre><code><span class="function"><span class="keyword">void</span> <span class="title">GenUrl</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; bucket, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; object, <span class="built_in">std</span>::<span class="built_in">string</span>&amp; url)</span> </span>{
    url.append(<span class="string">"bs://"</span>);
    url.append(bucket);
    url.append(<span class="string">"/"</span>);
    url.append(object);
}

<span class="function"><span class="keyword">int32_t</span> <span class="title">GetShardKey</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;bucket, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;object)</span> </span>{
    <span class="built_in">std</span>::<span class="built_in">string</span> url = <span class="string">""</span>;
    GenUrl(bucket, object, url);
    <span class="built_in">std</span>::<span class="built_in">string</span> md5sum = MD5(url);
    <span class="keyword">const</span> <span class="keyword">uint32_t</span> *p = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">uint32_t</span>*&gt;(md5sum.data());
    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">int32_t</span>&gt;((p[<span class="number">0</span>]^p[<span class="number">1</span>]^p[<span class="number">2</span>]^p[<span class="number">3</span>]) % BUCKET_SHARD_NUM);
}
</code></pre><h4 id="单表list">单表list</h4><ul>
<li><p><strong>解决方案</strong></p>
<ul>
<li>每次查询都是根据请求参数组装成一条SQL，查出需要的object  <code>select object, etag, size,…… from meta where bucket_id = * and shard_key = * order by object limit 0,1001</code></li>
<li>针对子文件夹的折叠处理：<ul>
<li>ls操作需要支持折叠文件夹操作，以免一个文件夹下边有很多子文件夹，而且子文件夹里有很多文件的时候，会导致多次ls也一直在一个子文件夹里边，支持折叠子文件夹，用户才可以ls出文件夹下边的所有子文件夹</li>
<li>解决方案：当遇到子文件夹中文件多的时候，每次都能list出指定数目的objects，这些objects可能都是一个子文件中的文件；因为用户需要折叠子文件夹，因此我们进行跳过子文件夹的处理，极端情况下这批objects都在一个子文件夹中，此时我们需要根据最后一个object name来判断是否在子文件中，如果该批objects在子文件中，此时我们会对下次查询的起始位置做一个++操作，确保下次查询跳过这个已经获取了的子文件夹；如此进行三次重试，至少保证一次请求可以拿出3个子文件夹给用户</li>
</ul>
</li>
<li>marker的处理：如果需要跳过文件夹，对marker++；例如正常情况下，object &gt; marker；如果要跳过文件夹，变成object &gt;= marker++</li>
</ul>
</li>
<li><p><strong>核心代码</strong></p>
<pre><code><span class="comment">// 需要跳过文件夹时对marker的处理</span>
<span class="built_in">string</span> BucketModel::ProcessMarkerWithDelimiter(<span class="keyword">const</span> <span class="built_in">string</span>&amp; marker,
                    <span class="keyword">const</span> <span class="built_in">string</span>&amp; prefix, <span class="keyword">char</span> delimiter) {
    <span class="comment">//prefix empty, or prefix not empty and marker start with prefix</span>
    <span class="keyword">if</span> (prefix.empty() || marker.compare(<span class="number">0</span>, prefix.length(), prefix) == <span class="number">0</span>) {
        size_t pos = marker.find_first_of(delimiter, prefix.length());
        <span class="built_in">string</span> new_marker;
        <span class="keyword">if</span> (<span class="built_in">std</span>::<span class="built_in">string</span>::npos != pos) {
            ++pos;
            new_marker = marker.substr(<span class="number">0</span>, pos);
            new_marker[new_marker.length()-<span class="number">1</span>]++;
            <span class="keyword">return</span> new_marker;
        } <span class="keyword">else</span> {
            <span class="keyword">return</span> marker;
        }
    }
    <span class="keyword">return</span> marker;
}
</code></pre></li>
</ul>
<h4 id="多表list">多表list</h4><ul>
<li><p><strong>解决方案</strong></p>
<ul>
<li>利用Golang携程并发发送1024个shardMeta的list请求，也就是1024次SQL查询，拿到1024个请求结果之后，对结果做归并和提取处理，最终得出与单表listObject接口逻辑一致的结果。</li>
</ul>
</li>
<li><p><strong>核心代码</strong></p>
<pre><code>// merge two <span class="type">ObjectInfo</span> struct <span class="keyword">type</span> slice, max length <span class="keyword">is</span> maxKeys
func merge(maxKeys <span class="type">int</span>, left, right []<span class="type">ObjectInfo</span>) []<span class="type">ObjectInfo</span> {
    <span class="keyword">var</span> <span class="literal">result</span> []<span class="type">ObjectInfo</span>

    <span class="keyword">for</span> len(left) &gt; <span class="number">0</span> || len(right) &gt; <span class="number">0</span> {
        <span class="keyword">if</span> len(left) == <span class="number">0</span> {
            <span class="literal">result</span> = append(<span class="literal">result</span>, right...)
            <span class="keyword">break</span>
        }
        <span class="keyword">if</span> len(right) == <span class="number">0</span> {
            <span class="literal">result</span> = append(<span class="literal">result</span>, left...)
            <span class="keyword">break</span>
        }
        <span class="keyword">if</span> left[<span class="number">0</span>].<span class="type">Key</span> &lt;= right[<span class="number">0</span>].<span class="type">Key</span> {
            <span class="literal">result</span> = append(<span class="literal">result</span>, left[<span class="number">0</span>])
            left = left[<span class="number">1</span>:]
        } <span class="keyword">else</span> {
            <span class="literal">result</span> = append(<span class="literal">result</span>, right[<span class="number">0</span>])
            right = right[<span class="number">1</span>:]
        }
        <span class="keyword">if</span> len(<span class="literal">result</span>) &gt;= maxKeys {
            <span class="keyword">return</span> <span class="literal">result</span>[<span class="number">0</span>:maxKeys]
        }
    }
    <span class="keyword">if</span> len(<span class="literal">result</span>) &gt;= maxKeys {
        <span class="keyword">return</span> <span class="literal">result</span>[<span class="number">0</span>:maxKeys]
    }
    <span class="keyword">return</span> <span class="literal">result</span>
}
</code></pre></li>
<li><p><strong>方案重难点</strong></p>
<ul>
<li><p><strong>Cache嗅探机制</strong>：<br>List ShardMeta每次会通过VIP从Bucket取回1024个表数据，为了提高请求响应速度，当请求频率达到阈值时，这1024个表的数据会分别以ApiType+Bucket+ShardKey为key保存到Cache中，如何在充分利用Cache降低请求响应速度和对数据库压力的同时，也尽量减少与Cache之间的通信显得尤为重要。  </p>
<p>  在充分考虑了系统Cache的实现机制之后，设计了预读取方案来降低与Cache之间的通信次数，将1024个ShardMeta的请求任务队列切割出一小部分(10个)作为嗅探Cache的任务，多个goroutine并发去读Cache，如果嗅探Cache的ShardMeta都能读取到，说明Cache中能读到1024个表数据，可以继续读Cache，否则后续请求都直接请求数据库，不再读Cache，这样可以把每次List Shard请求<span style="color:red">读Cache的次数从1024次降低到10次</span>。  </p>
</li>
<li><p><strong>性能优化</strong>：<br>List ShardMeta是一个重请求，相当于所有操作开销都放大1024倍，然而又必须满足客户对耗时的要求，我主要从以下几个方面做了性能优化 </p>
<p>  <strong>减少互斥锁粒度，充分利用Golang atomic函数</strong>：在归并1024个表数据时，只给归并过程和写最终结果的少量代码加锁，利用atomic变量做全局信号量，保证变量操作的原子性  </p>
<p>  <strong>并发Goroutine发送请求和进行Json-Struct转换</strong>：利用Golang Goroutine给Bucket并发发请求，加快网络请求速度；归并结果时需要多次进行byte数组和Struct之间的转换，而Golang自带json库函数效率低，也将该过程利用Goroutine来并发完成，加快转换速度</p>
<p>  <strong>通过VIP分发请求</strong>：1024个请求如果并发到本机Bucket服务，会对本机服务造成巨大压力，而且由于单进程资源有限，会导致响应速度很慢。因此采用了将1024个请求发送给VIP的方式，均衡地分散到服务集群数千台机器上，保证了处理速度，降低了单机压力 </p>
</li>
<li><p><strong>异常处理机制</strong>：<br>List ShardMeta每次1024个数据库请求，如果有一个请求遇到网络超时等错误，返回结果不正常，就会导致整个请求返回结果有误；因此我采用了标志量和超时机制来实现异常处理，一旦单个请求出现异常，标志量置位TRUE，其他请求不再继续；同时采用Goroutine等待超时信号量的方式来处理超时情况，如果工作任务出现错误，一旦从任务通道取不到任务超过50ms，Goroutine自动结束操作，给用户返回错误提示</p>
</li>
</ul>
</li>
</ul>
<h4 id="json转换函数性能低的解决方案">json转换函数性能低的解决方案</h4><p>Golang自带json Unmarshal函数转化包含1000个obj的list object接口返回结果时，耗时10ms，效率很低；主要有<strong>两种解决方案</strong>：</p>
<ul>
<li>一种是减少转化次数以及缩小锁的范围，并发地去做转化</li>
<li>另一种是使用开源库，性能能够提升2-4倍，例如easyjson，ffjson</li>
</ul>
<h4 id="并发等待是等goroutine还是Channel">并发等待是等goroutine还是Channel</h4><p>Goroutine一般会结合WaitGroup来使用，wg相当于一个同步信号量，等到wg减到0，才开始下一步的逻辑</p>
<ul>
<li>如果wg等待goroutine，也就是说先给wg.add(Goroutine数目)，然后使用<code>defer this.wg.Done()</code>和<code>return</code>来指定当函数结束(也意味着Goroutine结束)时就给wg减一，这样能确保最终协程都结束时，wg也不再等待，开始下一步的逻辑</li>
<li>如果wg等待channel里边的任务，会存在一些异常问题，例如channel任务没被消费完，Goroutine都异常中止了，那么wg永远等不到减到0的那一刻，程序就会hang住了</li>
</ul>
<h4 id="耗时正比例增加因为多打了log">耗时正比例增加因为多打了log</h4><p>上线之后从某一天开始发现list请求耗时突增到上线时的6倍，非常奇怪，而且耗时随着每次请求数据量的增加而增加，经过git diff版本分析代码，发现是后续debug增加了几行日志打印，打印数据为每个shardMeta返回的数据，而且打印日志的代码被mutex互斥锁锁住，也就意味着每次要串行打印n个object数据，打印1024次，每次耗时10ms，从而导致耗时剧增；后来删除log之后耗时恢复到正常水平 </p>
<h4 id="Golang相关技术和踩坑">Golang相关技术和踩坑</h4><h5 id="defer和WaitGroup">defer和WaitGroup</h5><ol>
<li>在Golang中，defer表达式通常用来处理一些清理和释放资源的操作。defer后面的表达式会被放入一个列表中，在当前方法返回的时候，列表中的表达式就会被执行。一个方法中可以在一个或者多个地方使用defer表达式</li>
<li>defer表达式中变量的值在defer表达式被定义时就已经明确</li>
<li>defer表达式的调用顺序是按照先进后出的方式</li>
<li>defer还可以用于在 return 之后修改函数的返回值</li>
<li>Go语言中, panic用于抛出异常, recover用于捕获异常. </li>
</ol>
<h4 id="参考链接">参考链接</h4><p>1.<a href="https://xiaozhou.net/something-about-defer-2014-05-25.html" target="_blank" rel="noopener">Golang中defer的那些事</a></p>

      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="../../tags/Golang/"> #Golang </a>
          
            <a href="../../tags/Mysql/"> #Mysql </a>
          
            <a href="../../tags/databse/"> #databse </a>
          
        </div>
      

      

      
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              Linux终端利器tmux指南
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2017-12-07
        </span>

        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="../../2017/12/07/Linux终端利器tmux指南/#comments">
              <span class="post-comments-count ds-thread-count" data-thread-key="2017/12/07/Linux终端利器tmux指南/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        <h4 id="tmux简介">tmux简介</h4><p>tmux是BSD实现的Screen替代品，相对于Screen，它更加先进：支持屏幕切分，而且具备丰富的命令行参数，使其可以灵活、动态的进行各种布局和操作。它可以做到一条命令就启动起来(强大的配置)</p>
<h5 id="安装方法">安装方法</h5><table>
<thead>
<tr>
<th>系统</th>
<th>安装命令</th>
</tr>
</thead>
<tbody>
<tr>
<td>mac</td>
<td><code>brew install tmux</code>（前提需要安装homebrew)</td>
</tr>
<tr>
<td>ubuntu</td>
<td><code>sudo apt-get install tmux</code></td>
</tr>
<tr>
<td>centos</td>
<td><code>yum install -y tmux</code></td>
</tr>
<tr>
<td>其它</td>
<td>下载源码配置-编译-链接-安装</td>
</tr>
</tbody>
</table>
<h5 id="概念名词">概念名词</h5><p>在你输入tmux开启了tmux服务器后，会首先创建一个会话，而这个会话则会首先创建一个窗口，其中仅包含一个面板; 也就是说，这里看到的所谓终端控制台应该称作tmux的一个面板，虽然其使用方法与终端控制台完全相同。</p>
<table>
<thead>
<tr>
<th>概念</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>server服务器</td>
<td>输入tmux命令时就开启了一个服务器</td>
</tr>
<tr>
<td>session会话</td>
<td>一个服务器可以包含多个会话</td>
</tr>
<tr>
<td>window窗口</td>
<td>通过c-b-c创建，所有窗口的名称显示在底部状态栏上，一个会话可以包含多个窗口</td>
</tr>
<tr>
<td>pane面板</td>
<td>窗口里面的分屏，可通过c-b-%创建，一个窗口可以包含多个面板</td>
</tr>
</tbody>
</table>
<h5 id="使用场景和优点">使用场景和优点</h5><ol>
<li>tmux命令开启一个终端之后，可以在这个终端里开启多个windows，同时还可以把windows split成多个pane，并行工作</li>
<li>ssh登录远程主机的情景下，一旦ssh断开，那么当前账户登录的任务就被取消了，但是使用 tmux 可以在断开之后继续工作，下次登录可以查看</li>
</ol>
<h4 id="常用默认快捷键">常用默认快捷键</h4><p>tmux里边所有快捷键都默认以c-b作为前缀，也就是以ctrl+b开头，当然你也可以自行配置；</p>
<ol>
<li>基本命令<ul>
<li><code>tmux</code>创建一个tmux session</li>
<li><code>tmux new -s session_name</code>创建一个叫做session_name的 session</li>
<li><code>tmux ls\tmux list-sessions</code>列出现有的所有session</li>
<li><code>tmux info</code>列出所有的 session, window, pane, 运行的进程号等</li>
<li><code>tmux list-keys</code>列出所有可以的快捷键和其运行的 tmux 命令</li>
<li><code>tmux list-commands</code>列出所有的 tmux 命令及其参数</li>
<li><code>tmux at(attach) -t session_name</code>进入叫做session_name的session</li>
<li><code>tmux detach\c-b-d</code>离开当前开启的session</li>
<li><code>tmux kill-session -t session</code>关闭开启的session</li>
</ul>
</li>
<li><p>基本操作</p>
<ul>
<li><code>d</code>脱离并保存当前会话,可暂时返回Shell界面,tmux仍在后台运行</li>
<li><code>ctrl + z</code>挂起当前会话</li>
<li><code>s</code>选择并切换会话；在同时开启了多个会话时使用</li>
<li><code>D</code>选择要脱离的会话；在同时开启了多个会话时使用</li>
<li><code>:</code>进入命令行模式；此时可输入支持的命令，例如 kill-server 关闭所有tmux会话</li>
<li><code>t</code>显示当前的时间</li>
</ul>
</li>
<li><p>窗口操作</p>
<ul>
<li><code>c</code>创建新窗口</li>
<li><code>&amp;</code>关闭当前窗口</li>
<li><code>[0-9]</code>数字键切换到指定窗口</li>
<li><code>p</code>切换至上一窗口</li>
<li><code>n</code>切换至下一窗口</li>
<li><code>l</code>切换到最后使用的窗口</li>
<li><code>l</code>前后窗口间互相切换</li>
<li><code>w</code>通过窗口列表切换窗口</li>
<li><code>,</code>重命名当前窗口，便于识别</li>
<li><code>.</code>修改当前窗口编号，相当于重新排序</li>
<li><code>f</code>在所有窗口中查找关键词，便于窗口多了切换</li>
</ul>
</li>
<li>(面板)分屏操作<ul>
<li><code>?</code>显示快捷键帮助</li>
<li><code>&quot;</code>将当前面板上下分屏（建议设置成 |）</li>
<li><code>%</code>将当前面板左右分屏（建议设置成 -）</li>
<li><code>x</code>关闭当前分屏</li>
<li><code>q</code>显示面板编号</li>
<li><code>o</code>选择当前窗口中下一个面板</li>
<li><code>;</code>切换到最后一个使用的面板</li>
<li><code>方向键</code>移动光标选择对应面板</li>
<li><code>z</code>最大化当前所在面板</li>
<li><code>!</code>面板转变成窗口</li>
</ul>
</li>
</ol>
<h4 id="推荐配置">推荐配置</h4><p>如果你有个性化配置的需要，包括快捷键，状态栏等，那么修改~/.tmux.conf文件可以达到你的目的，让你用起来更符合自己的习惯; 也可以通过配置~/.bashrc每次ssh登录时都默认attach或者新建tmux会话</p>
<ol>
<li>tmux.conf配置快捷键，配色等</li>
</ol>
<pre><code># 开启鼠标生效
<span class="operator"><span class="keyword">set</span>-<span class="keyword">option</span> -g mouse <span class="keyword">on</span>

#设置前缀为Ctrl + x
<span class="keyword">set</span> -g prefix C-x
unbind C-b

# <span class="keyword">key</span> bindings <span class="keyword">for</span> horizontal <span class="keyword">and</span> vertical panes
unbind %
bind | split-window -h      # 使用|竖屏，方便分屏
unbind <span class="string">'"'</span>
bind - split-window -v      # 使用-横屏，方便分屏

# <span class="keyword">status</span> bar <span class="keyword">with</span> <span class="keyword">load</span> <span class="keyword">and</span> <span class="keyword">time</span>
<span class="keyword">set</span> -g <span class="keyword">status</span>-bg blue
<span class="keyword">set</span> -g <span class="keyword">status</span>-fg <span class="string">'#bbbbbb'</span>
<span class="keyword">set</span> -g <span class="keyword">status</span>-<span class="keyword">left</span>-fg green
<span class="keyword">set</span> -g <span class="keyword">status</span>-<span class="keyword">left</span>-bg blue
<span class="keyword">set</span> -g <span class="keyword">status</span>-<span class="keyword">right</span>-fg green
<span class="keyword">set</span> -g <span class="keyword">status</span>-<span class="keyword">right</span>-bg blue
<span class="keyword">set</span> -g <span class="keyword">status</span>-<span class="keyword">left</span>-length <span class="number">90</span>
<span class="keyword">set</span> -g <span class="keyword">status</span>-<span class="keyword">right</span>-length <span class="number">90</span>
<span class="keyword">set</span> -g <span class="keyword">status</span>-<span class="keyword">left</span> <span class="string">'[#(whoami)]'</span>
<span class="keyword">set</span> -g <span class="keyword">status</span>-<span class="keyword">right</span> <span class="string">'[#(date +" %m-%d %H:%M ")]'</span>
<span class="keyword">set</span> -g <span class="keyword">status</span>-justify <span class="string">"centre"</span>
<span class="keyword">set</span> -g window-<span class="keyword">status</span>-<span class="keyword">format</span> <span class="string">'#I #W'</span>
<span class="keyword">set</span> -g window-<span class="keyword">status</span>-<span class="keyword">current</span>-<span class="keyword">format</span> <span class="string">' #I #W '</span>
setw -g window-<span class="keyword">status</span>-<span class="keyword">current</span>-bg blue
setw -g window-<span class="keyword">status</span>-<span class="keyword">current</span>-fg green
# pane <span class="built_in">number</span> display
<span class="keyword">set</span> -g display-panes-active-colour colour33 #blue
<span class="keyword">set</span> -g display-panes-colour colour166 #orange
<span class="keyword">set</span> -g base-<span class="keyword">index</span> <span class="number">1</span>
<span class="keyword">set</span> -g pane-base-<span class="keyword">index</span> <span class="number">1</span>
<span class="keyword">set</span> -g display-<span class="keyword">time</span> <span class="number">3000</span>
<span class="keyword">set</span> -g history-<span class="keyword">limit</span> <span class="number">10000</span>

# copy-<span class="keyword">mode</span> 将快捷键设置为 vi 模式
setw -g <span class="keyword">mode</span>-keys vi

# 选中窗口
bind-<span class="keyword">key</span> k <span class="keyword">select</span>-pane -U
bind-<span class="keyword">key</span> j <span class="keyword">select</span>-pane -D
bind-<span class="keyword">key</span> h <span class="keyword">select</span>-pane -L
bind-<span class="keyword">key</span> l <span class="keyword">select</span>-pane -R</span>
</code></pre><ol>
<li><p>~/.bash_rc配置登录时自动进入tmux</p>
<pre><code>tmux_init(<span class="function">)</span>
{
    tmux<span class="instruction"> new-session </span>-s <span class="string">"xiaoyong"</span> -d -n <span class="string">"local"</span>    <span class="comment"># 开启一个会话</span>
    tmux<span class="instruction"> new-window </span>-n <span class="string">"other"</span>          <span class="comment"># 开启一个窗口</span>
    tmux split-window -h                <span class="comment"># 开启一个竖屏</span>
    tmux split-window -v                <span class="comment"># 开启一个横屏</span>
    tmux -2 attach-session -d           <span class="comment"># tmux -2强制启用256color，连接已开启的tmux</span>
}

<span class="comment"># 判断是否已有开启的tmux会话，没有则开启</span><span class="instruction">
if </span>which tmux 2&gt;&amp;1 &gt;/dev/null; then
    test -z <span class="string">"$TMUX"</span> &amp;&amp;<span class="function"> (</span>tmux attach || tmux_init<span class="function">)</span>
fi
</code></pre></li>
</ol>
<h4 id="参考链接">参考链接</h4><ol>
<li><a href="http://wdxtub.com/2016/03/30/tmux-guide/" target="_blank" rel="noopener">tmux指南</a></li>
<li><strong> tmux如何将内容复制到系统clipboard ? </strong> Mac下如果用 iterm2 可以在 preference 下选择 Applications in terminal may access  clipboard</li>
</ol>

      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="../../tags/Linux/"> #Linux </a>
          
            <a href="../../tags/tmux/"> #tmux </a>
          
        </div>
      

      

      
      
    </div>
  </div>


    
  </div>

  
  <div class="pagination">
    <a class="extend prev" rel="prev" href="../3/">&laquo;</a><a class="page-number" href="../../">1</a><span class="space">&hellip;</span><a class="page-number" href="../3/">3</a><span class="page-number current">4</span><a class="page-number" href="../5/">5</a><span class="space">&hellip;</span><a class="page-number" href="../17/">17</a><a class="extend next" rel="next" href="../5/">&raquo;</a>
  </div>


        </div>

        
      </div>


      
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <div id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      <div class="site-overview">
        <div class="site-author motion-element">
          <img class="site-author-image" src="/images/avatar.jpg" alt="CharlesXiao">
          <p class="site-author-name">CharlesXiao</p>
        </div>
        <p class="site-description motion-element">在码农炼成之路不断挣扎……stay hungry……keep learning……</p>
        <div class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="../../archives">
              <span class="site-state-item-count">84</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            <a href="../../categories">
              <span class="site-state-item-count">17</span>
              <span class="site-state-item-name">分类</span>
              </a>
          </div>

          <div class="site-state-item site-state-tags">
            <a href="../../tags">
              <span class="site-state-item-count">76</span>
              <span class="site-state-item-name">标签</span>
              </a>
          </div>

        </div>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
              <a href="https://github.com/Charles-Xiao" target="_blank">github</a>
            </span>
            
              <span class="links-of-author-item">
              <a href="http://weibo.com/2262300105/profile?topnav=1&wvr=6" target="_blank">weibo</a>
            </span>
            
              <span class="links-of-author-item">
              <a href="http://daijiale.github.io/" target="_blank">Daijiale的个人站点</a>
            </span>
            
          
        </div>

        
        

      </div>

      

    </div>
  </div>


    </div>

    <div id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; &nbsp;  2015.05.16 - 
  2018
  <span class="with-love">
    <i class="icon-heart"></i>
  </span>
  <span class="author">CharlesXiao</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>



      </div>
    </div>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="../../vendors/jquery/index.js?v=2.1.3"></script>

  
  

  
  <script type="text/javascript" src="../../vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript">
    $(document).ready(function() {
      $('.content img').each(function () {
        var $image = $(this);
        var $imageWrapLink = $image.parent('a');

        if ($imageWrapLink.size() < 1) {
          $imageWrapLink = $image.wrap('<a href="' + this.getAttribute('src') + '"></a>').parent('a');
        }
        $imageWrapLink.addClass('fancybox');
      });
    });
    $('.fancybox').fancybox({
      helpers: {
        overlay: {
          locked: false
        }
      }
    });
  </script>


  <script type="text/javascript">
  function hasMobileUA () {
    var nav = window.navigator;
    var ua = nav.userAgent;
    var pa = /iPad|iPhone|Android|Opera Mini|BlackBerry|webOS|UCWEB|Blazer|PSP|IEMobile|Symbian/g;

    return pa.test(ua);
  }

  function isDesktop () {
    return screen.width > 991 && !hasMobileUA();
  }

  function isTablet () {
    return screen.width < 992 && screen.width > 767 && hasMobileUA();
  }

  function isMobile () {
    return screen.width < 767 && hasMobileUA();
  }

  function escapeSelector (selector) {
    return selector.replace(/[!"$%&'()*+,.\/:;<=>?@[\\\]^`{|}~]/g, "\\$&")
  }
</script>

  

  <script type="text/javascript" src="../../vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="../../vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" id="motion.global">
  $(document).ready(function () {
    var body = $('body');
    var isSidebarVisible = false;
    var sidebarToggle = $('.sidebar-toggle');
    var sidebarToggleLine1st = $('.sidebar-toggle-line-first')
    var sidebarToggleLine2nd = $('.sidebar-toggle-line-middle');
    var sidebarToggleLine3rd = $('.sidebar-toggle-line-last');
    var sidebar = $('.sidebar');

    var SIDEBAR_WIDTH = '320px';
    var SIDEBAR_DISPLAY_DURATION = 300;

    var sidebarToogleLineStatusInit = {width: '100%', opacity: 1, left: 0, rotateZ: 0, top: 0};

    var sidebarToggleLine1stStatusInit = sidebarToogleLineStatusInit;
    var sidebarToggleLine1stStatusArrow = {width: '50%', rotateZ: '-45deg', top: '2px'};
    var sidebarToogleLine1stStatusClose = {width: '100%', rotateZ: '-45deg', top: '5px'};

    var sidebarToggleLine2ndStatusInit = sidebarToogleLineStatusInit;
    var sidebarToggleLine2ndStatusArrow = {width: '90%'};
    var sidebarToogleLine2ndStatusClose = {opacity: 0};

    var sidebarToggleLine3rdStatusInit = sidebarToogleLineStatusInit;
    var sidebarToggleLine3rdStatusArrow = {width: '50%', rotateZ: '45deg', top: '-2px'};
    var sidebarToogleLine3rdStatusClose = {width: '100%', rotateZ: '45deg', top: '-5px'};

    LogoAndMenuMotion();
    sidebatToggleMotion();
    postsListMotion();
    backToTopMotion();


    $(document)
      .on('sidebar.isShowing', function () {
        isDesktop() && body.velocity(
          {paddingRight: SIDEBAR_WIDTH},
          SIDEBAR_DISPLAY_DURATION
        );
        sidebarContentMotion();
      })
      .on('sidebar.isHiding', function () {});

    function LogoAndMenuMotion() {
      $.Velocity.RunSequence([
        { e: $('.brand'), p: { opacity: 1 }, o: { duration: 100 } },
        { e: $('.logo'), p: { opacity: 1, top: 0 }, o: { duration: 50} },
        
        { e: $('.logo-line-before i'), p: { translateX: "100%" }, o: { duration: 500, sequenceQueue: false } },
        { e: $('.logo-line-after i'), p: { translateX: "-100%" }, o: { duration: 500, sequenceQueue: false } },
        
        { e: $('.site-title'), p: { opacity: 1, top: 0 }, o: { duration: 200 } }
      ]);
      $('.menu-item').velocity('transition.slideDownIn', {display: null});
    }


    function backToTopMotion () {
      var b2top = $('.back-to-top');
      b2top.on('click', function () {
        body.velocity('scroll');
      });
    }

    function sidebarShowMotion () {

      sidebarToggleLine1st.velocity(sidebarToogleLine1stStatusClose);
      sidebarToggleLine2nd.velocity(sidebarToogleLine2ndStatusClose);
      sidebarToggleLine3rd.velocity(sidebarToogleLine3rdStatusClose);

      sidebar.velocity({width: SIDEBAR_WIDTH}, {
        display: 'block',
        duration: SIDEBAR_DISPLAY_DURATION,
        complete: function () {
          sidebar.addClass('sidebar-active');
          sidebar.trigger('sidebar.didShow');
        }
      });
      sidebar.trigger('sidebar.isShowing');
    }

    function sidebarHideMotion () {
      isDesktop() && body.velocity({paddingRight: 0});
      sidebar.velocity('reverse');

      sidebarToggleLine1st.velocity(sidebarToggleLine1stStatusInit);
      sidebarToggleLine2nd.velocity(sidebarToggleLine2ndStatusInit);
      sidebarToggleLine3rd.velocity(sidebarToggleLine3rdStatusInit);

      sidebar.removeClass('sidebar-active');
      sidebar.trigger('sidebar.isHiding');
    };

    function sidebarContentMotion () {
      $('.sidebar .motion-element').velocity(
        'transition.slideRightIn',
        {stagger: 50, drag: true}
      );
    }

    function postsListMotion () {
      var postMotionOptions = window.postMotionOptions || {stagger: 300, drag: true};
      $('.post').velocity('transition.slideDownIn', postMotionOptions);
    }

    function sidebatToggleMotion () {
      sidebarToggle.on('click', function () {
        isSidebarVisible ? sidebarHideMotion() : sidebarShowMotion();
        isSidebarVisible = !isSidebarVisible;
      });

      sidebarToggle.hover(function () {
        if (isSidebarVisible) {return}
        sidebarToggleLine1st.velocity('stop').velocity(sidebarToggleLine1stStatusArrow);
        sidebarToggleLine2nd.velocity('stop').velocity(sidebarToggleLine2ndStatusArrow);
        sidebarToggleLine3rd.velocity('stop').velocity(sidebarToggleLine3rdStatusArrow);
      }, function () {
        if (isSidebarVisible) {return}
        sidebarToggleLine1st.velocity('stop').velocity(sidebarToggleLine1stStatusInit);
        sidebarToggleLine2nd.velocity('stop').velocity(sidebarToggleLine2ndStatusInit);
        sidebarToggleLine3rd.velocity('stop').velocity(sidebarToggleLine3rdStatusInit);
      });
    }
  });

</script>





  

  
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
  });
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for (i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>


  
  
  


  

  
</body>
</html>
