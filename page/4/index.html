<!doctype html>
<html class="theme-next use-motion theme-next-mist">
<head>
  

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






  <link rel="stylesheet" type="text/css" href="../../vendors/fancybox/source/jquery.fancybox.css?v=2.1.5"/>


<link rel="stylesheet" type="text/css" href="../../css/main.css?v=0.4.2"/>


    <meta name="description" content="在码农炼成之路不断挣扎……stay hungry……keep learning……" />



  <meta name="keywords" content="java,android,life,CharlesXiao" />





  <link rel="shorticon icon" type="image/x-icon" href="../..//favicon.ico?v=0.4.2" />



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?6749450";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>


  <title> CharlesXiao‘s Blog </title>
</head>

<body>
<!--[if lte IE 8]> <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'> <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode"><img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820" alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari." style='margin-left:auto;margin-right:auto;display: block;'/></a></div> <![endif]-->
  <div class="container one-column 
   page-home 
">
    <div class="headband"></div>

    <div id="header" class="header">
      <div class="header-inner">
        <h1 class="site-meta">
  <span class="logo-line-before"><i></i></span>
  <a href="/" class="brand">
      <span class="logo">
        <i class="icon-logo"></i>
      </span>
      <span class="site-title">CharlesXiao‘s Blog</span>
  </a>
  <span class="logo-line-after"><i></i></span>
</h1>


  <ul id="menu" class="menu">
     
    <!--增加swiftype搜索功能-->
    <form class="menu-item menu-item-search">
      <input type="text" id="st-search-input" class="st-search-input st-default-search-input" />
    </form>
    
    <script type="text/javascript">
      (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
      (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
      e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
      })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

      _st('install','yxUhPQ2aHyszT_1btxX9','2.0.0');
    </script>
    <!--增加swiftype搜索功能end-->
    
    
      
      <li class="menu-item menu-item-home">
        <a href="../..//">
          <i class="menu-item-icon icon-home"></i> <br />
          首页
        </a>
      </li>
    
      
      <li class="menu-item menu-item-categories">
        <a href="../..//categories">
          <i class="menu-item-icon icon-categories"></i> <br />
          分类
        </a>
      </li>
    
      
      <li class="menu-item menu-item-about">
        <a href="../..//about">
          <i class="menu-item-icon icon-about"></i> <br />
          关于
        </a>
      </li>
    
      
      <li class="menu-item menu-item-archives">
        <a href="../..//archives">
          <i class="menu-item-icon icon-archives"></i> <br />
          归档
        </a>
      </li>
    
      
      <li class="menu-item menu-item-tags">
        <a href="../..//tags">
          <i class="menu-item-icon icon-tags"></i> <br />
          标签
        </a>
      </li>
    
  </ul>


      </div>
    </div>

    <div id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content">
          
  <div id="posts" class="posts-expand">
    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="../../2015/05/21/常见设计模式实例讲解/">
                常见设计模式实例讲解
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2015-05-21
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分类于
            
              <a href="../../categories/设计模式/">设计模式</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="../../2015/05/21/常见设计模式实例讲解/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/05/21/常见设计模式实例讲解/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <h3 id="单例模式的三种实现方式及其优缺点">单例模式的三种实现方式及其优缺点</h3><pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonDemo</span> </span>{

    <span class="javadoc">/**
     *<span class="javadoctag"> @param</span> args
     */</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{
        SingletonEnum.INSTANCE.setmName(<span class="string">"enum"</span>);
        SingletonInner.getInstance().setmName(<span class="string">"inner"</span>);
        SingletonDoubleCheck.getInstance().setmName(<span class="string">"doubleCheck"</span>);
    }

    <span class="comment">/*
     * 单例模式考虑点： 
     * 1. 线程安全：Synchronized关键字，Enum，静态内部类 
     * 2. 延迟加载：减少负载和消耗 
     * 3. 自动序列化(Serializable和transient) 
     * 4. 防止反射强行调用构造器
     * 3、4点只有枚举可以实现
     */</span>

    <span class="comment">/*
     * 枚举实现单例
     */</span>
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">enum</span> SingletonEnum {
        INSTANCE;
        <span class="keyword">private</span> String mName;

        <span class="function"><span class="keyword">public</span> String <span class="title">getmName</span><span class="params">()</span> </span>{
            <span class="keyword">return</span> mName;
        }

        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setmName</span><span class="params">(String mName)</span> </span>{
            <span class="keyword">this</span>.mName = mName;
        }

    }
    <span class="comment">/*
     * 双重检查锁：单例模式中需要new的情况非常少,第一层锁可以减少锁的次数
     */</span>
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonDoubleCheck</span> </span>{
        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> SingletonDoubleCheck singleton = <span class="keyword">null</span>;

        <span class="function"><span class="keyword">private</span> <span class="title">SingletonDoubleCheck</span><span class="params">()</span> </span>{
        }

        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonDoubleCheck <span class="title">getInstance</span><span class="params">()</span> </span>{
            <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) {
                <span class="keyword">synchronized</span> (SingletonDoubleCheck.class) {
                    <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) {
                        singleton = <span class="keyword">new</span> SingletonDoubleCheck();
                    }
                }
            }
            <span class="keyword">return</span> singleton;
        }

        <span class="keyword">private</span> String mName;

        <span class="function"><span class="keyword">public</span> String <span class="title">getmName</span><span class="params">()</span> </span>{
            <span class="keyword">return</span> mName;
        }

        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setmName</span><span class="params">(String mName)</span> </span>{
            <span class="keyword">this</span>.mName = mName;
        }
    }

    <span class="comment">/*
     * 内部类方式实现
     */</span>
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonInner</span> </span>{

        <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder</span> </span>{
            <span class="keyword">private</span> <span class="keyword">static</span> SingletonInner singleton = <span class="keyword">new</span> SingletonInner();
        }

        <span class="function"><span class="keyword">private</span> <span class="title">SingletonInner</span><span class="params">()</span> </span>{

        }

        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonInner <span class="title">getInstance</span><span class="params">()</span> </span>{
            <span class="keyword">return</span> Holder.singleton;
        }

        <span class="keyword">private</span> String mName;

        <span class="function"><span class="keyword">public</span> String <span class="title">getmName</span><span class="params">()</span> </span>{
            <span class="keyword">return</span> mName;
        }

        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setmName</span><span class="params">(String mName)</span> </span>{
            <span class="keyword">this</span>.mName = mName;
        }
    }

}
</code></pre><h3 id="工厂模式实例">工厂模式实例</h3><h3 id="观察者模式">观察者模式</h3><h3 id="适配器模式">适配器模式</h3>
        
      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="../../tags/设计模式/"> #设计模式 </a>
          
        </div>
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="../../2015/05/19/数据库重难点集锦/">
                数据库重难点集锦
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2015-05-19
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分类于
            
              <a href="../../categories/数据库/">数据库</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="../../2015/05/19/数据库重难点集锦/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/05/19/数据库重难点集锦/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <h3 id="常见的Hash算法和一致性哈希">常见的Hash算法和一致性哈希</h3><ul>
<li><p>线性哈希，平方取中法，随机数法，按位分割求和法  </p>
</li>
<li><p><strong>MD5和SHA</strong>这两种单向加密算法都是基于hash算法，前者产生128位的散列值，后者产生160位的散列值；两者都存在不同输入的散列值相同的情况，但是概率很低，为了防止被彩虹表破解，可以考虑加入Salt  </p>
</li>
<li><p>Hash算法主要用于文件校验、数字签名、鉴权协议等  </p>
</li>
<li><p><strong>一致性哈希算法</strong>主要应用在cache系统中，常用的hash(object)%N算法会计算object 的hash值，然后对N取模得到余数i，该Object就会被映射到编号为i的cache上;那么当增加或者减少n的值时会导致所有的n个对象的映射全部发生改变，但是一致性哈希算法却只需要重新hash K/n个元素，为什么呢？？？; 因为一致性哈希的内部原理是将Object和cache都使用同一种hash算法hash到同一个数值空间上，该空间为一个首尾相接的圆环；然后如何将Object映射到cache呢？顺着顺时针方向,将每一个Object映射到下一个最邻近的cache,这样当新增一个cache时，只需要将原本映射到下一个cache上的Object部分映射修改到新增的cache上；当减少cache时就将之前映射到该cache的Object都映射到下一个cache上.  </p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Charles-Xiao/Charles-Xiao.github.io/master/images/ConsistHash_pre.png" class="full-image"></p>
<p><img src="https://raw.githubusercontent.com/Charles-Xiao/Charles-Xiao.github.io/master/images/ConsistHash_next.png" class="full-image"></p>
<h3 id="数据库的事务、索引、范式和存储过程概念以及优缺点">数据库的事务、索引、范式和存储过程概念以及优缺点</h3><ol>
<li><p>主键：数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null）。  </p>
<p>超键：在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。  </p>
<p>候选键：能够确定全部属性的某个属性或某组属性，称为候选键。若候选键多于一个，则选定其中一个作为主键</p>
<p>外键：在一个表中存在的另一个表的主键称此表的外键  </p>
</li>
</ol>
<ol>
<li><p><strong>事务</strong>：事务是数据库操作中的不可分割的逻辑单元,一个事务中的所有操作语句要么作为一个整体被执行，要么整体不被执行</p>
<ul>
<li>原子性：要么操作序列中全部语句都执行，要么全部不被执行,不可分割; 也就是说当事务的执行序列中某个语句执行错误，会回滚到该事务未执行时的状态</li>
<li>一致性：事务执行之后数据库从一个一致性状态转化到另一个一致性状态</li>
<li>隔离性：多个事务并行执行时互相之间不会影响</li>
<li>永久性：事务执行之后会对数据库内容产生永久性影响</li>
</ul>
</li>
<li><p><strong>范式</strong></p>
<ul>
<li>第一范式：数据库表里边的每一列都是不可分割的原子性基本数据项</li>
<li>第二范式：数据库表里边每一个非关键字段都和任意一组候选关键字(主键)完全依赖，只有表的任意一组候选键有多个属性时才会出现部分依赖</li>
<li>第三范式：数据库里边每一个非关键字段都和主键直接相关，而不能是间接相关(传递依赖)</li>
<li>BC范式：数据里边每一列既不部分依赖于任何候选键也不传递依赖于任何候选键；一个关系满足BCNF则一定满足第三范式</li>
</ul>
</li>
<li><p><strong>索引</strong> ：建立在数据库表的某些列上，例如需要搜索或者排序的列，主键列，外键列(用于连接的列),用在where语句中的列；有些列不应该建索引，比如：查询中很少使用或者参考的列， 只有很少数据值的列， 定义为text, image和bit数据类型的列,当修改性能远远大于检索性能时，不应该创建索引；索引的实现通常使用B树及其变种B+树</p>
<ul>
<li>参考: 一般来说，应该在这些列上创建索引：在经常需要搜索的列上，可以加快搜索的速度；在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构；在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度；在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的；在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。</li>
<li>复合索引就是索引建立在多个列上，唯一索引就是保证索引列中得所有数据都是唯一的，不会存在冗余数据;聚集索引是指表中行的物理顺序与键值的逻辑（索引）顺序相同。一个表只能包含一个聚集索引</li>
<li><p>当增加索引时，会提高检索性能，但是会降低修改性能 </p>
<p>优点：</p>
</li>
</ul>
<ol>
<li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性 </li>
<li>可以大大加快数据的检索速度    </li>
<li>可以加速表和表之间的连接</li>
<li>在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间</li>
<li><p>通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能</p>
<p>缺点：</p>
</li>
<li>创建索引和维护索引要耗费时间和大量的物理空间</li>
<li>对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度</li>
</ol>
</li>
<li><p><strong>存储过程</strong></p>
<ul>
<li>它是一组存储在数据库中的编译后的SQL语句集，可以接受参数以及返回值，也可以包括程序流，查询语句等</li>
<li>正常情况下,我们在code中写好SQL语句,连接数据库，SQL语句会被发送到服务器然后编译优化，数据库引擎执行编译后的查询语句，最后将查询结果返回给客户端；那么如果我们使用存储过程就可以省掉编译优化的过程，而且存储过程存储在database中，可以减少网络流量和传输时间；而且可以对存储过程授予制定权限，从而保证数据库操作安全</li>
</ul>
</li>
<li><p><strong>View</strong></p>
<ul>
<li>视图是一种通过自定义查询语句去查询筛选数据库表中的数据然后呈现给用户的一种动态生成的虚拟表,他和表一样包含行列数据，但是来自于其引用的表；其优点主要是可以保证数据库安全性以及筛选隐藏部分重要数据;View与Table之间的关系类似于MVC，在View中对数据进行修改会影响到Table中的数据，在Table中进行数据修改同样会显示到View，因为他们用的是同一份数据。</li>
</ul>
</li>
</ol>

        
      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="../../tags/databse/"> #databse </a>
          
        </div>
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="../../2015/05/15/Mac常用快捷键和Tips/">
                Mac常用快捷键和Tips
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2015-05-15
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分类于
            
              <a href="../../categories/Mac系统/">Mac系统</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="../../2015/05/15/Mac常用快捷键和Tips/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/05/15/Mac常用快捷键和Tips/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <p>在Mac系统中学会使用常用快捷键可以大大提高效率，以下为Mac系统中常用的快捷键和在Elipse开发中的常用快捷键(包含Mac和Win两个版本)。</p>
<h3 id="Mac系统中常用快捷键">Mac系统中常用快捷键</h3><pre><code>cmd+alt+<span class="number">1</span>  <span class="comment">--- 自动整理当前文件夹中文件</span>
ctrl+<span class="constant">space</span> <span class="comment">---  启动spotlight全局搜索</span>
cmd+<span class="constant">space</span> <span class="comment">--- 切换输入法</span>
cmd+向上/向下箭头 <span class="comment">--- 返回上级文件夹/打开当前文件夹或文件</span>
cmd+T <span class="comment">--- 新建各种窗口(包括terminal窗口、finder窗口、chrome tab等)</span>
cmd+shift+{/} <span class="comment">--- 切换tab(包括finder、terminal等窗口tab)</span>
cmd+shift+<span class="number">3</span> <span class="comment">--- 屏幕截屏</span>
cmd+shift+<span class="number">4</span> <span class="comment">---选取区域截图</span>
cmd+<span class="built_in">delete</span> <span class="comment">--- 删除某个文件</span>
enter <span class="comment">--- 修改文件名(类似于win中的F2)</span>
cmd+I <span class="comment">--- 查看文件详细属性</span>
cmd+option+esc <span class="comment">--- 打开进程管理窗口</span>
</code></pre><h3 id="Mac常用设置方法">Mac常用设置方法</h3><h4 id="设置Eclipse中package_explorer窗口中项目列表字体大小">设置Eclipse中package explorer窗口中项目列表字体大小</h4><ul>
<li><p>Step1: 下载安装TinkerTool的软件  </p>
</li>
<li><p>Step2: 点击fonts，修改Help tags的字体大小</p>
</li>
</ul>

        
      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="../../tags/Mac/"> #Mac </a>
          
        </div>
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="../../2015/05/15/Mac设置Path环境变量(adb+NDK+sdk)/">
                Mac设置环境变量(adb+NDK+sdk)
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2015-05-15
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分类于
            
              <a href="../../categories/Mac系统/">Mac系统</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="../../2015/05/15/Mac设置Path环境变量(adb+NDK+sdk)/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/05/15/Mac设置Path环境变量(adb+NDK+sdk)/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <p>无论是在windows还是mac系统下，对于程序猿而言，在terminal中输入命令进行一些常用操作是比用鼠标更为快捷的方式。那么为了能够打开terminal就可以直接输入并执行命令，就需要进行环境变量的设置，这样就不必进入命令文件所在目录下执行该命令了。windows下配置环境变量较为简单，在此讲一下mac下配置环境变量的方法和注意事项。</p>
<p><strong>1. 打开terminal，输入<code>cd ~</code>, 进入当前用户home目录</strong></p>
<p><strong>2. 输入<code>touch .bash_profile</code>, 创建bash_profile文件(如果该文件已经存在则可以直接进入第3步)</strong></p>
<p><strong>3. 打开记事本编辑bash_profile文件，示例如下</strong></p>
<pre><code>方式一：用<span class="constant">SDK_HOME指</span>代一个通用路径，一处设置，多处使用，结构明晰，然后设置到<span class="constant">PATH</span>

export <span class="constant">SDK_HOME=</span>“/usr/sdk”             
export <span class="constant">PATH=</span><span class="variable">${</span><span class="constant">PATH}</span><span class="symbol">:</span><span class="variable">${</span><span class="constant">SDK_HOME}</span><span class="symbol">:</span><span class="variable">${</span><span class="constant">SDK_HOME}</span>/<span class="symbol">tools:</span>/usr/ndk


方式二：直接将各个命令的路径用<span class="symbol">:</span>连接起来设置到<span class="constant">PATH </span>形如--- export <span class="constant">PATH=</span><span class="variable">${</span><span class="constant">PATH}</span><span class="symbol">:</span>路径<span class="number">1</span><span class="symbol">:</span>路径<span class="number">2</span><span class="symbol">:</span>路径<span class="number">3</span>

export <span class="constant">PATH=</span><span class="variable">${</span><span class="constant">PATH}</span><span class="symbol">:/usr/sdk</span><span class="symbol">:/usr/sdk/tools</span><span class="symbol">:/usr/ndk</span>
</code></pre><p><strong>4. 保存修改，输入更新命令<code>source .bash_profile</code>,PATH变量配置完成</strong></p>
<p><a href="http://blog.csdn.net/zf135792468/article/details/11926995" target="_blank" rel="external">参考链接</a></p>

        
      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="../../tags/Android/"> #Android </a>
          
            <a href="../../tags/Mac/"> #Mac </a>
          
        </div>
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="../../2015/05/12/如何阅读一本书/">
                如何阅读一本书
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2015-05-12
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分类于
            
              <a href="../../categories/读书札记/">读书札记</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="../../2015/05/12/如何阅读一本书/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/05/12/如何阅读一本书/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <p>书籍使人进步！阅读使人明智！如何阅读一本书也是一门学问，读懂不同类型的书也是一件不容易的事情。美国教育家查尔斯-范多伦还特地写了一本《如何阅读一本书》来讲述读书的“方法论”，此文为部分书摘，闲来无事翻书，翻到哪儿写到哪儿，未完待续……
          <div class="post-more-link text-center">
            <a class="btn" href="../../2015/05/12/如何阅读一本书/#more">
              阅读全文 &raquo;
            </a>
          </div>
        
      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="../../tags/阅读/"> #阅读 </a>
          
        </div>
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="../../2015/04/23/Java语言基础知识点/">
                Java语言基础知识点
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2015-04-23
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分类于
            
              <a href="../../categories/java学习笔记/">java学习笔记</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="../../2015/04/23/Java语言基础知识点/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/04/23/Java语言基础知识点/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <ol>
<li><strong>Switch语句参数</strong>: JDK7之前，switch 只能支持 byte、short、char、int 这几个基本数据类型和其对应的封装类型;如果想用String，需要将String包装成枚举类型作为参数；JDK7之后支持String类型直接作为参数<a href="http://blog.csdn.net/amazing7/article/details/51219315" target="_blank" rel="external">参考</a></li>
<li><strong>for循环和foreach的区别</strong>: for循环效率高于foreach; for循环可以间隔遍历，步伐可以自由设置，但是foreach只能用于遍历读取每一个元素，还不能进行修改</li>
<li><strong>Java和C++区别</strong>：①Java有接口，有垃圾回收机制②C++有引用，有多重继承，有操作符重载</li>
<li><strong>JNI</strong><br> <img src="https://raw.githubusercontent.com/Charles-Xiao/Charles-Xiao.github.io/master/images/JNI.png" class="full-image" width="100%"></li>
<li><strong>Java泛型</strong>：泛型是指在定义接口或者类时可以使用类型参数，泛型提供了编译期的类型安全检查，确保你只能把正确类型的对象放入集合中，避免了在运行时出现ClassCastException。Java中的泛型基本上都是在编译器这个层次来实现的。在生成的Java字节代码中是不包含泛型中的类型信息的。使用泛型的时候加上的类型参数，会被编译器在编译的时候去掉，JVM看到的只是List，而由泛型附加的类型信息对JVM来说是不可见的。这个过程就称为<strong>类型擦除</strong>。比如一个方法如果接收List<object>作为形式参数，那么如果尝试将一个List<string>的对象作为实际参数传进去，却发现无法通过编译；因为这会产生隐含的类型转换问题，编译器直接就禁止这样的行为；Array不支持泛型，所以不能保证编译期的类型安全保证。</string></object></li>
<li><strong>Java IO与NIO</strong>Java IO是面向流的阻塞式IO方式，而NIO是面向缓冲区的无阻塞式IO方式；在Java IO中当一个线程调用read() 或 write()时，该线程被阻塞，直到有一些数据被读取，或数据完全写入，对于每一个客户端连接，服务端都会新开一个线程处理。而Java NIO的非阻塞模式使用一个专用的reactor来处理分发IO事件，数据处理采用双通道模式，client和server各自维护一个selector用于检测通道上的事件，通过访问selector来处理感兴趣事件</li>
<li><strong>为什么匿名内部类和局部内部类只能访问final变量？</strong>：因为虽然匿名内部类在方法的内部，但实际编译的时候，内部类编译成Outer.Inner,这说明内部类所处的位置和外部类中的方法处在同一个等级上，外部类中的方法中的变量或参数只是方法的局部变量，这些变量或参数的作用域只在这个方法内部有效。因为编译的时候内部类和方法在同一级别上，所以方法中的变量或参数只有为final，内部类才可以引用，因为Java采用了一种copy local variable的方式来实现，也就是说把定义为final的局部变量拷贝过来用，而引用的也可以拿过来用，只是不能重新赋值。</li>
<li><strong>JDK8的新特性</strong>:</li>
</ol>

        
      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="../../tags/Java/"> #Java </a>
          
        </div>
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="../../2015/04/13/Java多线程同步方法/">
                Java多线程同步方法
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2015-04-13
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分类于
            
              <a href="../../categories/java学习笔记/">java学习笔记</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="../../2015/04/13/Java多线程同步方法/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/04/13/Java多线程同步方法/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <h3 id="同步VS异步_and_阻塞VS非阻塞_Link">同步VS异步 and 阻塞VS非阻塞 <a href="http://elf8848.iteye.com/blog/1739611" target="_blank" rel="external">Link</a></h3><ol>
<li><strong>同步/异步与阻塞/非阻塞是两组不同的概念,它们可以共存组合,同步和异步与消息的通知机制有关,阻塞和非阻塞与程序等待消息(无所谓同步或者异步)时的状态有关</strong> <strong>同步</strong>：就是在发出一个功能调用时，在没有得到结果之前，该调用就不返回(<strong>与阻塞的区别</strong>很多时候当前线程还是激活的，只是从逻辑上当前函数没有返回而已)。<strong>异步</strong>：当一个异步过程调用发出后，调用者不能立刻得到结果；这个调用的部件在处理完成后，通过状态、通知和回调来通知调用者。<strong>阻塞</strong>：是指调用结果返回之前，当前线程会被挂起，函数只有在得到结果之后才会返回。<strong>非阻塞</strong>指在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回。</li>
<li>举例: 我去买一本书，立即买到了，这就是<strong>非阻塞</strong>；如果恰好书店没有，我就等一直等到书店有了这本书买到了才走，这就是<strong>阻塞</strong>；这两种情况，非阻塞和阻塞都可以称为<strong>同步</strong>。如果书店恰好没有，我就告诉书店老板，书来了告诉我一声让我来取或者直接送到我家，然后我就走了，这就是<strong>异步</strong>。</li>
</ol>
<h3 id="Synchronized代码块和方法">Synchronized代码块和方法</h3><p>synchronized关键字强制实施一个互斥锁(<strong>互斥锁</strong>：任意时刻，只有一个线程锁。即假设A线程已经获取了锁，在A线程释放这个锁之前，B线程是无法获取到这个锁的，B要获取这个锁就会进入阻塞状态。)，使得被保护的代码块在同一时间只能有一个线程进入并执行，防止多线程访问临界共享资源出现数据不一致性；同步是一种高开销的操作，因此应该尽量减少同步的内容;通常没有必要同步整个方法，使用synchronized代码块同步关键代码；Synchronized锁住的是对象或者类,对象被锁住时，该对象所有的其他同步方法和代码块不能被执行；类被锁住时，该类所有的其他同步静态方法和代码块不能被执行</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">Bank</span> </span>{
        <span class="keyword">private</span> <span class="keyword">int</span> account = <span class="number">100</span>;

        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAccount</span><span class="params">()</span> </span>{
            <span class="keyword">return</span> account;
        }

        <span class="javadoc">/**
         * 用同步方法实现
         * 
         *<span class="javadoctag"> @param</span> money
         */</span>
        <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(<span class="keyword">int</span> money)</span> </span>{
            account += money;
        }

        <span class="javadoc">/**
         * 用同步代码块实现
         * 
         *<span class="javadoctag"> @param</span> money
         */</span>
        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save1</span><span class="params">(<span class="keyword">int</span> money)</span> </span>{
            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {
                account += money;
            }
        }
    }
</code></pre><h3 id="ReentrantLock可重入锁">ReentrantLock可重入锁</h3><ol>
<li>可重入锁，也叫做递归锁，指的是同一线程外层函数获得锁之后，内层递归函数仍然有获取该锁的代码，但不受影响;即被同一个线程多次获取，而不会产生死锁。在JAVA环境下 ReentrantLock 和synchronized 都是可重入锁</li>
<li><p>ReentrantLock是可重入、互斥、实现了Lock接口的锁，需要自己手动加锁与释放；要注意及时释放锁，否则会出现死锁，通常在finally代码释放锁；如果synchronized关键字能满足用户的需求，就用synchronized，因为它能简化代码</p>
<pre><code><span class="keyword">class</span> <span class="title">Bank</span> {
    <span class="keyword">private</span> <span class="keyword">int</span> account = <span class="number">100</span>;
    <span class="comment">// 创建一个ReentrantLock锁</span>
    <span class="keyword">private</span> Lock <span class="keyword">lock</span> = <span class="keyword">new</span> ReentrantLock();

    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAccount</span><span class="params">()</span> </span>{
        <span class="keyword">return</span> account;
    }

    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(<span class="keyword">int</span> money)</span> </span>{
        <span class="keyword">lock</span>.<span class="keyword">lock</span>();    <span class="comment">// 获得锁 </span>
        <span class="keyword">try</span> {
            account += money;
        } <span class="keyword">finally</span> {
            <span class="keyword">lock</span>.unlock();    <span class="comment">// 释放锁</span>
        }
    }
}
</code></pre></li>
</ol>
<h3 id="ThreadLocal线程局部变量">ThreadLocal线程局部变量</h3><p><strong>ThreadLocal与同步机制区别</strong>：a.ThreadLocal与同步机制都是为了解决多线程中相同变量的访问冲突问题。b.前者采用以”空间换时间”的方法，后者采用以”时间换空间”的方式<br>每一个使用ThreadLocal变量的线程都获得该变量的副本，副本之间相互独立，这样每一个线程都可以随意修改自己的变量副本，而不会对其他线程产生影响</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Bank</span> {
    <span class="comment">// 使用ThreadLocal类管理共享变量account</span>
    <span class="keyword">private</span> ThreadLocal&lt;Integer&gt; account = <span class="keyword">new</span> ThreadLocal&lt;Integer&gt;() {
        @<span class="function">Override
        <span class="keyword">protected</span> Integer <span class="title">initialValue</span><span class="params">()</span> </span>{
            <span class="keyword">return</span> <span class="number">100</span>;
        }
    };

    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(<span class="keyword">int</span> money)</span> </span>{
        account.<span class="keyword">set</span>(account.<span class="keyword">get</span>() + money);
    }

    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAccount</span><span class="params">()</span> </span>{
        <span class="keyword">return</span> account.<span class="keyword">get</span>();
    }
}
</code></pre><h3 id="volatile变量可见性">volatile变量可见性</h3><p><strong>volatile</strong>: 在需要同步的变量上加上修饰符volatile，例如：private volatile int account = 100;volatile可以保证变量的可见性但是不保证原子性，不能用于修饰final常量，线程每一次对volatile变量的修改都会即时刷新到主存和通知到其他线程，也就是说每一次每个线程读取volatile变量时都会从主存中去取而不会从缓存寄存器中获取，以确保变量的值都是最新获取的;该关键字在JDK1.6开始可以保证指令不被重排序；但是他不能保证原子性，比如n++这种复合型操作;java虚拟机规范（jvm spec）中，规定了声明为volatile的long和double变量的get和set操作是原子的,所以将long和double类型的变量用volatile修饰，就可以保证对他们的赋值操作的原子性。  </p>
<p><strong>CAS比较并交换操作</strong>：CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B). CAS有效地说明了“我认为位置 V 应该包含值 A；如果包含该值，则将 B 放到这个位置；否则，不要更改该位置，只告诉我这个位置现在的值即可。”   </p>
<p>例如，有一个变量i=0，Thread-1和Thread-2都对这个变量执行自增操作。 可能会出现Thread-1与Thread-2同时读取i=0到各自的工作内存中，然后各自执行+1，最后将结果赋予i。这样，虽然两个线程都对i执行了自增操作，但是最后i的值为1，而不是2。<br>解决这个问题使用互斥锁自然可以。但是也可以使用CAS来实现，思路如下：<br>自增操作可以分为两步：（1）从内存中读取这个变量的当前值（2）执行（变量=上一步取到的当前值+1）的赋值操作。</p>
<p>多线程情况下，自增操作出现问题的原因就是执行（2）的时候，变量在主内存中的值已经不等于上一步取到的当前值了，所以赋值时，用CompareAndSet操作代替Set操作：首先比较一下内存中这个变量的值是否等于上一步取到的当前值，如果等于，则说明可以执行+1运算，并赋值；如果不等于，则说明有其他线程在此期间更改了主内存中此变量的值，上一步取出的当前值已经失效，此时，不再执行+1运算及后续的赋值操作，而是返回主内存中此变量的最新值。“比较并交换（CAS）”操作是原子操作，它使用平台提供的用于并发操作的硬件原语。</p>
<p><strong>原子（atom）</strong>本意是“不能被进一步分割的最小粒子”，而原子操作（atomic operation）意为”不可被中断的一个或一系列操作” </p>
<h3 id="Wait_&amp;&amp;_Notify同步(生产者消费者模式实现)">Wait &amp;&amp; Notify同步(生产者消费者模式实现)</h3><ol>
<li><strong>Wait</strong>调用任意对象的wait()方法导致该线程阻塞，并释放该对象上的锁，进入等待对象同步锁的状态;<strong>Notify</strong>随机唤醒一个等待对象同步锁的线程</li>
<li><strong>生产者-消费者（producer-consumer）问题</strong>，也称作有界缓冲区（bounded-buffer）问题，两个进程共享一个公共的固定大小的缓冲区。其中一个是生产者，用于将消息放入缓冲区；另外一个是消费者，用于从缓冲区中取出消息。问题出现在当缓冲区已经满了，而此时生产者还想向其中放入一个新的数据项的情形，其解决方法是让生产者此时进行休眠，等待消费者从缓冲区中取走了一个或者多个数据后再去唤醒它。同样地，当缓冲区已经空了，而消费者还想去取消息，此时也可以让消费者进行休眠，等待生产者放入一个或者多个数据时再唤醒它</li>
<li>代码实现: </li>
</ol>
<pre><code><span class="keyword">public</span> class ProducerCustomer {

<span class="comment">/**
 * @param args
 */</span>
<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) {
    Product product = <span class="keyword">new</span> Product(); <span class="comment">// 实例化产品对象</span>
    Producer p = <span class="keyword">new</span> Producer(product); <span class="comment">// 实例化一个生产者</span>
    Consumer c = <span class="keyword">new</span> Consumer(product); <span class="comment">// 实例化一个消费者</span>
    <span class="keyword">new</span> Thread(p).start(); <span class="comment">// 开启生产者线程</span>
    <span class="keyword">new</span> Thread(c).start(); <span class="comment">// 开启消费者线程</span>
}

<span class="comment">/**
 * 生产者线程
 */</span>
<span class="keyword">static</span> class Producer implements Runnable {
    <span class="keyword">private</span> Product product;

    <span class="keyword">public</span> Producer(Product product) {
        <span class="keyword">this</span>.product = product;
    }

    <span class="keyword">public</span> <span class="keyword">void</span> run() {
        <span class="keyword">while</span> (<span class="keyword">true</span>) {
            <span class="comment">// 同步代码锁</span>
            <span class="keyword">synchronized</span> (product) {
                <span class="keyword">try</span> {
                    <span class="keyword">while</span> (product.getMax() == product.<span class="built_in">size</span>()) {
                        <span class="comment">// 产品栈已经满,不需要再生产,执行线程等待操作</span>
                        System.out.<span class="built_in">println</span>(<span class="string">"产品栈已满，生产者休息中......"</span>);
                        product.wait();
                    }
                    <span class="comment">// 产品栈不足,开始生产</span>
                    <span class="keyword">Object</span> newObj = <span class="keyword">new</span> <span class="keyword">Object</span>();
                    product.<span class="built_in">add</span>(newObj);
                    System.out.<span class="built_in">println</span>(<span class="string">"Producer 生产了一个产品，目前产品栈大小为："</span>
                            + product.<span class="built_in">size</span>());
                    <span class="comment">// 生产一个产品之后,线程开始睡眠</span>
                    Thread.sleep((<span class="keyword">long</span>) Math.<span class="built_in">random</span>() * <span class="number">3000</span>);
                    <span class="comment">// 通知消费者,有新产品</span>
                    product.notify();
                } <span class="keyword">catch</span> (Exception e) {
                }
            }
        }
    }
}

<span class="comment">/**
 * 消费者线程
 */</span>
<span class="keyword">static</span> class Consumer implements Runnable {
    <span class="keyword">private</span> Product product;

    <span class="keyword">public</span> Consumer(Product product) {
        <span class="keyword">this</span>.product = product;
    }

    <span class="keyword">public</span> <span class="keyword">void</span> run() {
        <span class="keyword">while</span> (<span class="keyword">true</span>) {
            <span class="comment">// 同步代码锁</span>
            <span class="keyword">synchronized</span> (product) {
                <span class="keyword">try</span> {
                    <span class="keyword">while</span> (product.<span class="built_in">size</span>() == <span class="number">0</span>) {
                        <span class="comment">// 产品栈已空,不可以再消费,执行线程等待操作</span>
                        System.out.<span class="built_in">println</span>(<span class="string">"产品栈为空，消费者等待中......"</span>);
                        product.wait();
                    }
                    <span class="comment">// 产品栈有商品,开始消费</span>
                    product.remove();
                    System.out.<span class="built_in">println</span>(<span class="string">"Consumer 消费了一个产品，目前产品栈大小为："</span>
                            + product.<span class="built_in">size</span>());
                    <span class="comment">// 消费一个产品之后,线程开始睡眠</span>
                    Thread.sleep((<span class="keyword">long</span>) Math.<span class="built_in">random</span>() * <span class="number">3000</span>);
                    product.notify();
                } <span class="keyword">catch</span> (Exception e) {
                }
            }
        }
    }
}

<span class="keyword">static</span> class Product {
    <span class="comment">// 使用list集合模拟一个产品栈</span>
    <span class="keyword">private</span> List&lt;<span class="keyword">Object</span>&gt; goods = <span class="keyword">new</span> LinkedList&lt;<span class="keyword">Object</span>&gt;();
    <span class="keyword">private</span> <span class="built_in">int</span> <span class="built_in">max</span> = <span class="number">10</span>; <span class="comment">// 最大产品数量</span>

    <span class="keyword">public</span> <span class="keyword">void</span> <span class="built_in">add</span>(<span class="keyword">Object</span> obj) {
        goods.<span class="built_in">add</span>(obj);
    }

    <span class="keyword">public</span> <span class="keyword">void</span> remove() {
        <span class="keyword">if</span> (goods.<span class="built_in">size</span>() &gt; <span class="number">0</span>) {
            goods.remove(goods.<span class="built_in">size</span>() - <span class="number">1</span>);
        }
    }

    <span class="keyword">public</span> <span class="built_in">int</span> <span class="built_in">size</span>() {
        <span class="keyword">return</span> goods.<span class="built_in">size</span>();
    }

    <span class="keyword">public</span> <span class="built_in">int</span> getMax() {
        <span class="keyword">return</span> <span class="keyword">this</span>.<span class="built_in">max</span>;
    }

    <span class="keyword">public</span> <span class="keyword">void</span> setMax(<span class="built_in">int</span> <span class="built_in">max</span>) {
        <span class="keyword">this</span>.<span class="built_in">max</span> = <span class="built_in">max</span>;
    }
}
}
</code></pre>
        
      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="../../tags/Java/"> #Java </a>
          
            <a href="../../tags/多线程/"> #多线程 </a>
          
        </div>
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="../../2015/04/09/Android基础知识总结/">
                Android基础知识总结
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2015-04-09
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分类于
            
              <a href="../../categories/Android开发/">Android开发</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="../../2015/04/09/Android基础知识总结/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/04/09/Android基础知识总结/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <h3 id="Android架构层次">Android架构层次</h3><p><img src="https://raw.githubusercontent.com/Charles-Xiao/Charles-Xiao.github.io/master/images/android_framework.png" class="full-image" width="100%"></p>
<p><strong>android系统架构分从下往上为Linux内核层、运行库、应用程序框架层和应用程序层</strong></p>
<ol>
<li>Linux内核层：负责硬件的驱动程序、网络、电源、系统安全以及内存管理等功能。</li>
<li>运行库和android runtion：运行库：即c/c++函数库部分，大多数都是开放源代码的函数库，例如webkit，该函数库负责android网页浏览器的运行；例如标准的c函数库libc、openssl、sqlite等，当然也包括支持游戏开发的2dsgl和3dopengles，在多媒体方面有mediaframework框架来支持各种影音和图形文件的播放与显示，如mpeg4、h.264、mp3、aac、amr、jpg和png等众多的多媒体文件格式。Androidruntion负责解释和执行生成的dalvik格式的字节码</li>
<li>应用软件架构：java应用程序开发人员主要是使用该层封装好的api进行快速开发的。</li>
<li>应用程序层：该层是java的应用程序层，android内置的googlemaps、email、IM、浏览器等，都处于该层，java开发人员工发的程序也处于该层，而且和内置的应用程序具有平等的地位，可以调用内置的应用程序，也可以替换内置的应用程序</li>
</ol>
<h3 id="ANR的产生原因以及解决方法">ANR的产生原因以及解决方法</h3><ol>
<li>ANR由Activity manager和windows manager来负责监听，android应用程序通常是运行在一个单独的线程里，这就意味你的应用程序所做的事情如果在主线程里占用了大长时间的话，就会引发ANR对话框，因为你的应用程序并没有给自己机会来处理输入事件或者Intent广播</li>
<li><strong>产生原因</strong>: ①Activity 5s没有响应输入事件，比如按键，触摸 事件②广播接收器在10s没有处理完毕事件 ③Service在20s之类没有完成事件处理</li>
<li>解决方法: 不在主线程进行网络请求,磁盘读取，位图修改，更新UI等耗时操作，而应该采用子线程来完成，完成之后通过Handler通知主线程</li>
</ol>
<h3 id="Android_界面卡顿怎么处理？Link">Android 界面卡顿怎么处理？<a href="http://charles-xiao.github.io/2015/08/30/Android%E5%BA%94%E7%94%A8%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" target="_blank" rel="external">Link</a></h3><h3 id="Android子线程和UI线程交互的5种方式">Android子线程和UI线程交互的5种方式</h3><ol>
<li><p><strong>handler</strong>: 参考“实习项目总结”</p>
</li>
<li><p><strong>AsyncTask</strong>: 参考“实习项目总结”</p>
</li>
<li><p><strong>Activity.runOnUIThread(Runnable)</strong>  </p>
<p> <strong>子线程更新UI</strong>  </p>
<pre><code><span class="keyword">new</span> Thread() {  
    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{  
        <span class="comment">//这儿是耗时操作，完成之后更新UI；  </span>
        runOnUiThread(<span class="keyword">new</span> Runnable(){  

            <span class="annotation">@Override</span>  
            <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{  
                <span class="comment">//更新UI  </span>
                imageView.setImageBitmap(bitmap);  
            }  

        });  
    }  
}.start(); 
</code></pre><p> <strong>非Activity更新UI</strong></p>
<pre><code>Activity activity = (Activity) imageView.getContext();  
        activity.runOnUiThread(<span class="keyword">new</span> Runnable() {  

            <span class="annotation">@Override</span>  
            <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{  
                imageView.setImageBitmap(bitmap);  
            }  
});  
</code></pre></li>
<li><p><strong>View.Post(Runnable)</strong></p>
<pre><code>imageView.post(<span class="keyword">new</span> Runnable(){  

            <span class="annotation">@Override</span>  
            <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{  
                imageView.setImageBitmap(bitmap);  
            }  

});  
</code></pre></li>
<li><p><strong>View.PostDelayed(Runnabe,long)</strong></p>
</li>
</ol>
<h3 id="Activity四种启动模式和生命周期">Activity四种启动模式和生命周期</h3><ol>
<li><strong>Application</strong>: 应用程序是组件的集合，manifest文件中展现了application中组件的结构,加载app时会根据manifest去加载和实例化组件</li>
<li><strong>Process</strong>: 一个应用程序占据一个进程，一个运行中的dalvik虚拟机实例就占据一个进程; 但是我们可以给组件设置android:process = “name”来让组件运行在独立进程中</li>
<li><strong>Task</strong>: 一组以栈的形式来进行管理的相互关联的activity的集合，它是存在于framework层的一个跨应用的概念，控制界面的跳转和返回；task中所有的activity在一个叫做back stack的栈中进行管理</li>
<li><strong>四种启动模式</strong><ul>
<li><strong>standard</strong>: 默认的lauchmode, 同一个activity可以被实例化多次，在一个task栈中可以同时存在一个activity的多个实例，每次startActivity就新建一个实例入栈<br><img src="https://raw.githubusercontent.com/Charles-Xiao/Charles-Xiao.github.io/master/images/standard.png" class="full-image"></li>
<li><strong>singleTop</strong>: 先检查栈顶是否是该activity的实例，是则重用该实例，并且调用该实例的onNewIntent()方法，否则要新建实例压入栈顶<br><img src="https://raw.githubusercontent.com/Charles-Xiao/Charles-Xiao.github.io/master/images/singleTop.png" class="full-image">  </li>
<li><strong>singleTask</strong>: 先检查栈中是否包含该activity的实例，是则重用该实例，清理该实例上的所有activity并将其显示给用户；否则新建实例压入back stack<br><img src="https://raw.githubusercontent.com/Charles-Xiao/Charles-Xiao.github.io/master/images/singleTask.png" class="full-image"></li>
<li><strong>singleInstance</strong>: 以singleInstance模式启动的Activity具有全局唯一性，即整个系统中只会存在一个这样的实例；而且具备独占性，以该模式启动的Activity不能与其他Activity共存在一个task中<br><img src="https://raw.githubusercontent.com/Charles-Xiao/Charles-Xiao.github.io/master/images/singleInstance.png" class="full-image"></li>
</ul>
</li>
<li><p><strong>Activity以及Fragment生命周期</strong>:</p>
<p> <img src="https://raw.githubusercontent.com/Charles-Xiao/Charles-Xiao.github.io/master/images/activity_life.png" class="full-image" width="100%"></p>
<p> <img src="https://raw.githubusercontent.com/Charles-Xiao/Charles-Xiao.github.io/master/images/fragment_life.png" class="full-image" width="100%"></p>
<ul>
<li><strong>onSaveInstanceState() 和 onRestoreInstanceState()</strong>： <a href="http://www.cnblogs.com/hanyonglu/archive/2012/03/28/2420515.html" target="_blank" rel="external">Link</a><br>①当某个activity变得”容易”被系统销毁时，该activity的<strong>onSaveInstanceState()</strong>就会被执行，除非该activity是被用户主动销毁的，例如当用户按BACK键的时候；他的调用有<strong>5种情况</strong>：(1)、<strong>当用户按下HOME键时</strong>：这是显而易见的，系统不知道你按下HOME后要运行多少其他的程序，自然也不知道activity A是否会被销毁，因此系统会调用onSaveInstanceState()，让用户有机会保存某些非永久性的数据。以下几种情况的分析都遵循该原则 (2)、<strong>长按HOME键，选择运行其他的程序时</strong>。(3)、<strong>按下电源按键（关闭屏幕显示）时</strong>。(4)、<strong>从activity A中启动一个新的activity时</strong>。(5)、<strong>屏幕方向切换时，例如从竖屏切换到横屏时</strong>。在屏幕切换之前，系统会销毁activity A，在屏幕切换之后系统又会自动地创建activity A，所以onSaveInstanceState()一定会被执行，且也一定会执行onRestoreInstanceState()。<br>②<strong>onRestoreInstanceState()</strong>被调用的前提是，activity A“确实”被系统销毁了，而如果仅仅是停留在有这种可能性的情况下，则该方法不会被调用，例如，当正在显示activity A的时候，用户按下HOME键回到主界面，然后用户紧接着又返回到activity A，这种情况下activity A一般不会因为内存的原因被系统销毁，故activity A的onRestoreInstanceState方法不会被执行 此也说明上二者，大多数情况下不成对被使用。</li>
</ul>
</li>
<li><p><strong>如果一个以SingleTask启动的的Activity实例，再新建一个该实例，Activity的执行流程？？？</strong>singleTask保证了在栈中Activity的唯一性，如果被SingleTask标记的Activity处于栈底，上面的Activity都会被pop出栈，这个时候被标记过SingleTask的Activity生命周期会做出调整：onNewIntent-&gt;onStart-&gt;onResume, 不再调用onCreate函数</p>
</li>
<li><strong>android:taskAffinity</strong>：每个Activity都有taskAffinity属性，这个属性指出了它希望进入的Task。如果一个Activity没有显式的指明该 Activity的taskAffinity，那么它的这个属性就等于Application指明的taskAffinity，如果 Application也没有指明，那么该taskAffinity的值就等于包名；例如 android:taskAffinity=””的意思是不依附于任何task，也就是自己新建一个task</li>
</ol>
<h3 id="Service">Service</h3><ol>
<li><strong>两种类型</strong>本地和远程service,分别运行于主线程或者独立进程的主线程，Service主要运行在后台执行一些监测行为或者其他加载网页等后台操作，可以通过iBinder或者广播与Activity进行交互<a href="http://www.cnblogs.com/newcj/archive/2011/05/30/2061370.html" target="_blank" rel="external">Service总结</a></li>
<li><strong>两种启动模式</strong>: <a href="http://www.jianshu.com/p/2fb6eb14fdec" target="_blank" rel="external">具体区别Link</a><ul>
<li>start方法一旦服务开启跟调用者(开启者)就没有任何关系了;开启者退出了，开启者挂了，服务还在后台长期的运行;开启者不能调用服务里面的方法</li>
<li>bind的方式开启服务，绑定服务，调用者挂了，服务也会跟着挂掉.绑定者可以调用服务里面的方法</li>
<li><strong>绑定者如何调用服务里的方法呢？</strong> 自定义Service，在其内部重写onBind函数返回一个实现IBinder接口或者继承Binder的对象给绑定者—-这个自定义Binder是一个内部类，提供一个可以间接调用服务或者直接返回service对象的方法—-在Activity中调用bindService方法,服务成功绑定之后，在回调方法onServiceConnected中会传递过来一个IBinder对象给Activity使用(ServiceConnection的匿名内部类)</li>
</ul>
</li>
<li><p><strong>Service生命周期</strong></p>
<p> <img src="https://raw.githubusercontent.com/Charles-Xiao/Charles-Xiao.github.io/master/images/service_life.png" class="full-image" width="100%"></p>
</li>
<li><p><strong>Service与Activity的通信机制</strong></p>
<ul>
<li>广播接收器: </li>
<li>iBinder机制: </li>
</ul>
</li>
<li><strong>Service,IntentService,和Intent区别</strong><ul>
<li>Service默认运行在主线程，如果Service将要运行耗时或者可能被阻塞的操作时，例如直接把耗时操作放在 Service 的 onStartCommand()方法中可能会出现ANR错误；所以应该在Service中重新启动一个新的线程来进行这些操作</li>
<li><strong>IntentService内部原理</strong>IntentService在onCreate函数中新建HandlerThread去执行耗时操作，并新建ServiceHandler对象处理消息，当启动一个IntentService的时候接下来会调用onstart方法，该方法会给ServiceHandler发送消息，在ServiceHandler的handleMessage回调函数中调用onHandleIntent函数，因此可以在这个方法里面处理我们的耗时工作；所以IntentService不仅有Service的功能,还有Handler处理和循环消息的功能  </li>
<li><strong>处理流程</strong>IntentService使用队列的方式将请求的Intent加入队列，然后开启一个工作线程来处理队列中的Intent，对于异步的多次startService请求，IntentService会处理完成一个之后再处理第二个，每一个请求都会在一个单独的worker thread中处理，不会阻塞应用程序的主线程;当任务执行完后，IntentService 会自动停止，而不需要我们去手动控制。</li>
</ul>
</li>
<li><strong>Service后台保活</strong>: <ul>
<li><strong>提高Service的优先级或者提高Service所在进程的优先级</strong>：这个，也只能说在系统内存不足需要回收资源的时候，优先级较高，不容易被回收；实现方法有<br>①setForeground(true) 来设置 Service 的优先级和正在运行的 Activity类似<br>②在AndroidManifest.xml文件中对于intent-filter可以通过android:priority = “1000”这个属性设置最高优先级，1000是最高值，如果数字越小则优先级越低</li>
<li><strong>在onDestroy方法里重启service</strong>：这个倒还算挺有效的一个方法，但是，直接干掉进程的时候，onDestroy方法都进不来，更别想重启了</li>
<li>broadcast广播：和第3种一样，没进入onDestroy，就不知道什么时候发广播了，另外，在Android4.4以上，程序完全退出后，就不好接收广播了，需要在发广播的地方特定处理</li>
<li>Service的onStartCommand方法返回START_STICKY，这个也主要是针对系统资源不足而导致的服务被关闭。四个返回值<a href="http://www.jianshu.com/p/a9360c282ef0" target="_blank" rel="external">参考link</a>：start_sticky、start_no_sticky、START_REDELIVER_INTENT、START_STICKY_COMPATIBILITY</li>
<li>App进程之间互相唤醒</li>
<li>通过JNI的方式（NDK编程），fork()出一个子线程作为守护进程，轮询监听服务状态。守护进程（Daemon）是运行在后台的一种特殊进程。它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。而守护进程的会话组和当前目录，文件描述符都是独立的。后台运行只是终端进行了一次fork，让程序在后台执行，这些都没有改变。</li>
</ul>
</li>
</ol>
<h3 id="BroadcastReceiver">BroadcastReceiver</h3><ol>
<li><strong>种类和特点</strong>: </li>
</ol>
<h3 id="ContentProvider">ContentProvider</h3><h3 id="Android_View事件分发机制">Android View事件分发机制</h3><p><img src="https://raw.githubusercontent.com/Charles-Xiao/Charles-Xiao.github.io/master/images/scroller.png" class="full-image" width="100%"></p>
<h3 id="Binder和AIDL">Binder和AIDL</h3><ol>
<li><strong>AIDL</strong>：Android Interface Definition Language,即Android接口定义语言。由于Android不同的进程不能共享内存，所以为了解决进程间通讯的问题，Android使用一种接口定义语言来公开服务的接口，本质上，AIDL非常像一个接口，通过公开接口，让别的进程调用该接口，从而实现进程间的通讯。<a href="http://www.jianshu.com/p/b9b15252b3d6" target="_blank" rel="external">AIDL基本用法</a></li>
<li><strong>Binder</strong>：Android进程间通信是通过Binder来实现的，Binder是安卓实现IPC的一种机制，Binder机制使本地对象能够调用远程对象的方法，在不同进程中传递单向/双向消息。远程Service在Client绑定服务时，会在onBind()的回调中返回一个Binder，当Client调用bindService()与远程Service建立连接成功时，会拿到远程Binder实例，从而使用远程Service提供的服务。Binder是基于C/S通信模式，传输过程只需要一次拷贝，且为Client添加UID/PID身份，性能和安全性更好，因此Android进程间通信使用了Binder。</li>
<li><strong>Android的IPC机制</strong>：IPC是内部进程通信的简称，是共享”命名管道”的资源。Android中的IPC机制是为了让Activity和Service之间可以随时的进行交互，故在Android中该机制，只适用于Activity和Service之间的通信，类似于远程方法调用，类似于C/S模式的访问。通过定义AIDL接口文件来定义IPC接口。Servier端实现IPC接口，Client端调用IPC接口本地代理。</li>
</ol>
<h3 id="Json_VS_XML">Json VS XML</h3><p><a href="http://blog.csdn.net/wei78008023/article/details/44940579" target="_blank" rel="external">XML解析和Json解析简介以及两者的区别</a></p>
<h3 id="Activity切换时生命周期交集">Activity切换时生命周期交集</h3><p>当一个activity A启动了另外一个activity B，它们的生命周期是有交叉的；</p>
<ol>
<li>首先A的onPause()被调用；之后B的onCrate(), onStart()及onResume() 方法会被调用（此时B拥有用户焦点）；最后，如果A在屏幕上不可见，onStop()方法被调用；</li>
<li>因此，我们在两个activities中传递数据，或者共享资源时（如数据库连接），需要在前一个activity的onPause()方法而不是onStop()方法中进行</li>
</ol>

        
      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="../../tags/Android/"> #Android </a>
          
        </div>
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
  </div>

  
  <div class="pagination">
    <a class="extend prev" rel="prev" href="../3/">&laquo;</a><a class="page-number" href="../..//">1</a><span class="space">&hellip;</span><a class="page-number" href="../3/">3</a><span class="page-number current">4</span><a class="page-number" href="../5/">5</a><a class="extend next" rel="next" href="../5/">&raquo;</a>
  </div>


        </div>

        
      </div>


      
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <div id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      <div class="site-overview">
        <div class="site-author motion-element">
          <img class="site-author-image" src="/images/avatar.jpg" alt="CharlesXiao" />
          <p class="site-author-name">CharlesXiao</p>
        </div>
        <p class="site-description motion-element">在码农炼成之路不断挣扎……stay hungry……keep learning……</p>
        <div class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="../..//archives">
              <span class="site-state-item-count">35</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            <a href="../..//categories">
              <span class="site-state-item-count">15</span>
              <span class="site-state-item-name">分类</span>
              </a>
          </div>

          <div class="site-state-item site-state-tags">
            <a href="../..//tags">
              <span class="site-state-item-count">42</span>
              <span class="site-state-item-name">标签</span>
              </a>
          </div>

        </div>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
              <a href="https://github.com/Charles-Xiao" target="_blank">github</a>
            </span>
            
              <span class="links-of-author-item">
              <a href="http://weibo.com/2262300105/profile?topnav=1&wvr=6" target="_blank">weibo</a>
            </span>
            
              <span class="links-of-author-item">
              <a href="http://daijiale.github.io/" target="_blank">Daijiale的个人站点</a>
            </span>
            
          
        </div>

        
        

      </div>

      

    </div>
  </div>


    </div>

    <div id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; &nbsp;  2015.05.16 - 
  2016
  <span class="with-love">
    <i class="icon-heart"></i>
  </span>
  <span class="author">CharlesXiao</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>



      </div>
    </div>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="../../vendors/jquery/index.js?v=2.1.3"></script>

  
  

  
  <script type="text/javascript" src="../../vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript">
    $(document).ready(function() {
      $('.content img').each(function () {
        var $image = $(this);
        var $imageWrapLink = $image.parent('a');

        if ($imageWrapLink.size() < 1) {
          $imageWrapLink = $image.wrap('<a href="' + this.getAttribute('src') + '"></a>').parent('a');
        }
        $imageWrapLink.addClass('fancybox');
      });
    });
    $('.fancybox').fancybox({
      helpers: {
        overlay: {
          locked: false
        }
      }
    });
  </script>


  <script type="text/javascript">
  function hasMobileUA () {
    var nav = window.navigator;
    var ua = nav.userAgent;
    var pa = /iPad|iPhone|Android|Opera Mini|BlackBerry|webOS|UCWEB|Blazer|PSP|IEMobile|Symbian/g;

    return pa.test(ua);
  }

  function isDesktop () {
    return screen.width > 991 && !hasMobileUA();
  }

  function isTablet () {
    return screen.width < 992 && screen.width > 767 && hasMobileUA();
  }

  function isMobile () {
    return screen.width < 767 && hasMobileUA();
  }

  function escapeSelector (selector) {
    return selector.replace(/[!"$%&'()*+,.\/:;<=>?@[\\\]^`{|}~]/g, "\\$&")
  }
</script>

  

  <script type="text/javascript" src="../../vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="../../vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" id="motion.global">
  $(document).ready(function () {
    var body = $('body');
    var isSidebarVisible = false;
    var sidebarToggle = $('.sidebar-toggle');
    var sidebarToggleLine1st = $('.sidebar-toggle-line-first')
    var sidebarToggleLine2nd = $('.sidebar-toggle-line-middle');
    var sidebarToggleLine3rd = $('.sidebar-toggle-line-last');
    var sidebar = $('.sidebar');

    var SIDEBAR_WIDTH = '320px';
    var SIDEBAR_DISPLAY_DURATION = 300;

    var sidebarToogleLineStatusInit = {width: '100%', opacity: 1, left: 0, rotateZ: 0, top: 0};

    var sidebarToggleLine1stStatusInit = sidebarToogleLineStatusInit;
    var sidebarToggleLine1stStatusArrow = {width: '50%', rotateZ: '-45deg', top: '2px'};
    var sidebarToogleLine1stStatusClose = {width: '100%', rotateZ: '-45deg', top: '5px'};

    var sidebarToggleLine2ndStatusInit = sidebarToogleLineStatusInit;
    var sidebarToggleLine2ndStatusArrow = {width: '90%'};
    var sidebarToogleLine2ndStatusClose = {opacity: 0};

    var sidebarToggleLine3rdStatusInit = sidebarToogleLineStatusInit;
    var sidebarToggleLine3rdStatusArrow = {width: '50%', rotateZ: '45deg', top: '-2px'};
    var sidebarToogleLine3rdStatusClose = {width: '100%', rotateZ: '45deg', top: '-5px'};

    LogoAndMenuMotion();
    sidebatToggleMotion();
    postsListMotion();
    backToTopMotion();


    $(document)
      .on('sidebar.isShowing', function () {
        isDesktop() && body.velocity(
          {paddingRight: SIDEBAR_WIDTH},
          SIDEBAR_DISPLAY_DURATION
        );
        sidebarContentMotion();
      })
      .on('sidebar.isHiding', function () {});

    function LogoAndMenuMotion() {
      $.Velocity.RunSequence([
        { e: $('.brand'), p: { opacity: 1 }, o: { duration: 100 } },
        { e: $('.logo'), p: { opacity: 1, top: 0 }, o: { duration: 50} },
        
        { e: $('.logo-line-before i'), p: { translateX: "100%" }, o: { duration: 500, sequenceQueue: false } },
        { e: $('.logo-line-after i'), p: { translateX: "-100%" }, o: { duration: 500, sequenceQueue: false } },
        
        { e: $('.site-title'), p: { opacity: 1, top: 0 }, o: { duration: 200 } }
      ]);
      $('.menu-item').velocity('transition.slideDownIn', {display: null});
    }


    function backToTopMotion () {
      var b2top = $('.back-to-top');
      b2top.on('click', function () {
        body.velocity('scroll');
      });
    }

    function sidebarShowMotion () {

      sidebarToggleLine1st.velocity(sidebarToogleLine1stStatusClose);
      sidebarToggleLine2nd.velocity(sidebarToogleLine2ndStatusClose);
      sidebarToggleLine3rd.velocity(sidebarToogleLine3rdStatusClose);

      sidebar.velocity({width: SIDEBAR_WIDTH}, {
        display: 'block',
        duration: SIDEBAR_DISPLAY_DURATION,
        complete: function () {
          sidebar.addClass('sidebar-active');
          sidebar.trigger('sidebar.didShow');
        }
      });
      sidebar.trigger('sidebar.isShowing');
    }

    function sidebarHideMotion () {
      isDesktop() && body.velocity({paddingRight: 0});
      sidebar.velocity('reverse');

      sidebarToggleLine1st.velocity(sidebarToggleLine1stStatusInit);
      sidebarToggleLine2nd.velocity(sidebarToggleLine2ndStatusInit);
      sidebarToggleLine3rd.velocity(sidebarToggleLine3rdStatusInit);

      sidebar.removeClass('sidebar-active');
      sidebar.trigger('sidebar.isHiding');
    };

    function sidebarContentMotion () {
      $('.sidebar .motion-element').velocity(
        'transition.slideRightIn',
        {stagger: 50, drag: true}
      );
    }

    function postsListMotion () {
      var postMotionOptions = window.postMotionOptions || {stagger: 300, drag: true};
      $('.post').velocity('transition.slideDownIn', postMotionOptions);
    }

    function sidebatToggleMotion () {
      sidebarToggle.on('click', function () {
        isSidebarVisible ? sidebarHideMotion() : sidebarShowMotion();
        isSidebarVisible = !isSidebarVisible;
      });

      sidebarToggle.hover(function () {
        if (isSidebarVisible) {return}
        sidebarToggleLine1st.velocity('stop').velocity(sidebarToggleLine1stStatusArrow);
        sidebarToggleLine2nd.velocity('stop').velocity(sidebarToggleLine2ndStatusArrow);
        sidebarToggleLine3rd.velocity('stop').velocity(sidebarToggleLine3rdStatusArrow);
      }, function () {
        if (isSidebarVisible) {return}
        sidebarToggleLine1st.velocity('stop').velocity(sidebarToggleLine1stStatusInit);
        sidebarToggleLine2nd.velocity('stop').velocity(sidebarToggleLine2ndStatusInit);
        sidebarToggleLine3rd.velocity('stop').velocity(sidebarToggleLine3rdStatusInit);
      });
    }
  });

</script>





  

  
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
  });
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for (i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>


  
  
  


  

  
</body>
</html>
