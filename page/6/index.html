<!doctype html>
<html class="theme-next use-motion theme-next-mist">
<head><meta name="generator" content="Hexo 3.8.0">
  

<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">






  <link rel="stylesheet" type="text/css" href="../../vendors/fancybox/source/jquery.fancybox.css?v=2.1.5">


<link rel="stylesheet" type="text/css" href="../../css/main.css?v=0.4.2">


    <meta name="description" content="在码农炼成之路不断挣扎……stay hungry……keep learning……">



  <meta name="keywords" content="java,android,life,CharlesXiao">





  <link rel="shorticon icon" type="image/x-icon" href="../../favicon.ico?v=0.4.2">



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?6749450";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>


  <title> CharlesXiao‘s Blog </title>
</head>

<body>
<!--[if lte IE 8]> <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'> <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode"><img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820" alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari." style='margin-left:auto;margin-right:auto;display: block;'/></a></div> <![endif]-->
  <div class="container one-column 
  
">
    <div class="headband"></div>

    <div id="header" class="header">
      <div class="header-inner">
        <h1 class="site-meta">
  <span class="logo-line-before"><i></i></span>
  <a href="/" class="brand">
      <span class="logo">
        <i class="icon-logo"></i>
      </span>
      <span class="site-title">CharlesXiao‘s Blog</span>
  </a>
  <span class="logo-line-after"><i></i></span>
</h1>


  <ul id="menu" class="menu">
     
    <!--增加swiftype搜索功能-->
    <form class="menu-item menu-item-search">
      <input type="text" id="st-search-input" class="st-search-input st-default-search-input">
    </form>
    
    <script type="text/javascript">
      (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
      (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
      e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
      })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

      _st('install','yxUhPQ2aHyszT_1btxX9','2.0.0');
    </script>
    <!--增加swiftype搜索功能end-->
    
    
      
      <li class="menu-item menu-item-home">
        
        <a href="">
          <i class="menu-item-icon icon-home"></i> <br>
          首页
        </a>
      </li>
    
      
      <li class="menu-item menu-item-categories">
        
        
        
        <a href="">
          <i class="menu-item-icon icon-categories"></i> <br>
          分类
        </a>
      </li>
    
      
      <li class="menu-item menu-item-about">
        
        
        
        <a href="">
          <i class="menu-item-icon icon-about"></i> <br>
          关于
        </a>
      </li>
    
      
      <li class="menu-item menu-item-archives">
        
        
        
        <a href="">
          <i class="menu-item-icon icon-archives"></i> <br>
          归档
        </a>
      </li>
    
      
      <li class="menu-item menu-item-tags">
        
        
        
        <a href="">
          <i class="menu-item-icon icon-tags"></i> <br>
          标签
        </a>
      </li>
    
  </ul>


      </div>
    </div>

    <div id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content">
          
  <div id="posts" class="posts-expand">
    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              常见分布式对象存储系统实现思考
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2017-11-11
        </span>

        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="../../2017/11/11/常见分布式对象存储系统实现思考/#comments">
              <span class="post-comments-count ds-thread-count" data-thread-key="2017/11/11/常见分布式对象存储系统实现思考/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        <p>整体来看，从上到下，一个对象存储系统应该包括产品层的高级功能(包括鉴权、读写接口)、元数据管理模块(MySQL、NewSQL数据库)、数据管理模块(对象数据的管理)。可以参考S3、Ceph等系统。</p>
<h3 id="元数据管理模块">元数据管理模块</h3><h4 id="NewSQL">NewSQL</h4><p>NewSQL 的出现就是为了解决扩展性和一致性之间的矛盾，主要面向 OLTP 业务和轻量级的OLAP业务。<strong>几点特性</strong>：</p>
<ol>
<li>支持常见SQL语句查询，需要实现一个分布式SQL engine，利用多个节点的计算能力，生成更好的执行计划，将计算逻辑尽可能的均摊到多个存储节点上，与单机引擎不同的是考虑网络的开销和延迟。</li>
<li>支持 ACID 的跨行事务，两阶段提交实现分布式事务，也就是保证多个节点操作的原子性，要么全部节点成功要么全部失败</li>
<li>自动可扩展性。目前关系型数据库的扩展方案上，基本只有分库分表和 PROXY 中间件两种方案。</li>
<li>自动FailOver。常规主从复制方式无法脱离人工运维，因此选用 Multi-Paxos 或者 Raft 这样基于分布式选举的复制协议，在某节点故障的时候，支持完全自动和强一致的故障转移和自我恢复，还能实现跨数据中心多活</li>
</ol>
<p><a href="">NewSQL数据库探秘</a></p>
<h3 id="数据管理模块">数据管理模块</h3><h4 id="几个思考">几个思考</h4><h5 id="为什么要用EC编码和三副本kv存储相结合的方式？">为什么要用EC编码和三副本kv存储相结合的方式？</h5><p>从3副本到1.5副本，主要是为了节省成本。3副本其实数据可靠性(也就是数据持久性)其实很低。对大对象直接进行EC编码，但是小对象不能直接EC，因为小对象太多，如果EC会带来IOPS放大；可以考虑对小对象打包之后做EC，避免增大IOPS。</p>
<h5 id="如何实现快速空间回收？也就是快速删除object">如何实现快速空间回收？也就是快速删除object</h5><h5 id="如何将存储副本降低到1-33的？">如何将存储副本降低到1.33的？</h5><h5 id="EC编码如何提高数据的持久性？">EC编码如何提高数据的持久性？</h5><h5 id="如何实现多AZ和更高的集群可扩展性？">如何实现多AZ和更高的集群可扩展性？</h5><h5 id="如何提高系统的读写性能？">如何提高系统的读写性能？</h5>
      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="../../tags/分布式系统/"> #分布式系统 </a>
          
            <a href="../../tags/对象存储/"> #对象存储 </a>
          
        </div>
      

      

      
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              C++源码之LevelDB
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2017-11-11
        </span>

        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="../../2017/11/11/C++源码之LevelDB:RocksDB/#comments">
              <span class="post-comments-count ds-thread-count" data-thread-key="2017/11/11/C++源码之LevelDB:RocksDB/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        <h4 id="什么是LevelDB—-LevelDB日知录">什么是LevelDB—-<a href="http://cighao.com/2016/08/14/leveldb-source-analysis-02-structure/" target="_blank" rel="noopener"><strong>LevelDB日知录</strong></a></h4><p>一种单机持久化 K/V 数据库。其基于 <a href="http://nosqlsummer.org/paper/lsm-tree" target="_blank" rel="noopener">LSM(LOG Structured Merge Tree)</a> 实现，将所有的 Key/Value 按照 Key 的词法序有序地储存在文件中，具有很高的随机/顺序写性能，非常适用于写多读少的环境。</p>
<p>LevelDB 不是一个 SQL 数据库，它不支持关系数据模型，不支持 SQL 语言，也不支持索引。在同一时刻只允许单个进程（可以是多线程）访问数据库。</p>
<p>LevelDB具备以下特性：</p>
<ol>
<li><p>Keys 和 Values 可以是任意的字节序列</p>
</li>
<li><p>数据是按照 Key 排序的</p>
</li>
<li><p>调用者可以提供一个定制的比较函数来决定 Keys 的排序方式。</p>
</li>
<li><p>针对数据库的操作非常简单，<em>i.e.</em> <code>Put</code>, <code>Get</code>, <code>Delete</code></p>
</li>
<li><p>可以在一次原子的批处理中同时多次修改数据库</p>
</li>
<li><p>用户可以创建 snapshot 保持对于数据视图的一致性</p>
</li>
<li><p>这个数据结构提供前向和后向的迭代器 (iterator)</p>
</li>
<li><p>数据可以自动经过 <a href="http://google.github.io/snappy/" target="_blank" rel="noopener"><em>Snappy</em></a> 算法压缩</p>
</li>
<li><p>针对于操作系统文件的交互操作，LevelDB 提供给外部用户一个可以定制的虚拟的接口(Env)</p>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/Charles-Xiao/Charles-Xiao.github.io/master/images/leveldb_store_engine.jpg" class="full-image"></p>
<h4 id="写入流程">写入流程</h4><ol>
<li>每次写入一个 Key/Value 对时，首先将该数据追加到 log 中，然后再将其写入到内存的 memtable。memtable 是一个基于 SkipList 的有序的结构，每一个 Key 都会按序组织到 memtable 中。</li>
<li>当 memtable 中的数据量达到一定的限制后，其将会转变成为一个 Immutable memtable，同时 levelDB 会新建新的 Log 文件和 memtable 结构用来接收后续的插入操作。内存的 Immutable memtable 将会被后台的线程持久化的存储到磁盘中，生成有序 sstable 文件。</li>
<li>磁盘上的 sstable 文件按照 level 的形式组织，从 memtable 序列化得到的 sst 文件位于 level0 层。由于经过 compaction 线程的压缩，文件将不断地从 level n 层向 level n+1层移动。</li>
</ol>
<blockquote>
<p>delete操作</p>
</blockquote>
<h4 id="读取流程">读取流程</h4><p>leveldb读取数据总是先读取最新的数据,因为有可能插入键值一样的键值对,但是我们查询时是想获取最近插入的数据,所以读取数据时的顺序为：memtable-&gt;immemtable-&gt;sstable</p>
<h4 id="compaction">compaction</h4><h5 id="minor_compaction">minor compaction</h5><p>就是将immemtable数据写回到磁盘的过程</p>
<h5 id="major_compaction">major compaction</h5><p>即将某一层某个文件和上一层的几个sst文件合并的过程</p>
<h5 id="源码分析">源码分析</h5><p>Put函数调用Write函数，触发后台合并操作，DoCompactionWork之前会先调用MakeRoomForWrite函数判断空间是否足够</p>
<h4 id="LSM_Tree存储引擎">LSM Tree存储引擎</h4><h5 id="MemTable">MemTable</h5><p>核心是Get和Add函数实现对SkipList的操作</p>
<h5 id="Skiplist跳跃表">Skiplist跳跃表</h5><ul>
<li><p>构建</p>
<p><img src="/Users/xiaoyong/Desktop/个人资料/hexo-CharlesXiao/themes/next/source/images/skiplist-construct.png" alt="skiplist-insert"></p>
</li>
</ul>
<ul>
<li><p>查找</p>
<p><img src="https://i.imgur.com/cQsPnGa.png" alt="Search"></p>
</li>
<li><p>插入/删除</p>
<p><img src="/Users/xiaoyong/Desktop/个人资料/hexo-CharlesXiao/themes/next/source/images/skiplist-insert.png" alt="skiplist-insert"></p>
</li>
</ul>
<ul>
<li><p>复杂度</p>
<p>  <img src="/Users/xiaoyong/Library/Application Support/typora-user-images/image-20181018145345754.png" alt="image-20181018145345754"></p>
</li>
</ul>
<h5 id="sstable">sstable</h5><h5 id="manifest">manifest</h5><h5 id="versionSet">versionSet</h5><h4 id="Key/Value数据存储">Key/Value数据存储</h4><h5 id="Node数据结构">Node数据结构</h5><p>skiplist中的单个node不仅存储了key，也存储了value。dbformat.h文件中定义了跳跃表中的node数据结构，如下表。</p>
<table>
<thead>
<tr>
<th style="text-align:center">klength</th>
<th style="text-align:center">user_key</th>
<th style="text-align:center">sequence+type(8byte)</th>
<th style="text-align:center">value_size</th>
<th style="text-align:center">value</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">user_key 长度</td>
<td style="text-align:center">用户输入的key</td>
<td style="text-align:center">Seq:全局递增的序列号，每一次Put操作都会递增; type:用于判断操作是插入还是删除</td>
<td style="text-align:center">value长度</td>
<td style="text-align:center">用户输入的value</td>
</tr>
</tbody>
</table>
<p>skiplist中定义的几种key类型及其组成部分：</p>
<ul>
<li>LookupKey/memtable_key：klength + user_key + sequence+type</li>
<li>InternalKey：user_key + sequence+type</li>
<li>不管是memtable还是sstable文件，其内部都是按InternalKey有序的。 比较时先使用InternalKey内部的user_key进行比较，再比较sequence_num</li>
</ul>
<h5 id="sstable存储结构">sstable存储结构</h5><h4 id="Cache">Cache</h4><h5 id="table_cache">table cache</h5><p>table cache的key值是SSTable的文件名称，Value部分包含两部分，一个是指向磁盘打开的SSTable文件的文件指针，这是为了方便读取内容；另外一个是指向内存中这个SSTable文件对应的Table结构指针。这样就将不同的sstable文件像cache一样进行管理。</p>
<h5 id="block_cache">block cache</h5><p>block cache 的结构其中的key是文件的cache_id加上这个block在文件中的起始位置block_offset。而value则是这个Block的内容</p>
<h4 id="Util基础工具包">Util基础工具包</h4><h5 id="coding-cc_—-_编解码">coding.cc —- 编解码</h5><p>leveldb所有数据都是字符形式，即使是整型，也将被转换为字符型存储。这样的好处就是可以减少内存空间的使用。例如，假如有一个int型数据，小于128，存储为整型时，需要占用四个字节，存储为字符型时，只需要一个字节即可。</p>
<p>LevelDB 使用了一种很简单的方案 <em>varint</em> 来节省小整数的存储。对于每一个字节，levelDB 使用其最高的 bit 位来表示当前的编码是否结束，而用低 7 bit 来存储实际的数据。<strong>如果最高位为1，表示当前的编码尚为结束，需要继续读下一字节的数据，否则当前的编码结束</strong>。示例：</p>
<ol>
<li>对于比较大的数，如果存储的数据如下<br>1001 0001  1000 1001 0111 1100<br>^          ^         ^      A: 最高位是1，未结束，实际值是后七位 001 0001<br>|          |         |      B: 最高位是1，未结束，实际值是后七位 000 1001<br>A          B         C      C: 最高位是0，结束，  实际值是后七位 111 1100<br>因此，三个字节拼接应该是 C + B + A :<br>[1111100][000 1001][0010001] = 2032785</li>
<li>对于 [0-127] 的整数，例如：<br>0001 0001<br>^                           A: 第一字节，最高位为0，表示结束，实际值是 0010001<br>|                              也就是 33<br>A</li>
</ol>
<h5 id="arena-cc_—-_内存池">arena.cc —- 内存池</h5><p>Arena内存池实现原理是每次向系统申请4KB大小的一整块内存block, 程序需要内存时,直接从block中获取一部分即可, 这样可以减少系统分配内存次数(new char[]操作), 降低系统分配内存带来的消耗。但是当程序需要一大块内存时(&gt;1024B)时就单独分配一块需要大小的内存，这样也是为了减少系统分配内存的次数。当需要的内存大于block剩余大小而且小于等于1024B时，重新分配一块block，这样会导致有1/4的block被浪费掉。</p>
<h5 id="cache-cc_—-_LRU缓存">cache.cc —- LRU缓存</h5><p>HashTable 和 环形双向链表的结合, hashtable实现O(1)存取时间复杂度; 双向链表实现每次读取或者插入元素都在链表head，每次淘汰链表tail。<code>lru.prev is newest entry, lru.next is oldest entry.</code></p>
<h5 id="schedule_—-_后台任务调度队列">schedule —- 后台任务调度队列</h5><h4 id="实例分析">实例分析</h4><h4 id="RocksDb_vs_LevelDb">RocksDb vs LevelDb</h4><h5 id="概述">概述</h5><h5 id="RocksDb新增特性和优化列表"><a href="http://xiaqunfeng.cc/2017/02/23/RocksDB%E7%9B%B8%E6%AF%94LevelDB%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7/" target="_blank" rel="noopener">RocksDb新增特性和优化列表</a></h5><p>性能优化：</p>
<ol>
<li>compaction和memtable inserts操作都多线程化，不止是后台单线程操作</li>
<li>减少互斥锁，优化写锁</li>
<li>Fewer comparator calls during SkipList searches</li>
<li>Allocate memtable memory using huge page</li>
<li>Prefix bloom filter</li>
<li>Optimized level-based compaction style and universal compaction style</li>
<li>对SSD存储做了优化，可以以in-memory方式运行</li>
</ol>
<p>新增特性：</p>
<ul>
<li>列簇（column families）</li>
<li>手动压缩与自动压缩并行运行</li>
<li>Persistent Cache 持久化缓存</li>
<li>Merge Operators，也就是原地更新，优化了modify的效率</li>
<li>Transactions and WriteBatchWithIndex</li>
<li>单个删除，以及范围删除文件</li>
<li>Vector-based and hash-based memtable format</li>
<li>Group commit和AwaitState</li>
<li>内存中有多个Immutable memtable</li>
</ul>
<h5 id="memtable">memtable</h5><p>rocksdb中,memtable在内存中的形式有三种：skiplist、hash-skiplist、hash-linklist。</p>
<h5 id="内联跳跃表（Inline_Skip_List）">内联跳跃表（Inline Skip List）</h5><h5 id="Group_commit和AwaitState">Group commit和AwaitState</h5><p>RocksDB多个写线程组成一个group， leader 负责 group 的 WAL (write ahead log)及 memtable 的提交，提交完后唤醒所有的 follwer，向上层返回；leader批量提交group所有线程的WAL日志，然后唤醒follower，一起开始并发无锁写memtable（allow_concurrent_memtable_write开关），洗完之后更新线程链表，开始下一轮写入；还支持enable_pipelined_write流水线配置，允许在WAL写完之后开始并发写memtale时就开始下一轮的group。</p>
<h4 id="参考链接">参考链接</h4>
      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="../../tags/C/"> #C++ </a>
          
        </div>
      

      

      
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              区块链技术探秘
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2017-11-11
        </span>

        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="../../2017/11/11/区块链技术探秘/#comments">
              <span class="post-comments-count ds-thread-count" data-thread-key="2017/11/11/区块链技术探秘/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        <h3 id="区块链">区块链</h3><p>技术角度来讲，<strong>区块链</strong>是分布式数据存储、P2P网络传输、共识机制、加密算法等技术的集成应用。区块链技术是利用块链式数据结构来验证与存储数据、利用分布式节点共识算法来生成和更新数据、利用密码学的方式保证数据传输和访问安全、利用智能化合约来编程和操作数据的一种全新的分布式基础架构与计算范式。  </p>
<p>通俗来讲，<strong>区块链</strong>是一个收录所有历史交易的分布式账本，每个区块中包含若干笔交易记录。如果说区块链是账本，那么区块就是账本的每一页。交易的细节都被记录在一个网络里任何人都可以看得到的公开账簿上，而且这个账本会保存在每个节点中。</p>
<p><strong>区块链的核心能力</strong>在于“大大降低了达成存在性证明的成本”：对于当前区块记录，采用一台矿机记录，成千上万矿机鉴证的模式，保证着没有非法区块被正确记录，当然理论上51%的矿机如果共同决定要做假，事实是可以记录假数据，只是在当前的算力下，准备如此大的算力来记录假数据，成本极高。</p>
<h4 id="主体架构">主体架构</h4><p>从架构设计上来说，区块链可以简单的分为三个层次，协议层、扩展层和应用层。<br><img src="https://raw.githubusercontent.com/Charles-Xiao/Charles-Xiao.github.io/master/images/blockchain_overview.png" class="full-image" width="100%"></p>
<h4 id="核心概念">核心概念</h4><ol>
<li><strong>共识机制</strong>：我们知道，比特币系统中每十分钟产生一个区块，同时有n个节点在收到了这个区块，那么由谁去负责打包这个区块，将其纳入区块链呢？为了达到这种共识，决定最终打包权，需要一种共识机制，例如比特币就采用了POW，看谁的计算力强大，哈希计算速度更快，谁就更有可能获得打包权，也就相应的获得打包的奖励以及交易的手续费用。</li>
<li><strong>挖矿过程</strong>：每一个比特币的节点都会收集所有尚未确认的交易，并将其归集到一个资料块中，比特币系统会在系统节点上将他生成一个随机代码，任何人都有权通过计算机去寻找此代码，争夺具有记账权的节点，挖矿节点不断重复进行尝试；矿工找到此代码，就会产生一个可记账区块，随即得到一个比特币的奖励报酬；当一个节点找到了符合要求的解，那么它就可以向全网广播自己的结果。其他节点就可以接收这个新解出来的资料块，并检验其是否符合规则。如果其他节点通过计算杂凑值发现确实满足要求（比特币要求的运算目标），那么该资料块有效，其他的节点就会接受该资料块。每隔一个时间点（10分钟），比特币系统会在系统节点上重新生成一个随机代码。具体计算随机数的流程：</li>
</ol>
<h4 id="传统分布式一致性算法和区块链共识过程的异同点">传统分布式一致性算法和区块链共识过程的异同点</h4><table>
<thead>
<tr>
<th style="text-align:center">—-</th>
<th style="text-align:left">传统一致性算法</th>
<th style="text-align:left">区块链共识算法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">主流算法</td>
<td style="text-align:left">paxos算法<br>raft算法</td>
<td style="text-align:left">pos(proof of stake)股权证明机制<br>pow(proof of work)工作量证明机制<br>瑞波共识机制(Ripple Consensus)</td>
</tr>
<tr>
<td style="text-align:center">相同点</td>
<td style="text-align:left">追加式写<br>强调序列化<br>长链覆盖短链区块，多节点覆盖少数节点日志<br>少数服从多数</td>
<td style="text-align:left">—-</td>
</tr>
<tr>
<td style="text-align:center">不同点</td>
<td style="text-align:left">1. 不考虑拜占庭容错(Byzanetine Paxos除外)，即假设所有节点只发生宕机、网络故障等非人为问题<br>2. 面向日志（数据库）的，即更通用的情况</td>
<td style="text-align:left">1. 需要考虑恶意节点篡改数据的问题<br>2. 区块链共识模型面向交易</td>
</tr>
</tbody>
</table>
<h3 id="比特币">比特币</h3><p>最初中本聪在2009年提出的白皮书是这么定义的 —- 《比特币：一种点对点的电子现金系统》，but，演变至今，比特币逐渐被理解为一种虚拟货币，而抽象出一种通用的技术框架—-区块链技术；比特币可以说是区块链技术的第一个应用，也是目前最成功的一个应用。比特币是一种P2P形式的数字货币，数量有限，一共只有2100万枚，有着类似于黄金的稀缺性。  </p>
<p>比特币协议规定：第0个 – 第21万个Block,每个Block里有50个比特币，第21万-第42万个Block，每个Block里有25个比特币，依次递减，最后比特币全网中只会有2100万个比特币。 </p>
<p>比特币系统中的几个常用概念与现有货币系统的类比：</p>
<blockquote>
<p>比特币钱包 —&gt; 电子银行的客户端</p>
<p>比特币地址 —&gt; 银行卡号</p>
<p>比特币密钥 —&gt; 银行卡密码</p>
</blockquote>
<h3 id="解决的问题">解决的问题</h3><p>如果说互联网技术解决了人类的信息获取问题，那边区块链技术则解决了人类之间的信任问题。传统人与与人之间的交易，一般都通过一个权威的中心进行，如通过银行转账，通过中介，政府的介入才能进行房屋买卖。而<strong>区块链让全网所有的节点共同维护一个账本，每个节点都有一份账本，交易记录一旦确定就无法修改等特点保证了交易记录的真实可靠，无法篡改。</strong>所以陌生人之间可以基于区块链技术直接进行各种交易，并保证交易的真实可靠和完全可信。</p>
<h3 id="应用场景">应用场景</h3><ol>
<li><p><strong>银行业</strong></p>
<blockquote>
<p>作为一种数字化，安全防干扰的帐户，区块链实现了银行业的核心功能：即价值的安全储存和转移中心。也就是说，在将来的几年内，一波基于区块链技术的公司或将影响到银行业。</p>
</blockquote>
</li>
<li><p><strong>支付和转账</strong></p>
<blockquote>
<p>区块链技术能够避开繁杂的系统，在付款人和收款人之间创造更直接的付款流程，不管是境内转账还是跨境转账，这种方式都有着低价、迅速的特点，而且无需中间手续费。</p>
</blockquote>
</li>
<li><p><strong>网络安全</strong></p>
<blockquote>
<p>虽然区块链的系统是公开的，但其核验、发送等数据交流过程却采用了先进的加密技术。这种技术不仅确保了数据的正确来源，也确保了数据在中间过程不被人拦截。如果区块链技术的应用更为广泛，那么其遭受黑客袭击的概率也可能会下降，因此人们认为区块链系统要比传统系统更为稳妥。区块链系统之所以能降低传统网络安全风险，一大原因就是它解除了对中间人的需求。</p>
</blockquote>
</li>
<li><p><strong>选举</strong></p>
<blockquote>
<p>大家的投票“绝不可能被我们——即程序员，学校管理员或学生修改、删除。”，信任代价降低。</p>
</blockquote>
</li>
<li><p><strong>智能合同</strong></p>
<blockquote>
<p>智能合同实际上是在另一个物体的行动上发挥功能的电脑程序。和普通电脑程序一样，智能合同也是一种“如果-然后”功能，但区块链技术实现了这些“合同”的自动填写，无需人工介入。这种合同最终可能会取代法律行业的核心业务，即在商业和民事领域起草和管理合同的业务。</p>
</blockquote>
</li>
<li><p><strong>股票交易</strong></p>
<blockquote>
<p>许多年来，各个公司都在想方设法简化股票的购买、销售和交易过程，新兴的区块链技术创企认为他们能够超越以往，实现整个流程的自动化，提高安全性和效率。</p>
</blockquote>
</li>
</ol>

      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="../../tags/分布式系统/"> #分布式系统 </a>
          
            <a href="../../tags/区块链/"> #区块链 </a>
          
        </div>
      

      

      
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              分布式存储系统基础
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2017-11-11
        </span>

        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="../../2017/11/11/分布式系统基础知识/#comments">
              <span class="post-comments-count ds-thread-count" data-thread-key="2017/11/11/分布式系统基础知识/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        <h3 id="块存储/对象存储/文件系统">块存储/对象存储/文件系统</h3><ol>
<li><strong>块存储</strong>：访问时延是10ms级，常用于跟虚机搭配使用，与普通硬盘无异，读写速度由于并发所以非常快。既要能应付大文件读写，也能处理好小文件读写。但是硬盘的特点是容量大，热点明显。因此块存储主要可以应付热点问题。另外，块存储要求的延迟是最低的。通常以QEMU Driver或者Kernel Module的方式存在，这种接口需要实现Linux的Block Device的接口或者QEMU提供的Block Driver接口，如Sheepdog，AWS的EBS，ceph的RBD；分布式块存储系统通常提供快照功能，方便在故障或者是业务需要的时候，将块设备上的数据恢复到期望的一个时间点。每次快照并不是全量快照，而是增量快照，仅对修改过的区间进行备份。</li>
<li><strong>对象存储</strong>：访问时延是100ms-1s级，通常以大文件为主，要求足够的IO带宽。接口就是简单的GET、PUT、DEL和其他扩展，如七牛、又拍、Swift、S3</li>
<li><strong>文件存储</strong>：通常意义是支持POSIX接口，它跟传统的文件系统如Ext4是一个类型的，需要考虑目录、文件属性等支持；但区别在于分布式存储提供了并行化的能力，如Ceph的CephFS；分布式文件系统通常需要有一个或一组namenode节点维护目录树，一个或一组metaserver节点来维护文件元信息</li>
<li>块存储和文件存储在形态上虽然不同，但实际使用基本一致，块存储扩展性好、兼容性更好，但使用略麻烦；文件存储使用方便，且故障隔离性好，但扩展性不好。</li>
<li><strong>表格存储</strong></li>
<li><strong>归档存储</strong></li>
</ol>
<h3 id="OLAP与OLTP">OLAP与OLTP</h3><p>当今的数据处理大致可以分成两大类：<strong>联机事务处理OLTP（on-line transaction processing）、联机分析处理OLAP（On-Line Analytical Processing）</strong>。OLTP是传统的关系型数据库的主要应用，主要是基本的、日常的事务处理，例如银行交易，关注实时性，数据量较少。OLAP是数据仓库系统的主要应用，支持复杂的分析操作，侧重决策支持，并且提供直观易懂的查询结果。</p>
<ul>
<li><strong>数据库OLTP</strong>：传统的关系型数据库的主要应用，主要是基本的、日常的事务处理，例如银行交易。</li>
<li><strong>数据仓库</strong>：数据仓库系统的主要应用主要是OLAP（On-Line Analytical Processing），支持复杂的分析操作，侧重决策支持，并且提供直观易懂的查询结果。</li>
<li>举个最常见的例子，拿电商行业来说好了。基本每家电商公司都会经历，从只需要业务数据库到要数据仓库的阶段。<ol>
<li>电商早期启动非常容易，入行门槛低。找个外包团队，做了一个可以下单的网页前端 + 几台服务器 + 一个MySQL，就能开门迎客了。这好比手工作坊时期。</li>
<li>第二阶段，流量来了，客户和订单都多起来了，普通查询已经有压力了，这个时候就需要升级架构变成多台服务器和多个业务数据库（量大+分库分表），这个阶段的业务数字和指标还可以勉强从业务数据库里查询。初步进入工业化。</li>
<li>第三个阶段，一般需要 3-5 年左右的时间，随着业务指数级的增长，数据量的会陡增，公司角色也开始多了起来，开始有了 CEO、CMO、CIO，大家需要面临的问题越来越复杂，越来越深入。高管们关心的问题，从最初非常粗放的：“昨天的收入是多少”、“上个月的 PV、UV 是多少”，逐渐演化到非常精细化和具体的用户的集群分析，特定用户在某种使用场景中，例如“20~30岁女性用户在过去五年的第一季度化妆品类商品的购买行为与公司进行的促销活动方案之间的关系”。</li>
<li>这类非常具体，且能够对公司决策起到关键性作用的问题，基本很难从业务数据库从调取出来。原因在于：业务数据库中的数据结构是为了完成交易而设计的，不是为了而查询和分析的便利设计的。业务数据库大多是读写优化的，即又要读（查看商品信息），也要写（产生订单，完成支付）。因此对于大量数据的读（查询指标，一般是复杂的只读类型查询）是支持不足的。</li>
<li>而怎么解决这个问题，此时我们就需要建立一个数据仓库了，公司也算开始进入信息化阶段了。数据仓库的作用在于：数据结构为了分析和查询的便利；只读优化的数据库，即不需要它写入速度多么快，只要做大量数据的复杂查询的速度足够快就行了。那么在这里前一种业务数据库（读写都优化）的是业务性数据库，后一种是分析性数据库，即数据仓库。</li>
</ol>
</li>
<li>最后总结一下：数据库比较流行的有：MySQL, Oracle, SqlServer等。数据仓库比较流行的有：AWS Redshift, Greenplum, Hive等。这样把数据从业务性的数据库中提取、加工、导入分析性的数据库就是传统的 ETL 工作。</li>
</ul>
<h3 id="CAP理论">CAP理论</h3><p>2000年7月，加州大学伯克利分校的Eric Brewer教授在ACM PODC会议上提出CAP猜想。2年后，麻省理工学院的Seth Gilbert和Nancy Lynch从理论上证明了CAP；也就是：<strong>一个分布式系统最多只能同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance）这三项中的两项</strong>。  </p>
<ol>
<li><strong>一致性</strong>：<code>all nodes see the same data at the same time</code>；根据业务场景可以分为强一致性，弱一致性和最终一致性。对于关系型数据库，要求更新过的数据能被后续的访问都能看到，这是<strong>强一致性</strong>。如果能容忍后续的部分或者全部访问不到，则是<strong>弱一致性</strong>。如果经过一段时间后要求能访问到更新后的数据，则是<strong>最终一致性</strong>。</li>
<li><strong>可用性</strong>：<code>Reads and writes always succeed</code>，即服务一直可用，而且是正常响应时间。如果系统每运行100个时间单位，会有1个时间单位无法提供服务，则说系统的可用性是99%。</li>
<li><strong>分区容错性</strong>：<code>the system continues to operate despite arbitrary message loss or failure of part of the system</code>，即分布式系统在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务。</li>
<li><strong>CAP权衡</strong>：</li>
</ol>
<blockquote>
<p>CA without P：如果不要求P（不允许分区），则C（强一致性）和A（可用性）是可以保证的。但其实分区不是你想不想的问题，而是始终会存在，因此CA的系统更多的是允许分区后各子系统依然保持CA。</p>
<p>CP without A：如果不要求A（可用），相当于每个请求都需要在Server之间强一致，而P（分区）会导致同步时间无限延长，如此CP也是可以保证的。很多传统的数据库分布式事务都属于这种模式。</p>
<p>AP wihtout C：要高可用并允许分区，则需放弃一致性。一旦分区发生，节点之间可能会失去联系，为了高可用，每个节点只能用本地数据提供服务，而这样会导致全局数据的不一致性。现在众多的NoSQL都属于此类。</p>
<p>对于多数大型互联网应用，集群规模庞大、主机众多、部署分散，节点故障、网络故障是常态，而且要保证服务可用性达到N个9，往往采用AP without C，只保证最终一致性即可。</p>
<p>对于银行业场景，C必须保证。网络发生故障宁可停止服务，这是保证CA，舍弃P；还有一种是保证CP，舍弃A，例如网络故障事只读不写。</p>
<p>保证P的前提下，选择一致性C，举例：传统单库水平切分，就是这类选型的典型</p>
<p>保证P的前提下，选择可用性A，举例：双主库同步高可用，就是这类选型的典型</p>
</blockquote>
<h3 id="分布式存储常见概念名词">分布式存储常见概念名词</h3><ol>
<li><strong>RAID(Redundant Array of Independent Disk 独立冗余磁盘阵列)</strong>是加州大学伯克利分校1987年提出，最初是为了组合小的廉价磁盘来代替大的昂贵磁盘，同时希望磁盘失效时不会使对数据的访问受损失而开发出一定水平的数据保护技术。<strong>RAID就是一种由多块廉价磁盘构成的冗余阵列，在操作系统下是作为一个独立的大型存储设备出现。RAID可以充分发挥出多块硬盘的优势，可以提升硬盘速度，增大容量，提供容错功能够确保数据安全性，易于管理的优点</strong>，在任何一块硬盘出现问题的情况下都可以继续工作，不会受到损坏硬盘的影响。</li>
<li><strong>RAID卡</strong>就是用来实现RAID功能的板卡，通常是由I/O<a href="http://baike.baidu.com/view/50152.htm" target="_blank" rel="noopener">处理器</a>、SCSI控制器、SCSI连接器和缓存等一系列零组件构成的。不同的RAID卡支持的RAID功能不同。支持RADI0、RAID1、RAID3、RAID4、RAID5、RAID10不等。RAID卡可以让很多磁盘驱动器同时传输数据，而这些磁盘驱动器在逻辑上又是一个磁盘驱动器，所以使用RAID可以达到单个的磁盘驱动器几倍、几十倍甚至上百倍的速率。这也是RAID卡最初想要解决的问题。可以提供容错功能，这是RAID卡的第二个重要功能。</li>
<li><strong>MVCC</strong></li>
<li><strong>EC编码与各级RAID</strong></li>
</ol>
<h3 id="轮询调度算法">轮询调度算法</h3><ol>
<li>轮询调度算法的原理是每一次把来自用户的请求轮流分配给内部中的服务器，从1开始，直到N(内部服务器个数)，然后重新开始循环；即每次调度执行<code>i = N-1; i = (i+1) mod N</code>，并选出第i台服务器</li>
<li>适合于服务器组中的所有服务器都有相同的软硬件配置并且平均服务请求相对均衡的情况, 它无需记录当前所有连接的状态，是一种无状态调度。</li>
</ol>
<h3 id="Learned_Indexes_VS_Traditional_Indexes">Learned Indexes VS Traditional Indexes</h3><blockquote>
<p>目前存在多种索引的选择来解决各种访问模式的需求。例如 B-Trees 是范围请求最好的选择（例如在特定时间线上索引所有的数据记录），哈希表（Hash-Maps）在性能上很难打败基于键值的搜索方法，而布隆过滤器 (Bloom Filter) 通常用于检测是否存在某条记录。由于索引对于数据库系统和其它一些应用的重要性，过去几十年来，它们已经广泛地发展为更高的内存、缓存和 CPU 效率的方法</p>
<p>本论文的核心思想是一个模型可以学习排序顺序或查找键的结构，并使用这一信号有效地预测记录的位置或存在。我们从理论上分析了学习索引在什么条件下表现优于传统索引结构，并描述了设计学习索引结构的主要挑战。我们的初步结果表明，借助神经网络，我们能够超过缓存优化的 B-Trees 高达 70％的速度，同时为若干个真实数据集节省一个数量级的内存。</p>
</blockquote>
<h3 id="分布式事务">分布式事务</h3><h4 id="两阶段提交2PC">两阶段提交2PC</h4><ol>
<li>二阶段提交2PC（Two phase Commit）是一种在分布式环境下所有节点进行事务提交保持一致性的算法。它通过引入一个协调者（Coordinator）来统一掌控所有参与者（Participant）的操作结果，并指示它们是否要把操作结果进行真正的提交（commit）或者回滚（rollback）。</li>
<li>两个阶段：<ul>
<li>投票阶段（voting phase）：参与者通知协调者，协调者反馈结果；</li>
<li>提交阶段（commit phase）：收到参与者的反馈后，协调者再向参与者发出通知，根据反馈情况决定各参与者是否要提交还是回滚</li>
</ul>
</li>
<li>2PC在执行过程中，所有节点都处于阻塞状态，所有节点所持有的资源（例如数据库数据，本地文件等）都处于封锁状态。例如，某一个参与者回复消息之前，所有参与者以及协调者都处于阻塞状态；在协调者发出消息之前，所有参与者都处于阻塞状态。要打破完全阻塞状态需要引入超时机制。</li>
</ol>
<h3 id="常见分布式一致性算法">常见分布式一致性算法</h3><h4 id="Paxos">Paxos</h4><h4 id="Raft">Raft</h4><h4 id="异同点">异同点</h4><h4 id="应用场景">应用场景</h4><ol>
<li><strong>2PC和Paxos区别</strong>：2PC用于保证多个数据分片上分布式事务的原子性，Paxos协议用于保证同一个数据分片在多个副本的分布式一致性，所以两者可以是互补的关系，绝不是替代关系。对于2PC协调者单点问题，可以利用Paxos协议解决，当协调者出问题时，选一个新的协调者继续提供服务。</li>
</ol>

      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="../../tags/存储/"> #存储 </a>
          
            <a href="../../tags/分布式系统/"> #分布式系统 </a>
          
        </div>
      

      

      
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              C++常用数据结构
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2017-11-11
        </span>

        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="../../2017/11/11/C++常用数据结构/#comments">
              <span class="post-comments-count ds-thread-count" data-thread-key="2017/11/11/C++常用数据结构/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        <h3 id="C++常用std集合—map/set">C++常用std集合—map/set</h3><ol>
<li>unordered_map在C++11的时候被引入标准库了，而hash_map没有，所以建议还是使用unordered_map比较好。查询平均时间是O(1)，无序，类似于Java中HashMap。</li>
<li>map的内部结构是R-B-tree来实现的，所以保证了一个稳定的动态操作时间，查询、插入、删除都是O（logN），最坏和平均都是。而unordered_map如前所述，是哈希表。顺便提一下，哈希表的查询时间虽然是O（1），但是并不是unordered_map查询时间一定比map短，因为实际情况中还要考虑到数据量，而且unordered_map的hash函数的构造速度也没那么快，所以不能一概而论，应该具体情况具体分析。最坏会是O(n)，额外空间复杂度则要高出许多。map中的元素是按照二叉搜索树存储，进行中序遍历会得到有序遍历，默认遍历顺序为以key从小到大。</li>
<li>无序集合（Unordered Set）容器是一个存储唯一（Unique，即无重复）元素的关联容器（Associative container），容器中的元素无特别的次序关系。该容器允许基于值地快速元素检索。类似于HashSet。</li>
<li><a href="https://zcheng.ren/2016/09/09/STLSetAndMap/#set" target="_blank" rel="noopener">set/multiset/map/multimap的内部实现和常用函数</a></li>
<li><a href="https://github.com/julycoding/The-Art-Of-Programming-By-July/blob/master/ebook/zh/03.01.md" target="_blank" rel="noopener">红黑树原理</a></li>
</ol>
<h3 id="BloomFilter布隆过滤器">BloomFilter布隆过滤器</h3><ol>
<li><p>核心实现是一个很长的二进制向量 （位数组）再加上一系列随机函数 (哈希)，空间效率和查询效率高，不会漏判，但是有一定的误判率（哈希表是精确匹配）。</p>
</li>
<li><p><a href="https://blog.csdn.net/tianyaleixiaowu/article/details/74721877" target="_blank" rel="noopener">布隆过滤器解决缓存击穿、垃圾邮件识别、集合判重</a></p>
</li>
</ol>
<h3 id="SkipList跳跃表">SkipList跳跃表</h3><h3 id="参考链接">参考链接</h3>
      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="../../tags/C/"> #C++ </a>
          
        </div>
      

      

      
      
    </div>
  </div>


    
  </div>

  
  <div class="pagination">
    <a class="extend prev" rel="prev" href="../5/">&laquo;</a><a class="page-number" href="../../">1</a><span class="space">&hellip;</span><a class="page-number" href="../5/">5</a><span class="page-number current">6</span><a class="page-number" href="../7/">7</a><span class="space">&hellip;</span><a class="page-number" href="../17/">17</a><a class="extend next" rel="next" href="../7/">&raquo;</a>
  </div>


        </div>

        
      </div>


      
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <div id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      <div class="site-overview">
        <div class="site-author motion-element">
          <img class="site-author-image" src="/images/avatar.jpg" alt="CharlesXiao">
          <p class="site-author-name">CharlesXiao</p>
        </div>
        <p class="site-description motion-element">在码农炼成之路不断挣扎……stay hungry……keep learning……</p>
        <div class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="../../archives">
              <span class="site-state-item-count">84</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            <a href="../../categories">
              <span class="site-state-item-count">17</span>
              <span class="site-state-item-name">分类</span>
              </a>
          </div>

          <div class="site-state-item site-state-tags">
            <a href="../../tags">
              <span class="site-state-item-count">76</span>
              <span class="site-state-item-name">标签</span>
              </a>
          </div>

        </div>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
              <a href="https://github.com/Charles-Xiao" target="_blank">github</a>
            </span>
            
              <span class="links-of-author-item">
              <a href="http://weibo.com/2262300105/profile?topnav=1&wvr=6" target="_blank">weibo</a>
            </span>
            
              <span class="links-of-author-item">
              <a href="http://daijiale.github.io/" target="_blank">Daijiale的个人站点</a>
            </span>
            
          
        </div>

        
        

      </div>

      

    </div>
  </div>


    </div>

    <div id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; &nbsp;  2015.05.16 - 
  2018
  <span class="with-love">
    <i class="icon-heart"></i>
  </span>
  <span class="author">CharlesXiao</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>



      </div>
    </div>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="../../vendors/jquery/index.js?v=2.1.3"></script>

  
  

  
  <script type="text/javascript" src="../../vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript">
    $(document).ready(function() {
      $('.content img').each(function () {
        var $image = $(this);
        var $imageWrapLink = $image.parent('a');

        if ($imageWrapLink.size() < 1) {
          $imageWrapLink = $image.wrap('<a href="' + this.getAttribute('src') + '"></a>').parent('a');
        }
        $imageWrapLink.addClass('fancybox');
      });
    });
    $('.fancybox').fancybox({
      helpers: {
        overlay: {
          locked: false
        }
      }
    });
  </script>


  <script type="text/javascript">
  function hasMobileUA () {
    var nav = window.navigator;
    var ua = nav.userAgent;
    var pa = /iPad|iPhone|Android|Opera Mini|BlackBerry|webOS|UCWEB|Blazer|PSP|IEMobile|Symbian/g;

    return pa.test(ua);
  }

  function isDesktop () {
    return screen.width > 991 && !hasMobileUA();
  }

  function isTablet () {
    return screen.width < 992 && screen.width > 767 && hasMobileUA();
  }

  function isMobile () {
    return screen.width < 767 && hasMobileUA();
  }

  function escapeSelector (selector) {
    return selector.replace(/[!"$%&'()*+,.\/:;<=>?@[\\\]^`{|}~]/g, "\\$&")
  }
</script>

  

  <script type="text/javascript" src="../../vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="../../vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" id="motion.global">
  $(document).ready(function () {
    var body = $('body');
    var isSidebarVisible = false;
    var sidebarToggle = $('.sidebar-toggle');
    var sidebarToggleLine1st = $('.sidebar-toggle-line-first')
    var sidebarToggleLine2nd = $('.sidebar-toggle-line-middle');
    var sidebarToggleLine3rd = $('.sidebar-toggle-line-last');
    var sidebar = $('.sidebar');

    var SIDEBAR_WIDTH = '320px';
    var SIDEBAR_DISPLAY_DURATION = 300;

    var sidebarToogleLineStatusInit = {width: '100%', opacity: 1, left: 0, rotateZ: 0, top: 0};

    var sidebarToggleLine1stStatusInit = sidebarToogleLineStatusInit;
    var sidebarToggleLine1stStatusArrow = {width: '50%', rotateZ: '-45deg', top: '2px'};
    var sidebarToogleLine1stStatusClose = {width: '100%', rotateZ: '-45deg', top: '5px'};

    var sidebarToggleLine2ndStatusInit = sidebarToogleLineStatusInit;
    var sidebarToggleLine2ndStatusArrow = {width: '90%'};
    var sidebarToogleLine2ndStatusClose = {opacity: 0};

    var sidebarToggleLine3rdStatusInit = sidebarToogleLineStatusInit;
    var sidebarToggleLine3rdStatusArrow = {width: '50%', rotateZ: '45deg', top: '-2px'};
    var sidebarToogleLine3rdStatusClose = {width: '100%', rotateZ: '45deg', top: '-5px'};

    LogoAndMenuMotion();
    sidebatToggleMotion();
    postsListMotion();
    backToTopMotion();


    $(document)
      .on('sidebar.isShowing', function () {
        isDesktop() && body.velocity(
          {paddingRight: SIDEBAR_WIDTH},
          SIDEBAR_DISPLAY_DURATION
        );
        sidebarContentMotion();
      })
      .on('sidebar.isHiding', function () {});

    function LogoAndMenuMotion() {
      $.Velocity.RunSequence([
        { e: $('.brand'), p: { opacity: 1 }, o: { duration: 100 } },
        { e: $('.logo'), p: { opacity: 1, top: 0 }, o: { duration: 50} },
        
        { e: $('.logo-line-before i'), p: { translateX: "100%" }, o: { duration: 500, sequenceQueue: false } },
        { e: $('.logo-line-after i'), p: { translateX: "-100%" }, o: { duration: 500, sequenceQueue: false } },
        
        { e: $('.site-title'), p: { opacity: 1, top: 0 }, o: { duration: 200 } }
      ]);
      $('.menu-item').velocity('transition.slideDownIn', {display: null});
    }


    function backToTopMotion () {
      var b2top = $('.back-to-top');
      b2top.on('click', function () {
        body.velocity('scroll');
      });
    }

    function sidebarShowMotion () {

      sidebarToggleLine1st.velocity(sidebarToogleLine1stStatusClose);
      sidebarToggleLine2nd.velocity(sidebarToogleLine2ndStatusClose);
      sidebarToggleLine3rd.velocity(sidebarToogleLine3rdStatusClose);

      sidebar.velocity({width: SIDEBAR_WIDTH}, {
        display: 'block',
        duration: SIDEBAR_DISPLAY_DURATION,
        complete: function () {
          sidebar.addClass('sidebar-active');
          sidebar.trigger('sidebar.didShow');
        }
      });
      sidebar.trigger('sidebar.isShowing');
    }

    function sidebarHideMotion () {
      isDesktop() && body.velocity({paddingRight: 0});
      sidebar.velocity('reverse');

      sidebarToggleLine1st.velocity(sidebarToggleLine1stStatusInit);
      sidebarToggleLine2nd.velocity(sidebarToggleLine2ndStatusInit);
      sidebarToggleLine3rd.velocity(sidebarToggleLine3rdStatusInit);

      sidebar.removeClass('sidebar-active');
      sidebar.trigger('sidebar.isHiding');
    };

    function sidebarContentMotion () {
      $('.sidebar .motion-element').velocity(
        'transition.slideRightIn',
        {stagger: 50, drag: true}
      );
    }

    function postsListMotion () {
      var postMotionOptions = window.postMotionOptions || {stagger: 300, drag: true};
      $('.post').velocity('transition.slideDownIn', postMotionOptions);
    }

    function sidebatToggleMotion () {
      sidebarToggle.on('click', function () {
        isSidebarVisible ? sidebarHideMotion() : sidebarShowMotion();
        isSidebarVisible = !isSidebarVisible;
      });

      sidebarToggle.hover(function () {
        if (isSidebarVisible) {return}
        sidebarToggleLine1st.velocity('stop').velocity(sidebarToggleLine1stStatusArrow);
        sidebarToggleLine2nd.velocity('stop').velocity(sidebarToggleLine2ndStatusArrow);
        sidebarToggleLine3rd.velocity('stop').velocity(sidebarToggleLine3rdStatusArrow);
      }, function () {
        if (isSidebarVisible) {return}
        sidebarToggleLine1st.velocity('stop').velocity(sidebarToggleLine1stStatusInit);
        sidebarToggleLine2nd.velocity('stop').velocity(sidebarToggleLine2ndStatusInit);
        sidebarToggleLine3rd.velocity('stop').velocity(sidebarToggleLine3rdStatusInit);
      });
    }
  });

</script>





  

  
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
  });
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for (i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>


  
  
  


  

  
</body>
</html>
