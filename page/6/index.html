<!doctype html>
<html class="theme-next use-motion theme-next-mist">
<head>
  

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






  <link rel="stylesheet" type="text/css" href="../../vendors/fancybox/source/jquery.fancybox.css?v=2.1.5"/>


<link rel="stylesheet" type="text/css" href="../../css/main.css?v=0.4.2"/>


    <meta name="description" content="在码农炼成之路不断挣扎……stay hungry……keep learning……" />



  <meta name="keywords" content="java,android,life,CharlesXiao" />





  <link rel="shorticon icon" type="image/x-icon" href="../..//favicon.ico?v=0.4.2" />



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?6749450";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>


  <title> CharlesXiao‘s Blog </title>
</head>

<body>
<!--[if lte IE 8]> <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'> <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode"><img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820" alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari." style='margin-left:auto;margin-right:auto;display: block;'/></a></div> <![endif]-->
  <div class="container one-column 
   page-home 
">
    <div class="headband"></div>

    <div id="header" class="header">
      <div class="header-inner">
        <h1 class="site-meta">
  <span class="logo-line-before"><i></i></span>
  <a href="/" class="brand">
      <span class="logo">
        <i class="icon-logo"></i>
      </span>
      <span class="site-title">CharlesXiao‘s Blog</span>
  </a>
  <span class="logo-line-after"><i></i></span>
</h1>


  <ul id="menu" class="menu">
     
    <!--增加swiftype搜索功能-->
    <form class="menu-item menu-item-search">
      <input type="text" id="st-search-input" class="st-search-input st-default-search-input" />
    </form>
    
    <script type="text/javascript">
      (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
      (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
      e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
      })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

      _st('install','yxUhPQ2aHyszT_1btxX9','2.0.0');
    </script>
    <!--增加swiftype搜索功能end-->
    
    
      
      <li class="menu-item menu-item-home">
        <a href="../..//">
          <i class="menu-item-icon icon-home"></i> <br />
          首页
        </a>
      </li>
    
      
      <li class="menu-item menu-item-categories">
        <a href="../..//categories">
          <i class="menu-item-icon icon-categories"></i> <br />
          分类
        </a>
      </li>
    
      
      <li class="menu-item menu-item-about">
        <a href="../..//about">
          <i class="menu-item-icon icon-about"></i> <br />
          关于
        </a>
      </li>
    
      
      <li class="menu-item menu-item-archives">
        <a href="../..//archives">
          <i class="menu-item-icon icon-archives"></i> <br />
          归档
        </a>
      </li>
    
      
      <li class="menu-item menu-item-tags">
        <a href="../..//tags">
          <i class="menu-item-icon icon-tags"></i> <br />
          标签
        </a>
      </li>
    
  </ul>


      </div>
    </div>

    <div id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content">
          
  <div id="posts" class="posts-expand">
    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="../../2017/11/11/常见分布式对象存储系统实现思考/">
                常见分布式对象存储系统实现思考
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2017-11-11
        </span>

        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="../../2017/11/11/常见分布式对象存储系统实现思考/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2017/11/11/常见分布式对象存储系统实现思考/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <p>整体来看，从上到下，一个对象存储系统应该包括产品层的高级功能(包括鉴权、读写接口)、元数据管理模块(MySQL、NewSQL数据库)、数据管理模块(对象数据的管理)。可以参考S3、Ceph等系统。</p>
<h3 id="元数据管理模块">元数据管理模块</h3><h4 id="NewSQL">NewSQL</h4><p>NewSQL 的出现就是为了解决扩展性和一致性之间的矛盾，主要面向 OLTP 业务和轻量级的OLAP业务。<strong>几点特性</strong>：</p>
<ol>
<li>支持常见SQL语句查询，需要实现一个分布式SQL engine，利用多个节点的计算能力，生成更好的执行计划，将计算逻辑尽可能的均摊到多个存储节点上，与单机引擎不同的是考虑网络的开销和延迟。</li>
<li>支持 ACID 的跨行事务，两阶段提交实现分布式事务，也就是保证多个节点操作的原子性，要么全部节点成功要么全部失败</li>
<li>自动可扩展性。目前关系型数据库的扩展方案上，基本只有分库分表和 PROXY 中间件两种方案。</li>
<li>自动FailOver。常规主从复制方式无法脱离人工运维，因此选用 Multi-Paxos 或者 Raft 这样基于分布式选举的复制协议，在某节点故障的时候，支持完全自动和强一致的故障转移和自我恢复，还能实现跨数据中心多活</li>
</ol>
<h3 id="数据管理模块">数据管理模块</h3><h4 id="几个思考">几个思考</h4><h5 id="为什么要用EC编码和三副本kv存储相结合的方式？">为什么要用EC编码和三副本kv存储相结合的方式？</h5><p>从3副本到1.5副本，主要是为了节省成本。3副本其实数据可靠性(也就是数据持久性)其实很低。对大对象直接进行EC编码，但是小对象不能直接EC，因为小对象太多，如果EC会带来IOPS放大；可以考虑对小对象打包之后做EC，避免增大IOPS。</p>
<h5 id="如何实现快速空间回收？也就是快速删除object">如何实现快速空间回收？也就是快速删除object</h5><h5 id="如何将存储副本降低到1-33的？">如何将存储副本降低到1.33的？</h5><h5 id="EC编码如何提高数据的持久性？">EC编码如何提高数据的持久性？</h5><h5 id="如何实现多AZ和更高的集群可扩展性？">如何实现多AZ和更高的集群可扩展性？</h5><h5 id="如何提高系统的读写性能？">如何提高系统的读写性能？</h5>
        
      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="../../tags/分布式系统/"> #分布式系统 </a>
          
            <a href="../../tags/对象存储/"> #对象存储 </a>
          
        </div>
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="../../2017/11/11/2018/">
                2018
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2017-11-11
        </span>

        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="../../2017/11/11/2018/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2017/11/11/2018/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <h3 id="投资理财">投资理财</h3><ul>
<li>美股和港股</li>
<li>基金和P2P理财类(懒投资，网贷之家，行业收紧需慎重) — 不再碰</li>
<li>百度钱包等固定收益类 — 稳定收益</li>
<li>少量虚拟货币 — 自媒体扩大业务，50%进入投资</li>
<li>股票技术面分析理论与实践</li>
<li>阅读5本相关书籍：格林皮特的两本，技术面分析2本，宏微观经济 — doing</li>
</ul>
<h3 id="被动收入">被动收入</h3><ul>
<li>内容号，包括博客，百家号等 — done，微博+头条+微信</li>
<li>小程序，招聘信息类爬虫等开发类产品 — 红利期还没爆发？百度小程序？</li>
</ul>
<h3 id="技术成长">技术成长</h3><ul>
<li>有一个系统全面的roadmap和framework</li>
<li>基础技术方面：语言，操作系统，网络</li>
<li>专业技能：分布式系统，存储，云计算相关新技术栈</li>
<li>算法和数据结构：leetcode到达300道，以C++，Go，Java三种语言</li>
<li>阅读5本相关书籍：深入理解计算机系统、effective C++、Golang一本、系统架构</li>
<li>阅读2-3份源码：Nginx、Leveldb、raft or brpc、redis、mysql、golang</li>
<li>熟悉3个周边系统：BlobStorage、proxy、tafDB、Mola</li>
</ul>
<h3 id="外部机遇">外部机遇</h3><ul>
<li>涨薪机会</li>
<li>晋升机会</li>
<li>技术转管理或金融机会</li>
<li>跳槽机会</li>
<li>面试技巧训练</li>
<li>找准3次定位</li>
</ul>
<h3 id="行业新风口">行业新风口</h3><ul>
<li>机器学习与AI算法</li>
<li>区块链和虚拟货币</li>
</ul>
<h3 id="随笔札记">随笔札记</h3><p>区块链技术的发展很有可能带来技术革新，类似于PC互联网、移动互联网、自媒体内容创业这样同等重要的机遇，如何抓住并且变现，值得思考！  </p>
<p>房产市场的变化，从买房到租房，可能会引发下一个投资机遇，这个跟政策有很大关系，应该多加关注房地产政策的走向和解读  </p>

        
      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="../../tags/2018/"> #2018 </a>
          
        </div>
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="../../2017/02/19/Linux正则表达式:通配符揭秘/">
                Linux正则表达式/通配符揭秘
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2017-02-19
        </span>

        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="../../2017/02/19/Linux正则表达式:通配符揭秘/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2017/02/19/Linux正则表达式:通配符揭秘/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <h4 id="正则表达式概念">正则表达式概念</h4><p><strong>正则表达式</strong>是你所定义的模式模板(pattern template)，Linux工具可以用它来过滤文本；如果数据匹配模式，它就会被接受并进一步处理;如果数据不匹配模式，它就会被滤掉。正则表达式模式利用通配符来描述数据流中的一个或多个字符，例如<figure class="highlight"><figcaption><span>da*```da*参数会让ls命令只列出名字以da开头的文件。文件名中da之后可以有任意多个字符(包括什么也没有)。  </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10;&#27491;&#21017;&#34920;&#36798;&#24335;&#26159;&#36890;&#36807;&#27491;&#21017;&#34920;&#36798;&#24335;&#24341;&#25806;(regular expression engine)&#23454;&#29616;&#30340;&#12290;&#27491;&#21017;&#34920;&#36798;&#24335;&#24341;&#25806;&#26159;&#19968;&#22871;&#24213;&#23618;&#36719;&#20214;&#65292;&#36127;&#36131;&#35299;&#37322;&#27491;&#21017;&#34920;&#36798;&#24335;&#27169;&#24335;&#24182;&#20351;&#29992;&#36825;&#20123;&#27169;&#24335;&#36827;&#34892;&#25991;&#26412;&#21305;&#37197;&#12290;&#10;#### &#27491;&#21017;&#34920;&#36798;&#24335;&#31867;&#22411;&#10;Linux&#20013;&#30340;&#19981;&#21516;&#24212;&#29992;&#31243;&#24207;&#21487;&#33021;&#20250;&#29992;&#19981;&#21516;&#31867;&#22411;&#30340;&#27491;&#21017;&#34920;&#36798;&#24335;&#65307;&#32780;&#22312;Linux&#20013;&#65292;&#26377;&#20004;&#31181;&#27969;&#34892;&#30340;&#27491;&#21017;&#34920;&#36798;&#24335;&#24341;&#25806;&#65306;&#10;&#9;&#10;&#62; POSIX&#22522;&#30784;&#27491;&#21017;&#34920;&#36798;&#24335;(basic regular expression&#65292;BRE)&#24341;&#25806;&#65292;sed&#32534;&#36753;&#22120;&#21482;&#31526;&#21512;&#20102;BRE&#24341;&#25806;&#35268;&#33539;&#30340;&#23376;&#38598;&#10;&#10;&#62; POSIX&#25193;&#23637;&#27491;&#21017;&#34920;&#36798;&#24335;(extended regular expression&#65292;ERE)&#24341;&#25806;&#65292;gawk&#31243;&#24207;&#29992;ERE&#24341;&#25806;&#26469;&#22788;&#29702;&#23427;&#30340;&#27491;&#21017;&#34920;&#36798;&#24335;&#27169;&#24335;&#12290;&#10;&#10;#### &#22788;&#29702;&#29305;&#27530;&#23383;&#31526;&#10;&#27491;&#21017;&#34920;&#36798;&#24335;&#35782;&#21035;&#30340;&#29305;&#27530;&#23383;&#31526;&#21253;&#25324;:```.*[]^$&#123;&#125;\+?|()```,&#22914;&#26524;&#35201;&#29992;&#26576;&#20010;&#29305;&#27530;&#23383;&#31526;&#20316;&#20026;&#25991;&#26412;&#23383;&#31526;&#65292;&#23601;&#24517;&#39035;&#29992;```\```&#36716;&#20041;</span><br></pre></td></tr></table></figure></p>
<h1 id="查找$或者正斜线">查找$或者正斜线</h1><p>sed -n ‘/\$/p’ data2<br>echo “3 / 2” | sed -n ‘/\//p’</p>
<h1 id="^字符会在每个由换行符决定的新数据行的行首检查模式">^字符会在每个由换行符决定的新数据行的行首检查模式</h1><p>echo “Books are great” | sed -n ‘/^Book/p’</p>
<h1 id="美元符($)定义了行尾锚点">美元符($)定义了行尾锚点</h1><p>echo “This book is good” | sed -n ‘/book$/p’</p>
<h1 id="^$组合删除所有空白行">^$组合删除所有空白行</h1><p>sed ‘/^$/d’ data5</p>
<h1 id="点号字符-用来匹配除换行符之外的任意单个字符，如果在点号字符的位置没有字符，那么模式就不成立。在正则表达式中，空格也是字符，也会被-匹配">点号字符.用来匹配除换行符之外的任意单个字符，如果在点号字符的位置没有字符，那么模式就不成立。在正则表达式中，空格也是字符，也会被.匹配</h1><p>sed -n ‘/.at/p’ data6</p>
<h1 id="[]定义字符组，字符组中必须有个字符来匹配相应的位置，例如匹配cat和hat">[]定义字符组，字符组中必须有个字符来匹配相应的位置，例如匹配cat和hat</h1><p>sed -n ‘/[ch]at/p’ data6</p>
<h1 id="使用3个字符组来涵盖3个字符位置含有大小写的情况">使用3个字符组来涵盖3个字符位置含有大小写的情况</h1><p>echo “yeS” | sed -n ‘/[Yy][Ee][Ss]/p’</p>
<h1 id="匹配了任意含有数字0、1、2或3的行">匹配了任意含有数字0、1、2或3的行</h1><p>sed -n ‘/[0123]/p’ data7</p>
<p>排除匹配</p>
<h1 id="匹配c或h之外的任何字符以及文本模式">匹配c或h之外的任何字符以及文本模式</h1><p>sed -n ‘/[^ch]at/p’ data6</p>
<p>区间匹配</p>
<h1 id="每个字符组都会匹配0~9的任意数字">每个字符组都会匹配0~9的任意数字</h1><p>sed -n ‘/^[0-9][0-9][0-9][0-9][0-9]$/p’ data8</p>
<h1 id="新的模式[c-h]at匹配了首字母在字母c和字母h之间的单词">新的模式[c-h]at匹配了首字母在字母c和字母h之间的单词</h1><p>sed -n ‘/[c-h]at/p’ data6</p>
<h1 id="该字符组允许区间a~c、h~m中的字母出现在at文本前">该字符组允许区间a~c、h~m中的字母出现在at文本前</h1><p>sed -n ‘/[a-ch-m]at/p’ data6</p>
<h1 id="特殊字符组，可以用[[:digit:]]来代替区间[0-9]">特殊字符组，可以用[[:digit:]]来代替区间[0-9]</h1><h1 id="在字符后面放置星号表明该字符必须在匹配模式的文本中出现0次或多次，例如u*表明字母u可能出现或不出现在匹配模式的文本中">在字符后面放置星号表明该字符必须在匹配模式的文本中出现0次或多次，例如u*表明字母u可能出现或不出现在匹配模式的文本中</h1><p>echo “I’m getting a color TV” | sed -n ‘/colou*r/p’</p>
<h1 id="将点号特殊字符和星号特殊字符组合起来。这个组合能够匹配任意数量的任意字符。">将点号特殊字符和星号特殊字符组合起来。这个组合能够匹配任意数量的任意字符。</h1><p>echo “bat” | sed -n ‘/b.*t/p’</p>
<h1 id="星号还能用在字符组上,例如只要a和e字符以任何组合形式出现在b和t字符之间(就算完全不出现也行)">星号还能用在字符组上,例如只要a和e字符以任何组合形式出现在b和t字符之间(就算完全不出现也行)</h1><p>echo “bat” | sed -n ‘/b[ae]*t/p’</p>
<p>扩展正则表达式：gawk程序能够识别ERE模式，但sed编辑器不能</p>
<h1 id="问号表明前面的字符可以出现0次或1次">问号表明前面的字符可以出现0次或1次</h1><p>echo “bt” | gawk ‘/be?t/{print $0}’</p>
<h1 id="加号表明前面的字符可以出现1次或多次，但必须至少出现1次">加号表明前面的字符可以出现1次或多次，但必须至少出现1次</h1><p>echo “bt” | gawk ‘/b[ae]+t/{print $0}’</p>
<h1 id="花括号{}允许你为可重复的正则表达式指定一个上限">花括号{}允许你为可重复的正则表达式指定一个上限</h1><h1 id="字符e只能出现1次，模式才能匹配">字符e只能出现1次，模式才能匹配</h1><p>echo “bet” | gawk —re-interval ‘/be{1}t/{print $0}’</p>
<h1 id="字符e可以出现1次或2次，这样模式就能匹配">字符e可以出现1次或2次，这样模式就能匹配</h1><p>echo “beet” | gawk —re-interval ‘/be{1,2}t/{print $0}’</p>
<h1 id="圆括号进行表达式分组，当你将正则表达式模式分组时，该组会被视为一个标准字符">圆括号进行表达式分组，当你将正则表达式模式分组时，该组会被视为一个标准字符</h1><h1 id="结尾的urday分组以及问号，使得模式能够匹配完整的Saturday或缩写Sat">结尾的urday分组以及问号，使得模式能够匹配完整的Saturday或缩写Sat</h1><p>echo “Sat” | gawk ‘/Sat(urday)?/{print $0}’</p>
<h1 id="模式(c|b)a(b|t)会匹配第一组中字母的任意组合以及第二组中字母的任意组合">模式(c|b)a(b|t)会匹配第一组中字母的任意组合以及第二组中字母的任意组合</h1><p>echo “bab” | gawk ‘/(c|b)a(b|t)/{print $0}’</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="title">#### 正则表达式应用</span><br><span class="line">1</span>. 验证电话号码</span><br><span class="line"><span class="number">2.</span> 解析邮件地址</span><br><span class="line">	```^<span class="comment">([a-zA-Z0-9_\-\.\+]+)</span>@<span class="comment">([a-zA-Z0-9_\-\.]+)</span>\.<span class="comment">([a-zA-Z]&#123;2,5&#125;)</span>$</span><br></pre></td></tr></table></figure>
<h4 id="Linux通配符">Linux通配符</h4><p>bash shell可以使用正则表达式中的一些元字符实现通配（Globbing）功能。通配是把一个包含通配符的非具体文件名扩展存储在计算机，服务器或者网络上的一批具体文件名的过程。（可以看出<strong>①通配主要应用匹配文件名上，而正则主要应用于字符串上；②通配符通常只能被shell自解释，正则表达式需要被正则引擎解析；③元字符不同</strong>）。最常用的通配符包括正则表达式元字符：</p>
<ul>
<li>？(匹配任意单个字符,不能匹配“/”字符)</li>
<li>*（匹配任意位的任意字符，包括空字符串，不包含对“/”字符的匹配）</li>
<li>[]（匹配一个单字符范围,如[a-z]；[0-9]；[a-zBE5-7]表示所有a到z之间的字符和 B、E、5、6、7相匹配；[!abc]匹配除了“a，b，c”这3个字符之外的任意一个字符)</li>
<li>{}</li>
<li>^(取反)，例如<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* !&#21462;&#21453;&#10;&#10;&#62; &#31034;&#20363;&#10;&#62;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><em>.txt               # 匹配全部后缀为.txt的文件<br>file?.log           # 匹配file1.log, file2.log, …<br>[a-z]</em>.log          # 匹配a-z开头的.log文件<br>[^a-z]*.log         # 上面的反向匹配<br>```</p>
<blockquote>
<p>备注：反斜杠()或引号(‘, “)都会使通配符失效，例如如: <code>\*</code>, <code>&quot;*&quot;</code>, <code>&#39;*&#39;</code>都表示<code>*</code>本身，不通配任何文件</p>
</blockquote>

        
      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="../../tags/Linux/"> #Linux </a>
          
            <a href="../../tags/shell/"> #shell </a>
          
        </div>
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="../../2017/02/19/Linux shell:目录基础知识/">
                Linux shell/目录基础知识
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2017-02-19
        </span>

        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="../../2017/02/19/Linux shell:目录基础知识/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2017/02/19/Linux shell:目录基础知识/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <h4 id="Unix/Linux/GNU_Linux">Unix/Linux/GNU Linux</h4><p>Linux本质是指 Linux 内核，而GNU/Linux则代表这是一个发行版系统(内核+GNU工具), GNU的全称又是：Gnu’s Not Unix, 本质上这些都属于类unix系统。</p>
<h4 id="bash配置文件(Linux_or_Mac)">bash配置文件(Linux or Mac)</h4><h5 id="全局配置文件">全局配置文件</h5><ol>
<li>/etc/profile 和 /rtc/profile.d/*.sh : 此文件为系统的每个用户设置环境信息,当用户第一次登录时该文件被执行，并从/etc/profile.d目录的配置文件中搜集shell的设置</li>
<li>/etc/bashrc : 为每一个运行bash shell的用户执行此文件，当bash shell被打开时,该文件被读取</li>
</ol>
<h5 id="个人配置文件">个人配置文件</h5><ol>
<li>~/.bash_profile : 每个用户都可使用该文件输入专用于自己使用的shell信息；当用户登录时,该文件仅仅执行一次；默认情况下,他设置一些环境变量,执行用户的.bashrc文件</li>
<li>~/.bashrc : 该文件包含专用于你的bash shell的bash信息,当登录时以及每次打开新的shell时,该文件被读取</li>
<li>~/.bash_history : </li>
<li>~/.bash_logout : 当每次退出系统(退出bash shell)时,执行该文件</li>
</ol>
<h5 id="shell如何读取配置文件">shell如何读取配置文件</h5><ol>
<li><p><strong>登录式shell如何读取配置文件</strong>  </p>
<pre><code><span class="comment">/etc/profile</span> <span class="literal">-</span><span class="literal">-</span>&gt; <span class="comment">/etc/profile</span><span class="string">.</span><span class="comment">d/*</span><span class="string">.</span><span class="comment">sh</span> <span class="literal">-</span><span class="literal">-</span>&gt; <span class="comment">~/</span><span class="string">.</span><span class="comment">bash_profile</span> <span class="literal">-</span><span class="literal">-</span>&gt; <span class="comment">~/</span><span class="string">.</span><span class="comment">bashrc</span> <span class="literal">-</span><span class="literal">-</span>&gt; <span class="comment">/etc/bashrc</span>
</code></pre></li>
<li><p>非登录式shell如何配置文件</p>
<pre><code>~<span class="regexp">/.bashrc --&gt; /etc</span><span class="regexp">/bashrc --&gt; /etc</span><span class="regexp">/profile.d/</span>*.sh  
</code></pre></li>
</ol>
<h5 id="配置变量和命令">配置变量和命令</h5><ol>
<li><p>$PATH : 决定了shell将到哪些目录中寻找命令或程序，PATH的值是一系列目录，当您运行一个程序时，Linux在这些目录下进行搜寻编译链接  </p>
<pre><code><span class="comment"># 设置PATH, PATH N 为自己加上指定路径，中间用冒号隔开</span>
<span class="variable">$ </span><span class="constant">PATH=</span><span class="variable">$PATH</span><span class="symbol">:PATH1</span><span class="symbol">:PATH</span> <span class="number">2</span><span class="symbol">:PATH</span> <span class="number">3</span><span class="symbol">:</span> ... <span class="symbol">:PATH</span> <span class="constant">N</span>
<span class="comment"># 打印当前搜索路径的两种方法</span>
<span class="variable">$ </span>echo <span class="variable">$PATH</span> 或者 <span class="variable">$ </span>export
<span class="comment"># 打印全局变量的两种方法，printenv HOME打印变量值</span>
<span class="variable">$ </span>env 或者printenv
<span class="comment"># 显示所有的全局变量，局部变量以及用户自定义变量</span>
<span class="variable">$set</span>
</code></pre></li>
<li><p>export : 该命令将新变量添加到环境中 ; 在命令行直接执行可以设置一个新的临时环境变量, 变量在关闭shell时失效</p>
</li>
<li>source .bash_profile : 使设置的PATH生效</li>
<li>每次重新打开终端的时候，.bashrc会自动执行一次，而.bash_profile不会</li>
</ol>
<h4 id="shell和shell脚本的概念">shell和shell脚本的概念</h4><p><strong>shell</strong>是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问操作系统内核的服务。Ken Thompson的sh是第一种Unix Shell，Windows Explorer是一个典型的图形界面Shell。</p>
<p><strong>shell脚本（shell script）</strong>，是一种为shell编写的脚本程序。业界所说的shell通常都是指shell脚本，但读者朋友要知道，shell和shell script是两个不同的概念。本文出现的“shell编程”都是指shell脚本编程，不是指开发shell自身（如Windows Explorer扩展开发）</p>
<h4 id="脚本解释器">脚本解释器</h4><p><strong>sh</strong> —- 即Bourne shell，POSIX（Portable Operating System Interface）标准的shell解释器，它的二进制文件路径通常是/bin/sh，由Bell Labs开发。</p>
<p><strong>Bash</strong> —- 是Bourne shell的替代品，属GNU Project，二进制文件路径通常是/bin/bash。</p>
<p><strong>ksh、csh、zsh等不常用的解释器</strong></p>
<h4 id="shell脚本实例">shell脚本实例</h4><pre><code><span class="shebang">#!/bin/sh</span>
<span class="built_in">cd</span> ~
ret=`mkdir shell_tut`
<span class="built_in">cd</span> shell_tut

<span class="keyword">for</span> ((i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)); <span class="keyword">do</span>
    touch <span class="built_in">test</span>_<span class="variable">$i</span>.txt
<span class="keyword">done</span>
</code></pre><ol>
<li>定义变量时，变量名不加美元符号（$）</li>
<li>变量名和等号之间不能有空格</li>
<li>单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的；单引号字串中不能出现单引号（对单引号使用转义符后也不行）</li>
<li>双引号里可以有变量，双引号里可以出现转义字符</li>
<li>以“#”开头的行就是注释，会被解释器忽略</li>
<li>bash shell提供了一个组合键来生成 EOF(End-of-File)字符。Ctrl+D组合键会在bash中产生一个EOF字符</li>
</ol>
<h4 id="运行Shell脚本的两种方法">运行Shell脚本的两种方法</h4><pre><code>chmod +x <span class="keyword">test</span>.<span class="keyword">sh</span>
./<span class="keyword">test</span>.<span class="keyword">sh</span>
或者
bin/<span class="keyword">sh</span> <span class="keyword">test</span>.<span class="keyword">sh</span>
/bin/php <span class="keyword">test</span>.php
第一种必须要带上.才能在当前目录寻找脚本，否则会去PATH寻找；第二种不需要指定#!/bin/<span class="keyword">sh</span>
</code></pre><h4 id="Shell日志分析常用命令">Shell日志分析常用命令</h4><ol>
<li><p>查看内容</p>
<pre><code>who - show who is logged <span class="command"><span class="keyword">on</span></span>

    <span class="comment"># 多个命令可以用分号隔开，同时执行</span>
    who; <span class="built_in">date</span>

    <span class="comment"># 通配符？代表一个字符，*代表多个字符</span>
    ls -alh
    ll <span class="operator">a</span>*.txt  
    ll <span class="operator">a</span>?.txt

    <span class="comment"># 符号链接(软链接):指向源文件的新的独立文件，与原文件完全不同，inode也不同</span>
    <span class="built_in">ln</span> -s <span class="operator">a</span> a_link
    <span class="comment"># 硬链接:与原文件本质上是同一个文件，大小一样</span>
    <span class="built_in">ln</span> <span class="operator">a</span> a_link
    <span class="comment"># 查看inode编号</span>
    ls -li <span class="operator">a</span>*

    <span class="comment"># 查看目录的树形结构</span>
    tree dir

    <span class="comment"># 查看文件内容，显示行数和进度; 输入v可以直接进入vim编辑模式</span>
    less -NM <span class="built_in">file</span> 

    <span class="comment"># cat新建、合并文件</span>
    cat &gt; <span class="built_in">file</span>
    cat f1 f2 &gt; f 

    <span class="comment"># 显示行数</span>
    cat -n/-b <span class="built_in">file</span>

    <span class="comment"># 使用两个 &gt; 符时, 会将第一个文件中的内容追加到第二个文件的末尾</span>
    cat /root/linux &gt;&gt; /root/desktop

    <span class="comment"># ps,top,du,df查看系统信息</span>
    lsblk -f: 可以查看未挂载的文件系统类型
    parted -l 命令会输出文件系统类型（File <span class="keyword">system</span>）， 其中参数l表示列出所有设备的分区信息
    parted /dev/sdg
    fdisk -l

    df -T 查看已经挂载的分区和文件系统类型

    killall <span class="operator">a</span>* 杀死所有以<span class="operator">a</span>开头的进程
    mount 查看系统挂载的设备列表
    umount 卸载设备

    <span class="comment"># 测试url联通性</span>
    wget -nv <span class="comment">--spider $url</span>
</code></pre></li>
<li><p>数据提取处理</p>
<pre><code># <span class="keyword">sort</span> -n可以识别每行开头的数字，并按其大小对文本行进行排序；-t设置分隔符
    # <span class="keyword">sort</span>默认是按升序排列，如果想要按降序要加-r选项(<span class="keyword">sort</span> -rn), <span class="keyword">sort</span>命令按照第<span class="number">1</span>个、第<span class="number">2</span>个、第N个字段依次排序，如果第一个字段相同，就按第<span class="number">2</span>个字段的顺序排列，直到最后。
    # 用命令cut -c <span class="number">9</span>- 取出每行第<span class="number">9</span>个及其以后的字符
    # uniq命令只能对相邻行进行去重操作,所以要先<span class="keyword">sort</span>；uniq -c显示每一行出现次数，-u只显示单独出现的行，-d只显示重复出现的行

    # 排序+去重并显示次数+按开头数字降序+取出第<span class="number">9</span>个之后的字符
    <span class="keyword">sort</span> <span class="keyword">file</span> | uniq -c | <span class="keyword">sort</span> -rn | cut -c <span class="number">9</span>- 

    # 先对第<span class="number">2</span>列<span class="keyword">sort</span>，然后对第<span class="number">3</span>列<span class="keyword">sort</span>
    <span class="keyword">sort</span> t.txt -k2,<span class="number">2</span>n -k3,<span class="number">3</span>n

    # <span class="keyword">grep</span>或操作
    <span class="keyword">grep</span> <span class="string">'word1\|word2'</span>
    <span class="keyword">grep</span> -E <span class="string">'word1|word2'</span>
    # 非操作
    <span class="keyword">grep</span> -v <span class="string">'word1\|word2'</span>
    # <span class="keyword">grep</span>正则匹配
    <span class="keyword">grep</span> -o regex FILENAME  正则匹配
    # 例如匹配vip=ip地址形式文本
    <span class="keyword">grep</span> -o <span class="string">'vip=[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}'</span>

    <span class="keyword">grep</span> -n pattern <span class="keyword">file</span> 显示行号
    <span class="keyword">grep</span> -c pattern <span class="keyword">file</span> 显示匹配到的行数

    # 压缩文件相关的搜索
    zgrep <span class="string">"/api"</span> access_log.gz access_log_1.gz

    zcat access.tar.gz | <span class="keyword">grep</span> -a <span class="string">'/api'</span>
    zgrep -a <span class="string">"/api"</span> access.tar.gz

    zcat  解压文件并将内容输出到标准输出
    zcmp  解压文件并且 <span class="keyword">byte</span> by <span class="keyword">byte</span> 比较两个文件
    zdiff 解压文件并且 line by line 比较两个文件
    zgrep 解压文件并且根据正则搜索文件内容
</code></pre></li>
</ol>
<pre><code><span class="comment"># 根据进程路径查找pid并kill</span>
<span class="built_in">kill</span> `ps -ef | grep bos/nginx | grep master | awk <span class="string">'{print $2}'</span>` 

<span class="comment"># 去除每一行中的重复空格，输出 'a b c'</span>
<span class="built_in">echo</span> <span class="string">'a     b c'</span> | tr <span class="operator">-s</span> <span class="string">' '</span>

<span class="comment"># 数学表达式,例如计算10*10的结果, 只支持整数运算</span>
<span class="built_in">echo</span> $[<span class="number">10</span>*<span class="number">10</span>]

expr <span class="number">5</span> / <span class="number">2</span>  不支持浮点数计算
<span class="built_in">echo</span> <span class="string">'scale=3;5/2'</span> | bc

<span class="comment"># bc进入计算器模式，可以进行浮点数运算，scale=4代表保留4位小数，quit退出</span>
</code></pre><ol>
<li><p><strong>cut</strong>：按行剪切数据，cut命令主要是接受三个定位方法: ①字节（bytes），用选项-b，例如; ②字符（characters），用选项-c; ③域（fields），用选项-f; -n选项，-n用于告诉cut不要将多字节字符拆开</p>
<pre><code># 提取每一行的第3个字节,-3表示从第一个字节到第三个字节，而3-表示从第三个字节到行尾
<span class="keyword">cat</span> <span class="keyword">file</span> | cut -b 3
# 提取每一行的第3,4,5,8个字节,执行此命令时，cut会先把-b后面所有的定位进行从小到大排序
<span class="keyword">cat</span> <span class="keyword">file</span> | cut -b 3-5,8

# -<span class="keyword">d</span>来设置间隔符为空格，然后用-f来设置我要取的是第一个域(用awk也可以取出指定列)
<span class="keyword">cat</span> <span class="keyword">file</span> | cut -<span class="keyword">d</span> ' ' -f 1

# cut的-<span class="keyword">d</span>选项的默认间隔符就是制表符，当要使用制表符的时候，可以省略-<span class="keyword">d</span>选项，直接用－f来取域;cut -<span class="keyword">d</span>只允许间隔符是一个字符。
</code></pre></li>
<li><p><strong>sed</strong>：一种流编辑器，会在编辑器处理数据之前基于预先提供的一组规则来编辑数据流。sed按行处理文本，默认从STDIN读取文本并将处理结果输出到STDOUT，不改变输入文本内容。</p>
<pre><code><span class="preprocessor"># 显示空格和制表符的区别，-n选项是禁止编辑器输出,l是将特殊符以直观形式输出</span>
sed -n l file

<span class="preprocessor"># sed 替换字符串，把文本中第一个dog替换成big cat</span>
echo <span class="string">"This is a dog"</span> | sed <span class="string">'s/dog/big cat/'</span>

<span class="preprocessor"># 删除前N个字符  </span>
sed -i <span class="string">'s/^..//'</span> file   (N个.表示N个字符)

<span class="preprocessor"># substitute替换，通用格式：s/pattern/replace/flags, 选项可以是g,p,w,数字</span>
sed <span class="string">'s/dog/big cat/g'</span> data.txt
<span class="preprocessor"># -n + p 等价于w选项，只输出被替换命令修改过的行</span>

<span class="preprocessor"># 包含特殊字符/的字符串替换，可使用\转义或者指定分隔符！</span>
sed <span class="string">'s!/bin/bash!/bin/csh!'</span> /etc/passwd
sed <span class="string">'s/\/bin\/bash/\/bin\/csh/'</span> /etc/passwd

<span class="preprocessor"># -e执行多条命令到每行数据上</span>
sed -e <span class="string">'s/brown/green/; s/dog/cat/'</span> data1.txt

<span class="preprocessor"># -f选项读取script1.sed文件中所有sed命令并执行，每行都是一条单独的命令</span>
sed -f script1.sed data1.txt

<span class="preprocessor"># sed行寻址，也就是讲命令只作用于特定行or某些行</span>
sed <span class="string">'2s/dog/cat/'</span> data1.txt
sed <span class="string">'2,3s/dog/cat/'</span> data1.txt 
<span class="preprocessor"># 只作用于第2行到最后一行</span>
sed <span class="string">'2,$s/dog/cat/'</span> data1.txt 

<span class="preprocessor"># 只作用于包含Samantha的行</span>
sed <span class="string">'/Samantha/s/bash/csh/'</span> /etc/passwd

<span class="preprocessor"># sed删除行</span>
sed <span class="string">'2,3d'</span> data1.txt 
<span class="preprocessor"># 只作用于第2行到最后一行</span>
sed <span class="string">'2,$d'</span> data1.txt 

<span class="preprocessor"># 只作用于包含Samantha的行</span>
sed <span class="string">'/Samantha/d'</span> /etc/passwd

<span class="preprocessor"># 插入行, 最后一行之后插入</span>
sed <span class="string">'$a\This is a new line of text.'</span> data1.txt
<span class="preprocessor"># 第三行之前插入</span>
sed <span class="string">'3i\This is a new line of text.'</span> data1.txt

<span class="preprocessor"># 修改包含'number 3'内容的行</span>
sed <span class="string">'/number 3/c\
&gt; This is a changed line of text.'</span> data6.txt

<span class="preprocessor"># 修改第3行</span>
sed <span class="string">'3c\
&gt; This is a changed line of text.'</span> data6.txt

<span class="preprocessor"># sed transform转换命令会对inchars和outchars值进行一对一的映射</span>
$ echo <span class="string">"This 1 is a test of 1 try."</span> | sed <span class="string">'y/123/456/'</span> 
This <span class="number">4</span> is a test of <span class="number">4</span> <span class="keyword">try</span>.

<span class="preprocessor"># 禁止输出其他行，只打印包含匹配文本模式的行</span>
sed -n <span class="string">'/number 3/p'</span> data6.txt
<span class="preprocessor"># 非操作!</span>
sed -n <span class="string">'/number 3/!p'</span> data6.txt

提取内容并写入文件
<span class="preprocessor"># 将data6.txt数据流中的前两行打印到一个文本文件test.txt中</span>
sed <span class="string">'1,2w test.txt'</span> data6.txt

<span class="preprocessor"># 只将包含文本模式的数据行写入目标文件Browncoats.txt</span>
sed -n <span class="string">'/Browncoat/w Browncoats.txt'</span> data11.txt

从文件读数据
<span class="preprocessor"># 读取data12.txt所有内容，并写入data6.txt文件第三行之后</span>
sed <span class="string">'3r data12.txt'</span> data6.txt
<span class="preprocessor"># 写入包含number 2的一行之后并删除number 2行</span>
sed <span class="string">'/number 2/r data12.txt'</span> data6.txt
sed <span class="string">'$r data12.txt d'</span> data6.txt

<span class="preprocessor"># sed多行命令</span>
<span class="preprocessor"># next，n命令会让sed编辑器移动到文本的下一行</span>
<span class="preprocessor"># N命令将下一行合并到当前行</span>
sed <span class="string">'/first/{ N ; s/\n/ / }'</span> data2.txt
<span class="preprocessor"># 合并行号和行内容</span>
sed <span class="string">'='</span> data2.txt | sed <span class="string">'N; s/\n/ /'</span>

<span class="preprocessor"># 向文本文件的行间插入空白行</span>
sed <span class="string">'G'</span> data2.txt
<span class="preprocessor"># 删除连续的空白行，保留单个空白行</span>
sed <span class="string">'/./,/^$/!d'</span> data8.txt
<span class="preprocessor"># 用排除符号(!)和尾行符号($)来确保脚本不会将空白行加到数据流的最后一行后面</span>
sed <span class="string">'$!G'</span> data2.txt
</code></pre></li>
<li><p><strong>awk</strong>: gawk程序是Unix中的原始awk程序的GNU版本。gawk程序让流编辑迈上了一个新的台阶，它提供了一种编程语言而不只是编辑器命令。awk是一种文本处理和模式匹配语言，数据驱动的语言。gawk程序脚本用一对花括号来定义，你必须将脚本命令放到两个花括号{}中</p>
<pre><code># 强制awk在读取数据前执行BEGIN关键字后指定的程序脚本；END关键字允许你指定一个程序脚本，awk会在读完数据后执行它
awk 'BEGIN {<span class="keyword">print</span> <span class="string">"Hello World!"</span>}'
# awk默认以任意的空白字符(例如空格或制表符)分割每一行，也可以用-F指定分隔符(也可以定义FS的特殊变量来指定字段分隔符)，<span class="label">$0</span>代表整行，<span class="label">$n</span>代表第<span class="keyword">n</span>列内容
# 打印<span class="keyword">file</span>的第五列
<span class="keyword">cat</span> <span class="keyword">file</span> | awk '{<span class="keyword">print</span> <span class="label">$5}</span>'
awk -F: '{<span class="keyword">print</span> <span class="label">$1}</span>' <span class="keyword">file</span>

# 通过设置OFS变量，可以在输出中使用任意字符串来分隔字段
# 以,为分隔符，读取1-3列，然后以-连接，输出；相当于替换分隔符
awk 'BEGIN{FS=<span class="string">","</span>; OFS=<span class="string">"-"</span>} {<span class="keyword">print</span> <span class="label">$1</span>,<span class="label">$2</span>,<span class="label">$3}</span>' data1

# 记录分隔符设置，例如把文件中的每行都当成一个字段，把空白行当作记录分隔符，可以起到合并多行成1行的效果
awk 'BEGIN{FS=<span class="string">"\n"</span>; RS=<span class="string">""</span>} {<span class="keyword">print</span> <span class="label">$1</span>,<span class="label">$4}</span>' data2

# awk自带的ARGC，ARGV，NF，FNR等数据变量

# awk自定义变量，进行计算
awk 'BEGIN{x=4; x= x * 2 + 13 % 2 + 3^2; <span class="keyword">print</span> x}'

# awk 遍历数组变量
gawk 'BEGIN{
&gt; <span class="keyword">var</span>[<span class="string">"a"</span>] = 1
&gt; <span class="keyword">var</span>[<span class="string">"g"</span>] = 2
&gt; <span class="keyword">for</span> (<span class="keyword">test</span> <span class="keyword">in</span> <span class="keyword">var</span>) &gt;{
&gt; <span class="keyword">print</span> <span class="string">"Index:"</span>,<span class="keyword">test</span>,<span class="string">" - Value:"</span>,<span class="keyword">var</span>[<span class="keyword">test</span>] &gt;}'

# awk 匹配操作符/……/，例如筛选出包含11的行做对应处理，用逗号做分隔符
gawk 'BEGIN{FS=<span class="string">","</span>} /11/{<span class="keyword">print</span> <span class="label">$1}</span>' data1

# 在每行第一个数据字段中查找以文本rich开头的行，打印第一个和最后一个字段
awk -F: '<span class="label">$1</span> ~ /^rich/{<span class="keyword">print</span> <span class="label">$1</span>,<span class="label">$NF}</span>' /etc/passwd
# 非操作!
gawk –F: '<span class="label">$1</span> !~ /^rich/{<span class="keyword">print</span> <span class="label">$1</span>,<span class="label">$NF}</span>' /etc/passwd
# 数学表达式，==，&lt;=……
gawk -F, '<span class="label">$1</span> == <span class="string">"data"</span>{<span class="keyword">print</span> <span class="label">$1}</span>' data1

# awk使用<span class="keyword">if</span> <span class="keyword">else</span>，<span class="keyword">while</span>，<span class="keyword">for</span>等结构化语句
awk '{<span class="keyword">if</span> (<span class="label">$1</span> &gt; 20) <span class="keyword">print</span> <span class="label">$1</span> * 2; <span class="keyword">else</span> <span class="keyword">print</span> <span class="label">$1</span> / 2}' data4

# printf格式化输出，例如用几个单独的printf命令在同一行上打印多个输出
gawk 'BEGIN{FS=<span class="string">","</span>} {printf <span class="string">"%s "</span>, <span class="label">$1}</span> END{printf <span class="string">"\n"</span>}' data1

# rand()产生随机数只在0和1之间(不包括0或1)，int会生成该值和0之间最接近该值的整数
x = int(10 * rand())

# 字符串函数，时间函数，自定义函数
# 在定义函数时，它必须出现在所有代码块之前(包括BEGIN代码块)，例如
awk '
&gt; function myprint() 
&gt; {
&gt; printf <span class="string">"%-16s - %s\n"</span>, <span class="label">$1</span>, <span class="label">$4</span>
&gt; }
&gt; BEGIN{FS=<span class="string">"\n"</span>; RS=<span class="string">""</span>}
&gt; {
&gt; myprint()
&gt; }' data2

# 也可以把函数定义到文件中，然后用-f引用函数

# 求<span class="keyword">sum</span>和average，使用awk变量时不需要带$
<span class="keyword">cat</span> <span class="keyword">file</span> | awk '{<span class="keyword">sum</span>+=<span class="label">$1}</span> END {<span class="keyword">print</span> <span class="string">"Sum = "</span>, <span class="keyword">sum</span>}'
<span class="keyword">cat</span> <span class="keyword">file</span> | awk '{<span class="keyword">sum</span>+=<span class="label">$1}</span> END {<span class="keyword">print</span> <span class="string">"Average = "</span>, <span class="keyword">sum</span>/NR}'

# a.txt中每一行为一个单词，按行读取a.txt, <span class="label">$1</span>代表第一列，统计出出现次数前3名的单词
# <span class="keyword">sort</span> -<span class="keyword">n</span> -r -k 2 -t ':' xx.txt -<span class="keyword">n</span>数字排序方式， -r倒序, -t ':'以冒号分隔, -k 2表示以冒号分隔后的第2列
awk '{<span class="keyword">sum</span>[<span class="label">$1</span>]+=1} END {<span class="keyword">for</span>(k <span class="keyword">in</span> <span class="keyword">sum</span>) <span class="keyword">print</span> k <span class="string">":"</span> <span class="keyword">sum</span>[k]}' a.txt | <span class="keyword">sort</span> -<span class="keyword">n</span> -r -k 2 -t ':' | head -<span class="keyword">n</span> 3
</code></pre></li>
<li><p>权限相关(Linux文件权限以八进制表示)</p>
<pre><code><span class="literal">umask</span> 设置文件(<span class="number">666</span>-x)<span class="keyword">or</span>目录(<span class="number">777</span>-x)默认权限的掩码

权限的八进制表示：wr- --&gt; <span class="number">110</span> --&gt; <span class="number">6</span>

<span class="comment"># 八进制修改权限</span>
chmod -<span class="constant">R</span> <span class="number">777</span> dir
chmod <span class="number">777</span> <span class="keyword">file</span>

<span class="comment">#符号模式修改权限</span>
chmod u+w <span class="keyword">file</span>   给文件<span class="keyword">user</span>增加write权限

<span class="comment"># 改变文件的属主和属组；只有root可以改变文件属主，任何属主可以改变属组</span>
chown <span class="keyword">user</span>.<span class="literal">group</span> <span class="keyword">file</span>
</code></pre></li>
<li><p>处理脚本控制信号和特殊参数  </p>
<blockquote>
<p>默认情况下，脚本以最后一个命令的退出状态码退出；当然也可以通过<figure class="highlight"><figcaption><span>0```来指定退出状态码，范围为0-255，如果大于255，则以num % 256返回给用户</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#9;&#10;&#9;&#9;# &#36755;&#20986;&#19978;&#19968;&#21629;&#20196;&#30340;&#36864;&#20986;&#30721;&#10;&#9;&#9;echo $? &#10;&#9;&#9;&#10;&#9;&#9;# shell&#30340;&#20301;&#32622;&#21442;&#25968;&#21464;&#37327;&#26159;&#26631;&#20934;&#30340;&#25968;&#23383;:$0&#26159;&#31243;&#24207;&#21517;&#65292;$1&#26159;&#31532;&#19968;&#20010;&#21442;&#25968;&#65292;$2&#26159;&#31532;&#20108;&#20010;&#21442;&#25968;&#65292;&#20381;&#27425;&#31867;&#25512;&#65292;&#30452;&#21040;&#31532;&#20061;&#20010;&#21442;&#25968;$9&#10;&#9;&#9;# $0&#21442;&#25968;&#33719;&#21462;shell&#22312;&#21629;&#20196;&#34892;&#21551;&#21160;&#30340;&#33050;&#26412;&#21517;&#10;&#9;&#9;echo $0&#10;&#9;&#9;&#10;&#9;&#9;# basename&#33719;&#21462;&#32477;&#23545;&#36335;&#24452;&#19979;&#30340;&#25991;&#20214;&#21517;or&#25991;&#20214;&#22841;&#21517;&#10;&#9;&#9;echo $(basename $0)&#10;&#9;&#9;&#10;&#9;&#9;# &#23450;&#26102;&#20219;&#21153;&#10;&#9;&#9;cron,crontab,anacron&#21644;at&#10;&#9;&#9;# &#36827;&#31243;&#20248;&#20808;&#32423;&#35843;&#24230;&#10;&#9;&#9;nice&#21644;renice&#10;&#9;&#9;# &#21518;&#21488;&#21069;&#21488;&#20219;&#21153;&#65306;jobs -l&#65292;bg,fg,&#38;,nohup&#10;&#10;#### Linux/Mac&#24120;&#35265;&#30446;&#24405;&#10;1. /bin &#23384;&#25918;&#31995;&#32479;&#31649;&#29702;&#21592;&#21644;&#26222;&#36890;&#29992;&#25143;&#37117;&#35201;&#20351;&#29992;&#30340;&#31243;&#24207;&#10;2. /sbin &#23384;&#25918;&#29992;&#20110;&#31995;&#32479;&#24674;&#22797;&#65292;&#31995;&#32479;&#21551;&#21160;&#65292;&#31995;&#32479;&#32500;&#25252;&#31561;&#31243;&#24207;&#10;3. /usr/bin &#30331;&#24405;&#29992;&#25143;&#21487;&#20197;&#20351;&#29992;&#30340;&#39044;&#35013;&#31243;&#24207;&#19968;&#33324;&#37117;&#25918;&#22312;&#36825;&#37324;,&#20250;&#38543;&#30528;&#31995;&#32479;&#21319;&#32423;&#32780;&#25913;&#21464;&#10;4. /usr/share/bin &#21487;&#20197;&#36890;&#36807;web&#35775;&#38382;&#30340;&#31243;&#24207;&#19968;&#33324;&#25918;&#22312;&#36825;&#37324;&#10;5. /usr/local/bin &#30446;&#24405;&#26159;&#32473;&#29992;&#25143;&#25918;&#32622;&#33258;&#24049;&#30340;&#21487;&#25191;&#34892;&#31243;&#24207;&#30340;&#22320;&#26041;&#65292;&#26159;&#25163;&#21160;&#32534;&#35793;&#25110;&#32773;&#23433;&#35013;&#30340;&#31243;&#24207;, &#19981;&#20250;&#34987;&#31995;&#32479;&#21319;&#32423;&#32780;&#35206;&#30422;&#21516;&#21517;&#25991;&#20214;&#10;6. usr &#25351; Unix System Resource&#65292;&#32780;&#19981;&#26159;User&#10;7. /lib&#30446;&#24405;&#37117;&#26159;&#20026;/bin, /sbin&#20934;&#22791;&#30340;;&#19968;&#20010;&#24212;&#29992;&#31243;&#24207;&#21551;&#21160;&#30340;&#26102;&#20505;&#65292;&#20250;&#22312;/lib &#21644; /usr/lib&#24211;&#20013;&#26597;&#25214;&#21160;&#24577;&#24211;&#10;&#10;#### Linux&#26816;&#27979;&#31243;&#24207;&#10;&#10;#### Linux&#30913;&#30424;&#25346;&#36733;/&#21368;&#36733;/&#26684;&#24335;&#21270;&#25805;&#20316;&#10;linux&#31995;&#32479;&#20013;&#21482;&#33021;&#22312;root&#26435;&#38480;&#29992;&#25143;&#19979;&#25346;&#36733;&#35774;&#22791;&#12290;&#10;##### BIOS vs UEFI&#10;BIOS&#65288;Basic Input/Output System&#65289;&#21644; UEFI&#65288;Unified Extensible Firmware Interface &#65289;&#26159;&#19981;&#21516;&#30340;&#35745;&#31639;&#26426;&#21551;&#21160;&#22266;&#20214;&#65288;Fireware&#65289;&#65292;&#38656;&#35201;&#30828;&#20214;&#65288;&#36890;&#24120;&#20026;&#20027;&#26495;&#65289;&#25903;&#25345;&#65292;&#30456;&#20114;&#20195;&#26367;&#65292;&#20854;&#20013; UEFI &#26159;&#27604;&#36739;&#26032;&#30340;&#26041;&#24335;&#12290;&#10;&#10;* BIOS&#65306;&#32463;&#20856;&#30340;&#21551;&#21160;&#22266;&#20214;&#65292;&#20250;&#35843;&#29992;&#30913;&#30424;&#30340; MBR&#65292;&#28982;&#21518;&#30001; MBR &#20013;&#30340; loader &#32487;&#32493;&#21152;&#36733;&#25805;&#20316;&#31995;&#32479;&#12290;&#10;* UEFI&#65306;UEFI &#29992;&#26469;&#20195;&#26367; BIOS&#65292;&#24182;&#20811;&#26381; BIOS &#30340;&#32570;&#28857;&#65292;&#22823;&#22810;&#25968;&#30340; UEFI &#22266;&#20214;&#20250;&#25552;&#20379;&#20860;&#23481; BIOS &#30340;&#21551;&#21160;&#26041;&#24335;&#12290;&#10;&#10;##### MBR vs GPT&#10;* MBR &#19982; GPT &#29992;&#20110;&#23384;&#20648;&#30828;&#30424;&#30340;&#20998;&#21306;&#20449;&#24687;&#65292;&#26159;&#19981;&#21516;&#30340;&#30828;&#30424;&#20998;&#21306;&#34920;&#31867;&#22411;&#12290;MBR&#25903;&#25345;&#26368;&#22823;&#32422;2T&#30340;&#30828;&#30424;&#65292;&#26368;&#22810;&#33021;&#21010;&#20998;4&#20010;&#20027;&#20998;&#21306;&#65292;&#26356;&#22810;&#20998;&#21306;&#38656;&#35201;&#20351;&#29992;&#25299;&#23637;&#20998;&#21306;&#23454;&#29616;&#12290;&#10;* GPT &#34920;&#31034; GUID&#65288;Globally Unique Identifier&#65289; &#20998;&#21306;&#34920;&#65292;&#26159; UEFI &#35268;&#33539;&#30340;&#19968;&#37096;&#20998;&#65292;&#29992;&#20110;&#26367;&#25442; MBR &#30340;&#20998;&#21306;&#26041;&#24335;&#12290;GPT &#27809;&#26377;&#20998;&#21306;&#25968;&#21644;&#20998;&#21306;&#22823;&#23567;&#38480;&#21046;&#12290;&#10;* BIOS/UEFI &#36319; MBR/GPT &#26159;&#19981;&#21516;&#23618;&#32423;&#30340;&#65292;BIOS/UEFI &#26159; Fireware&#65292;MBR/GPT &#26159;&#20998;&#21306;&#34920;&#12290;&#10;&#10;##### File System&#65288;&#25991;&#20214;&#31995;&#32479;&#65289;&#26159;&#23384;&#20648;&#23186;&#20171;&#20013;&#25991;&#20214;&#23384;&#20648;&#30340;&#32452;&#32455;&#26041;&#24335;&#12290;&#10;&#19981;&#21516;&#30340;&#25991;&#20214;&#31995;&#32479;&#31867;&#22411;&#26377;&#19981;&#21516;&#30340;&#36895;&#24230;&#65292;&#28789;&#27963;&#24615;&#65292;&#23433;&#20840;&#24615;&#21644;&#21344;&#29992;&#31354;&#38388;&#12290;&#19981;&#21516;&#25805;&#20316;&#31995;&#32479;&#21482;&#25903;&#25345;&#29305;&#23450;&#30340;&#25991;&#20214;&#31995;&#32479;&#31867;&#22411;&#12290;&#24120;&#35265;&#30340;&#25991;&#20214;&#31995;&#32479;&#31867;&#22411;&#26377; FAT16&#65292;FAT32&#65292;NTFS&#65292;EXT3&#65292;EXT4&#65292;HFS &#31561;&#12290;&#10;&#10;* **&#30913;&#30424;&#25991;&#20214;&#31995;&#32479;**&#21253;&#25324;&#30828;&#30424;&#12289;U&#30424;&#12289;&#30913;&#30424;&#38453;&#21015;&#12289;CDROM&#12289;DVD&#31561;&#12290;&#24120;&#35265;&#25991;&#20214;&#31995;&#32479;&#26377;autofs&#12289;coda&#12289;Ext2&#12289;Ext3&#12289;Ext4&#12289;VFAT&#12289;ISO9660&#65288;&#20809;&#30424;&#25110;&#32773;&#20809;&#30424;&#38236;&#20687;&#65289;&#12289;UFS&#65288;Unix File System&#65292;Unix&#25991;&#20214;&#31995;&#32479;&#65289;&#12289;FAT&#65288;File Allocation Table&#65292;&#25991;&#20214;&#20998;&#37197;&#34920;&#65289;&#12289;FAT16&#12289;FAT32&#12289;NTFS&#65288;New TechnologyFile System&#65289;&#31561;&#12290;&#10;* **&#32593;&#32476;&#25991;&#20214;&#31995;&#32479;**&#21487;&#20197;&#36828;&#31243;&#35775;&#38382;&#30340;&#25991;&#20214;&#31995;&#32479;&#65292;&#36825;&#31181;&#25991;&#20214;&#31995;&#32479;&#22312;&#26381;&#21153;&#22120;&#31471;&#20173;&#26159;&#26412;&#22320;&#30340;&#30913;&#30424;&#25991;&#20214;&#31995;&#32479;&#65292;&#23458;&#25143;&#26426;&#36890;&#36807;&#32593;&#32476;&#36828;&#31243;&#35775;&#38382;&#25968;&#25454;&#12290;&#24120;&#35265;&#25991;&#20214;&#31995;&#32479;&#26684;&#24335;&#26377;&#65306;NFS&#65288;Network File System&#65292;&#32593;&#32476;&#25991;&#20214;&#31995;&#32479;&#65289;&#12289;Samba&#65288;SMB/CIFS&#65289;&#12289;AFP&#65288;Apple FillingProtocol&#65292;Apple&#25991;&#20214;&#24402;&#26723;&#21327;&#35758;&#65289;&#21644;WebDAV&#31561;&#12290;&#10;* **&#19987;&#26377;/&#34394;&#25311;&#25991;&#20214;&#31995;&#32479;**&#19981;&#39547;&#30041;&#22312;&#30913;&#30424;&#19978;&#30340;&#25991;&#20214;&#31995;&#32479;&#12290;&#24120;&#35265;&#26684;&#24335;&#26377;&#65306;TMPFS&#65288;&#20020;&#26102;&#25991;&#20214;&#31995;&#32479;&#65289;&#12289;PROCFS&#65288;Process FileSystem&#65292;&#36827;&#31243;&#25991;&#20214;&#31995;&#32479;&#65289;&#21644;LOOPBACKFS&#65288;Loopback File System&#65292;&#22238;&#36865;&#25991;&#20214;&#31995;&#32479;&#65289;&#12290;&#10;&#10;##### GRUB&#65288;Grand Unified Boot loader&#65289;&#10;GRUB&#26159;&#30828;&#30424;&#20013;&#30340;&#36719;&#20214;&#65292;&#24341;&#23548;&#22120;&#65288;loader&#65289;&#30340;&#19968;&#31181;&#12290;&#30446;&#21069;&#20027;&#27969;&#29256;&#26412;&#26159; GRUB2&#65292;GRUB &#29992;&#20110;&#20174;&#22810;&#25805;&#20316;&#31995;&#32479;&#30340;&#35745;&#31639;&#26426;&#20013;&#36873;&#25321;&#19968;&#20010;&#31995;&#32479;&#26469;&#21551;&#21160;&#65292;&#25110;&#20174;&#31995;&#32479;&#20998;&#21306;&#20013;&#36873;&#25321;&#29305;&#27530;&#30340;&#20869;&#26680;&#37197;&#32622;&#12290;&#10;&#10;#### [Linux&#24120;&#29992;&#30340;&#26597;&#25214;&#21629;&#20196;](http://www.ruanyifeng.com/blog/2009/10/5_ways_to_search_for_files_using_the_terminal.html)&#10;find/locate, whereis/which/ps -ef, grep&#10;&#10;* find&#25991;&#20214;&#26597;&#25214;&#65306;`find path_name -name file_name -exec rm -f &#123;&#125; \;`&#10;&#10;  `find /&#160;&#65293;name &#39;*abvd*&#39;`  &#26597;&#25214;&#21253;&#21547;abvd&#23383;&#31526;&#20018;&#30340;&#25991;&#20214;&#21517;&#25991;&#20214;&#10;&#10;* grep&#25628;&#32034;&#30446;&#24405;&#21644;&#23376;&#30446;&#24405;&#65306; `grep -R &#39;&#25991;&#26412;&#39; ./*`&#10;&#10;* whereis&#23450;&#20301;&#21487;&#25191;&#34892;&#25991;&#20214;&#20301;&#32622;&#10;&#10;#### Linux&#23567;&#25216;&#24039;&#10;1. &#29983;&#25104;&#38543;&#26426;&#23494;&#30721;&#30340;&#20004;&#31181;&#26041;&#24335;&#65306;&#9312; `date | md5 | cut -b -8` &#9313; `openssl rand -base64 8`&#10;2. **&#38543;&#26426;&#29983;&#25104;10&#20010;8&#20301;&#23494;&#30721;shell&#33050;&#26412;**: &#39318;&#20301;&#22823;&#20889;&#23383;&#27597;, &#20013;&#38388;&#20845;&#20301;&#22823;&#23567;&#20889;&#23383;&#27597;&#25968;&#23383;&#38543;&#26426;&#28151;&#21512;, &#31532;&#20843;&#20301;[0-9]</span><br></pre></td></tr></table></figure></p>
</blockquote>
</li>
</ol>
<h1 id="!/bin-bash">!/bin.bash</h1><p>for i in {1..10}<br>do<br>A=<code>head -c 500 /dev/urandom | tr -dc A-Z |head -c 1</code></p>
<h1 id="随机生成500字符|只取大写字母|取第一个字符">随机生成500字符|只取大写字母|取第一个字符</h1><p>B=<code>head -c 500 /dev/urandom | tr -dc [:alnum:]| head -c 6</code></p>
<h1 id="随机生成500字符|取英文大小写字节及数字，亦即_0-9,_A-Z,_a-z|取6位">随机生成500字符|取英文大小写字节及数字，亦即 0-9, A-Z, a-z|取6位</h1><p>C=<code>echo $RANDOM$RANDOM|cut -c 2</code></p>
<h1 id="取第二位随机数字,第一位随机性不高大多数是1或2,所以取第二位-">取第二位随机数字,第一位随机性不高大多数是1或2,所以取第二位.</h1><p>echo $A$B$C<br>done<br>```</p>
<ol>
<li><code>source /path/to/filename</code> 在当前 shell 里执行一个文件里的命令</li>
<li><code>wget -r --no-parent --reject &quot;index.html*&quot; http://hostname/ -P /home/user/dirs</code> 用 wget 抓取完整的网站目录结构，存放到本地目录中</li>
<li>diff和cmp命令，分别比对两个file的逐行和逐字节</li>
<li><a href="https://cnbin.github.io/blog/2015/06/15/shell-qian-hou-tai-jin-cheng-qie-huan/" target="_blank" rel="external">Shell 前后台进程切换</a></li>
<li><code>dd if=/dev/zero of=obj_900k bs=1024 count=0 seek=$[9*1024/10]</code> 生成900k的文件</li>
<li><code>mv /usr/cbu/ * .</code>  将/usr/cbu中的所有文件移到当前目录（用“.”表示）中</li>
<li><code>at －f data 15:30 +2 days</code>  让系统在两天后的17：30执行文件data中指明的作业</li>
</ol>

        
      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="../../tags/Linux/"> #Linux </a>
          
            <a href="../../tags/shell/"> #shell </a>
          
        </div>
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="../../2017/02/19/Linux expect自动交互脚本入门/">
                Linux expect自动交互脚本入门
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2017-02-19
        </span>

        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="../../2017/02/19/Linux expect自动交互脚本入门/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2017/02/19/Linux expect自动交互脚本入门/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <p><strong>Expect</strong> is a program that “talks” to other interactive programs according to a script. Following the script, Expect knows what can be expected from a program and what the correct response should be. An interpreted language provides branching and high-level control structures to direct the dialogue. In addition, the user can take control and interact directly when desired, afterward returning control to the script.</p>
<h4 id="expect基础语法">expect基础语法</h4><p>示例：</p>
<figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 命令行参数 </span></span><br><span class="line"><span class="comment"># $argv，参数数组，使用[lindex $argv n]获取，$argv 0初始化为脚本名字</span></span><br><span class="line"><span class="comment"># $argc，参数个数</span></span><br><span class="line"><span class="keyword">set</span> username [<span class="keyword">lindex</span> <span class="variable">$argv</span> <span class="number">0</span>]  # 获取第<span class="number">0</span>个参数</span><br><span class="line"><span class="keyword">set</span> passwd [<span class="keyword">lindex</span> <span class="variable">$argv</span> <span class="number">1</span>]    # 获取第<span class="number">1</span>个参数</span><br><span class="line"><span class="keyword">set</span> TOKEN <span class="variable">$expect_out(buffer)</span>: 获取上一个键盘输入保存到TOKEN变量中</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> timeout <span class="number">30</span> # 设置超时<span class="number">30</span>s</span><br><span class="line"> </span><br><span class="line"><span class="comment"># spawn是expect内部命令，开启ssh连接</span></span><br><span class="line">spawn ssh -l username <span class="number">192.168</span>.1.1</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 判断上次输出结果里是否包含以“password:”开头的字符串，如果有则立即返回，否则就等待一段时间(timeout)后返回</span></span><br><span class="line">expect <span class="string">"password:*"</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 发送内容ispass(密码)，与手工输入密码ispass的动作等效</span></span><br><span class="line">send <span class="string">"ispass\r"</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 发送内容给用户</span></span><br><span class="line">send_user <span class="string">"$argv0 [lrange $argv 0 2]\n"</span></span><br><span class="line">send_user <span class="string">"It's OK\r"</span></span><br><span class="line"><span class="comment"># 执行完成后保持交互状态，控制权交给控制台(可以继续手工输入等操作)。否则会完成后会退出。</span></span><br><span class="line">interact</span><br></pre></td></tr></table></figure>
<h5 id="spwan命令">spwan命令</h5><p>spawn命令用于启动一个进程, 后边接上你要执行的命令，例如<code>spawn ssh relay01.baidu.com</code></p>
<h5 id="interact命令">interact命令</h5><p>interact命令用于脚本执行完简单的命令后人手动介入,只在所属的spawn进程空间有效</p>
<h5 id="expect的三种使用格式">expect的三种使用格式</h5><ul>
<li><p>并行：只要其中的任何一个pattern能够匹配，那么这个expect就算是完成了一次匹配</p>
<pre><code>expect {
    pattern1 {
        command2 }
    pattern2 {
        command2 }
}

<span class="comment"># 示例</span>
expect {
   <span class="string">"hi"</span>    { <span class="built_in">send</span> <span class="string">"You said hi\r"</span> }
   <span class="string">"hello"</span> { <span class="built_in">send</span> <span class="string">"Hello yourself\r"</span> }
   <span class="string">"bye"</span>   { <span class="built_in">send</span> <span class="string">"That was unexpected\r"</span> }
}
</code></pre></li>
</ul>
<ul>
<li><p>串行：所有的匹配被依次满足了之后才算整个语句完成</p>
<pre><code>expect pattern command
expect pattern2 command2

<span class="comment"># 串行示例</span>
expect <span class="string">"username:"</span>
<span class="keyword">send</span> <span class="string">"<span class="variable">$userid</span>\r"</span>
expect <span class="string">"password:"</span> { <span class="keyword">send</span> <span class="string">"<span class="variable">$mypassword</span>\r"</span> }

<span class="comment"># 利用exp_continue并行实现串行，continue执行下一个pattern</span>
expect {   
    <span class="string">"*yes/no"</span> { <span class="keyword">send</span> <span class="string">"yes\r"</span>; exp_continue }
     <span class="string">"*password:"</span> { <span class="keyword">send</span> <span class="string">"<span class="variable">$mypassword</span>\r"</span> }   
}
</code></pre></li>
</ul>
<h5 id="shell脚本接收多个参数">shell脚本接收多个参数</h5><ol>
<li>expect脚本可以接受从bash传递过来的参数.可以使用[lindex $argv n]获得，n从0开始，分别表示第一个,第二个,第三个….参数</li>
<li>$argc为命令行参数的个数，$argv0为脚本名字本身，$argv为命令行参数。[lrange $argv 0 0]表示第1个参数，[lrange $argv 0 4]为第一个到第五个参数。</li>
<li>执行<code>./test.sh 1 2 3</code>,脚本内容如下：</li>
</ol>
<figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/expect -d</span></span><br><span class="line"><span class="keyword">set</span> username [<span class="keyword">lindex</span> <span class="variable">$argv</span> <span class="number">0</span>]</span><br><span class="line"><span class="keyword">set</span> password [<span class="keyword">lindex</span> <span class="variable">$argv</span> <span class="number">1</span>]</span><br><span class="line"><span class="keyword">set</span> server [<span class="keyword">lindex</span> <span class="variable">$argv</span> <span class="number">2</span>]</span><br><span class="line">send_user  <span class="string">"UserName is $username\n"</span></span><br><span class="line">send_user  <span class="string">"PassWord is $password\n"</span></span><br><span class="line">send_user  <span class="string">"Server is $server\n"</span></span><br><span class="line">send_user <span class="string">"Total arg num is $argc\n"</span></span><br></pre></td></tr></table></figure>
<h4 id="bash脚本直接调用expect进行交互">bash脚本直接调用expect进行交互</h4><ul>
<li>Here document实现, expect脚本可以使用bash中定义的变量</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="shebang">#!/bin/bash</span></span><br><span class="line">host=<span class="string">"USER@HOST"</span></span><br><span class="line">password=<span class="string">"PASSWORD"</span></span><br><span class="line">cmd=<span class="string">"command_list"</span></span><br><span class="line"></span><br><span class="line">expect &lt;&lt;EOF </span><br><span class="line">spawn ssh <span class="variable">$host</span> <span class="string">"<span class="variable">$cmd</span>"</span></span><br><span class="line">expect &#123;</span><br><span class="line"><span class="string">"*(yes/no)?"</span> &#123; send <span class="string">"yes\r"</span>;exp_<span class="built_in">continue</span> &#125;</span><br><span class="line"><span class="string">"*assword:"</span> &#123; send <span class="string">"<span class="variable">$password</span>\r"</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line">expect eof</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
<ul>
<li>直接使用set来定义变量并在expect脚本中使用</li>
</ul>
<figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="shebang">#!/bin/bash</span></span><br><span class="line">expect -c '</span><br><span class="line">set $PASSWORD=<span class="string">"123qwe"</span></span><br><span class="line">spawn ssh USER<span class="keyword">@HOST</span> <span class="string">"commands"</span></span><br><span class="line">expect &#123;</span><br><span class="line"><span class="string">"*(yes/no)?"</span> &#123; send <span class="string">"yes\r"</span>;exp_continue &#125;</span><br><span class="line"><span class="string">"*assword:"</span> &#123; send <span class="string">"$PASSWORD\r"</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line">expect eof</span><br><span class="line">'</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果希望保持登录，去掉上面代码的ssh后的命令列表并且将expect eof改成interact即可</p>
</blockquote>
<h4 id="更多示例">更多示例</h4><ol>
<li><a href="http://xstarcd.github.io/wiki/shell/expect.html" target="_blank" rel="external">expect交互脚本示例</a></li>
<li><a href="https://www.jianshu.com/p/70556b1ce932" target="_blank" rel="external">Linux Expect 简介和使用实例</a></li>
</ol>
<h4 id="开发机登陆脚本示例">开发机登陆脚本示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/expect</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 登录relay</span></span><br><span class="line">spawn ssh relay01.baidu.com</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义变量</span></span><br><span class="line"><span class="built_in">set</span> PIN <span class="string">"123321"</span></span><br><span class="line"><span class="built_in">set</span> HOST <span class="string">"hz01-bos-dev-r15-01-005.hz01"</span></span><br><span class="line"><span class="built_in">set</span> PASSWORD <span class="string">""</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行脚本时带上参数,以空格分开</span></span><br><span class="line"><span class="comment"># set TOKEN [lindex $argv 0]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开调试模式</span></span><br><span class="line"><span class="comment">#exp_internal 1</span></span><br><span class="line"><span class="comment"># relay PIN码 + Token(Token需手动输入)</span></span><br><span class="line">expect &#123;</span><br><span class="line">    -re <span class="string">"password:*"</span> &#123;</span><br><span class="line">        send_user <span class="string">"PIN:****** + Token:"</span></span><br><span class="line">        expect_user &#123;</span><br><span class="line">            -timeout -<span class="number">1</span></span><br><span class="line">            -re <span class="string">"(.*)\n"</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">set</span> TOKEN <span class="variable">$expect_out</span>(buffer)</span><br><span class="line">        send <span class="string">"<span class="variable">$PIN</span><span class="variable">$TOKEN</span>\r"</span></span><br><span class="line">        exp_<span class="built_in">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment"># 自动登录开发机</span></span><br><span class="line">    -re <span class="string">"-bash-baidu-ssl*"</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> &#123; <span class="string">"<span class="variable">$HOST</span>"</span> != <span class="string">""</span> &#125; &#123;</span><br><span class="line">            send <span class="string">"ssh --silent <span class="variable">$HOST</span>\r"</span></span><br><span class="line">            <span class="comment"># [可选]自动开发机输入密码</span></span><br><span class="line">            <span class="keyword">if</span> &#123; <span class="string">"<span class="variable">$PASSWORD</span>"</span> != <span class="string">""</span> &#125; &#123;</span><br><span class="line">                expect -re <span class="string">"password:"</span> &#123; send <span class="string">"<span class="variable">$PASSWORD</span>\r"</span> &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 关闭调试模式</span></span><br><span class="line"><span class="comment">#exp_internal 0</span></span><br><span class="line">interact</span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure>

        
      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="../../tags/Linux/"> #Linux </a>
          
            <a href="../../tags/shell/"> #shell </a>
          
        </div>
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
  </div>

  
  <div class="pagination">
    <a class="extend prev" rel="prev" href="../5/">&laquo;</a><a class="page-number" href="../..//">1</a><span class="space">&hellip;</span><a class="page-number" href="../5/">5</a><span class="page-number current">6</span><a class="page-number" href="../7/">7</a><span class="space">&hellip;</span><a class="page-number" href="../16/">16</a><a class="extend next" rel="next" href="../7/">&raquo;</a>
  </div>


        </div>

        
      </div>


      
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <div id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      <div class="site-overview">
        <div class="site-author motion-element">
          <img class="site-author-image" src="/images/avatar.jpg" alt="CharlesXiao" />
          <p class="site-author-name">CharlesXiao</p>
        </div>
        <p class="site-description motion-element">在码农炼成之路不断挣扎……stay hungry……keep learning……</p>
        <div class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="../..//archives">
              <span class="site-state-item-count">80</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            <a href="../..//categories">
              <span class="site-state-item-count">17</span>
              <span class="site-state-item-name">分类</span>
              </a>
          </div>

          <div class="site-state-item site-state-tags">
            <a href="../..//tags">
              <span class="site-state-item-count">75</span>
              <span class="site-state-item-name">标签</span>
              </a>
          </div>

        </div>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
              <a href="https://github.com/Charles-Xiao" target="_blank">github</a>
            </span>
            
              <span class="links-of-author-item">
              <a href="http://weibo.com/2262300105/profile?topnav=1&wvr=6" target="_blank">weibo</a>
            </span>
            
              <span class="links-of-author-item">
              <a href="http://daijiale.github.io/" target="_blank">Daijiale的个人站点</a>
            </span>
            
          
        </div>

        
        

      </div>

      

    </div>
  </div>


    </div>

    <div id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; &nbsp;  2015.05.16 - 
  2018
  <span class="with-love">
    <i class="icon-heart"></i>
  </span>
  <span class="author">CharlesXiao</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>



      </div>
    </div>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="../../vendors/jquery/index.js?v=2.1.3"></script>

  
  

  
  <script type="text/javascript" src="../../vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript">
    $(document).ready(function() {
      $('.content img').each(function () {
        var $image = $(this);
        var $imageWrapLink = $image.parent('a');

        if ($imageWrapLink.size() < 1) {
          $imageWrapLink = $image.wrap('<a href="' + this.getAttribute('src') + '"></a>').parent('a');
        }
        $imageWrapLink.addClass('fancybox');
      });
    });
    $('.fancybox').fancybox({
      helpers: {
        overlay: {
          locked: false
        }
      }
    });
  </script>


  <script type="text/javascript">
  function hasMobileUA () {
    var nav = window.navigator;
    var ua = nav.userAgent;
    var pa = /iPad|iPhone|Android|Opera Mini|BlackBerry|webOS|UCWEB|Blazer|PSP|IEMobile|Symbian/g;

    return pa.test(ua);
  }

  function isDesktop () {
    return screen.width > 991 && !hasMobileUA();
  }

  function isTablet () {
    return screen.width < 992 && screen.width > 767 && hasMobileUA();
  }

  function isMobile () {
    return screen.width < 767 && hasMobileUA();
  }

  function escapeSelector (selector) {
    return selector.replace(/[!"$%&'()*+,.\/:;<=>?@[\\\]^`{|}~]/g, "\\$&")
  }
</script>

  

  <script type="text/javascript" src="../../vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="../../vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" id="motion.global">
  $(document).ready(function () {
    var body = $('body');
    var isSidebarVisible = false;
    var sidebarToggle = $('.sidebar-toggle');
    var sidebarToggleLine1st = $('.sidebar-toggle-line-first')
    var sidebarToggleLine2nd = $('.sidebar-toggle-line-middle');
    var sidebarToggleLine3rd = $('.sidebar-toggle-line-last');
    var sidebar = $('.sidebar');

    var SIDEBAR_WIDTH = '320px';
    var SIDEBAR_DISPLAY_DURATION = 300;

    var sidebarToogleLineStatusInit = {width: '100%', opacity: 1, left: 0, rotateZ: 0, top: 0};

    var sidebarToggleLine1stStatusInit = sidebarToogleLineStatusInit;
    var sidebarToggleLine1stStatusArrow = {width: '50%', rotateZ: '-45deg', top: '2px'};
    var sidebarToogleLine1stStatusClose = {width: '100%', rotateZ: '-45deg', top: '5px'};

    var sidebarToggleLine2ndStatusInit = sidebarToogleLineStatusInit;
    var sidebarToggleLine2ndStatusArrow = {width: '90%'};
    var sidebarToogleLine2ndStatusClose = {opacity: 0};

    var sidebarToggleLine3rdStatusInit = sidebarToogleLineStatusInit;
    var sidebarToggleLine3rdStatusArrow = {width: '50%', rotateZ: '45deg', top: '-2px'};
    var sidebarToogleLine3rdStatusClose = {width: '100%', rotateZ: '45deg', top: '-5px'};

    LogoAndMenuMotion();
    sidebatToggleMotion();
    postsListMotion();
    backToTopMotion();


    $(document)
      .on('sidebar.isShowing', function () {
        isDesktop() && body.velocity(
          {paddingRight: SIDEBAR_WIDTH},
          SIDEBAR_DISPLAY_DURATION
        );
        sidebarContentMotion();
      })
      .on('sidebar.isHiding', function () {});

    function LogoAndMenuMotion() {
      $.Velocity.RunSequence([
        { e: $('.brand'), p: { opacity: 1 }, o: { duration: 100 } },
        { e: $('.logo'), p: { opacity: 1, top: 0 }, o: { duration: 50} },
        
        { e: $('.logo-line-before i'), p: { translateX: "100%" }, o: { duration: 500, sequenceQueue: false } },
        { e: $('.logo-line-after i'), p: { translateX: "-100%" }, o: { duration: 500, sequenceQueue: false } },
        
        { e: $('.site-title'), p: { opacity: 1, top: 0 }, o: { duration: 200 } }
      ]);
      $('.menu-item').velocity('transition.slideDownIn', {display: null});
    }


    function backToTopMotion () {
      var b2top = $('.back-to-top');
      b2top.on('click', function () {
        body.velocity('scroll');
      });
    }

    function sidebarShowMotion () {

      sidebarToggleLine1st.velocity(sidebarToogleLine1stStatusClose);
      sidebarToggleLine2nd.velocity(sidebarToogleLine2ndStatusClose);
      sidebarToggleLine3rd.velocity(sidebarToogleLine3rdStatusClose);

      sidebar.velocity({width: SIDEBAR_WIDTH}, {
        display: 'block',
        duration: SIDEBAR_DISPLAY_DURATION,
        complete: function () {
          sidebar.addClass('sidebar-active');
          sidebar.trigger('sidebar.didShow');
        }
      });
      sidebar.trigger('sidebar.isShowing');
    }

    function sidebarHideMotion () {
      isDesktop() && body.velocity({paddingRight: 0});
      sidebar.velocity('reverse');

      sidebarToggleLine1st.velocity(sidebarToggleLine1stStatusInit);
      sidebarToggleLine2nd.velocity(sidebarToggleLine2ndStatusInit);
      sidebarToggleLine3rd.velocity(sidebarToggleLine3rdStatusInit);

      sidebar.removeClass('sidebar-active');
      sidebar.trigger('sidebar.isHiding');
    };

    function sidebarContentMotion () {
      $('.sidebar .motion-element').velocity(
        'transition.slideRightIn',
        {stagger: 50, drag: true}
      );
    }

    function postsListMotion () {
      var postMotionOptions = window.postMotionOptions || {stagger: 300, drag: true};
      $('.post').velocity('transition.slideDownIn', postMotionOptions);
    }

    function sidebatToggleMotion () {
      sidebarToggle.on('click', function () {
        isSidebarVisible ? sidebarHideMotion() : sidebarShowMotion();
        isSidebarVisible = !isSidebarVisible;
      });

      sidebarToggle.hover(function () {
        if (isSidebarVisible) {return}
        sidebarToggleLine1st.velocity('stop').velocity(sidebarToggleLine1stStatusArrow);
        sidebarToggleLine2nd.velocity('stop').velocity(sidebarToggleLine2ndStatusArrow);
        sidebarToggleLine3rd.velocity('stop').velocity(sidebarToggleLine3rdStatusArrow);
      }, function () {
        if (isSidebarVisible) {return}
        sidebarToggleLine1st.velocity('stop').velocity(sidebarToggleLine1stStatusInit);
        sidebarToggleLine2nd.velocity('stop').velocity(sidebarToggleLine2ndStatusInit);
        sidebarToggleLine3rd.velocity('stop').velocity(sidebarToggleLine3rdStatusInit);
      });
    }
  });

</script>





  

  
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
  });
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for (i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>


  
  
  


  

  
</body>
</html>
