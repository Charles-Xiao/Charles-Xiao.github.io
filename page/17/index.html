<!doctype html>
<html class="theme-next use-motion theme-next-mist">
<head><meta name="generator" content="Hexo 3.8.0">
  

<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">






  <link rel="stylesheet" type="text/css" href="../../vendors/fancybox/source/jquery.fancybox.css?v=2.1.5">


<link rel="stylesheet" type="text/css" href="../../css/main.css?v=0.4.2">


    <meta name="description" content="在码农炼成之路不断挣扎……stay hungry……keep learning……">



  <meta name="keywords" content="java,android,life,CharlesXiao">





  <link rel="shorticon icon" type="image/x-icon" href="../../favicon.ico?v=0.4.2">



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?6749450";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>


  <title> CharlesXiao‘s Blog </title>
</head>

<body>
<!--[if lte IE 8]> <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'> <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode"><img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820" alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari." style='margin-left:auto;margin-right:auto;display: block;'/></a></div> <![endif]-->
  <div class="container one-column 
  
">
    <div class="headband"></div>
    <!-- fork me github icon  -->
    <a href="https://github.com/Charles-Xiao" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewbox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <div id="header" class="header">
      <div class="header-inner">
        <h1 class="site-meta">
  <span class="logo-line-before"><i></i></span>
  <a href="/" class="brand">
      <span class="logo">
        <i class="icon-logo"></i>
      </span>
      <span class="site-title">CharlesXiao‘s Blog</span>
  </a>
  <span class="logo-line-after"><i></i></span>
</h1>


  <ul id="menu" class="menu">
     
    <!--增加swiftype搜索功能-->
    <form class="menu-item menu-item-search">
      <input type="text" id="st-search-input" class="st-search-input st-default-search-input">
    </form>
    
    <script type="text/javascript">
      (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
      (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
      e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
      })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

      _st('install','yxUhPQ2aHyszT_1btxX9','2.0.0');
    </script>
    <!--增加swiftype搜索功能end-->
    
    
      
      <li class="menu-item menu-item-home">
        <a href="/">
          <i class="menu-item-icon icon-home"></i> <br>
          首页
        </a>
      </li>
    
      
      <li class="menu-item menu-item-categories">
        <a href="/categories">
          <i class="menu-item-icon icon-categories"></i> <br>
          分类
        </a>
      </li>
    
      
      <li class="menu-item menu-item-about">
        <a href="/about">
          <i class="menu-item-icon icon-about"></i> <br>
          关于
        </a>
      </li>
    
      
      <li class="menu-item menu-item-archives">
        <a href="/archives">
          <i class="menu-item-icon icon-archives"></i> <br>
          归档
        </a>
      </li>
    
      
      <li class="menu-item menu-item-tags">
        <a href="/tags">
          <i class="menu-item-icon icon-tags"></i> <br>
          标签
        </a>
      </li>
    
  </ul>


      </div>
    </div>

    <div id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content">
          
  <div id="posts" class="posts-expand">
    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              Android基础知识总结
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2015-04-09
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分类于
            
              <a href="../../categories/Android开发/">Android开发</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="../../2015/04/09/Android基础知识总结/#comments">
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/04/09/Android基础知识总结/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        <h3 id="Android架构层次">Android架构层次</h3><p><img src="https://raw.githubusercontent.com/Charles-Xiao/Charles-Xiao.github.io/master/images/android_framework.png" class="full-image" width="100%"></p>
<p><strong>android系统架构分从下往上为Linux内核层、运行库、应用程序框架层和应用程序层</strong></p>
<ol>
<li>Linux内核层：负责硬件的驱动程序、网络、电源、系统安全以及内存管理等功能。</li>
<li>运行库和android runtion：运行库：即c/c++函数库部分，大多数都是开放源代码的函数库，例如webkit，该函数库负责android网页浏览器的运行；例如标准的c函数库libc、openssl、sqlite等，当然也包括支持游戏开发的2dsgl和3dopengles，在多媒体方面有mediaframework框架来支持各种影音和图形文件的播放与显示，如mpeg4、h.264、mp3、aac、amr、jpg和png等众多的多媒体文件格式。Androidruntion负责解释和执行生成的dalvik格式的字节码</li>
<li>应用软件架构：java应用程序开发人员主要是使用该层封装好的api进行快速开发的。</li>
<li>应用程序层：该层是java的应用程序层，android内置的googlemaps、email、IM、浏览器等，都处于该层，java开发人员工发的程序也处于该层，而且和内置的应用程序具有平等的地位，可以调用内置的应用程序，也可以替换内置的应用程序</li>
</ol>
<h3 id="ANR的产生原因以及解决方法">ANR的产生原因以及解决方法</h3><ol>
<li>ANR由Activity manager和windows manager来负责监听，你的应用程序所做的事情如果在主线程里占用了大长时间的话，就会引发ANR对话框，因为你的应用程序并没有给自己机会来处理输入事件或者Intent广播</li>
<li><strong>产生原因</strong>: ①Activity 5s没有响应输入事件，比如按键，触摸事件②广播接收器在10s没有处理完毕事件 ③Service在20s之类没有完成事件处理</li>
<li>解决方法: 不在主线程进行网络请求,磁盘读取，位图修改，更新UI等耗时操作，而应该采用子线程来完成，完成之后通过Handler通知主线程</li>
<li><strong>如何定位ANR</strong>：①检查log文件并分析LogCat输出，查看CPU使用量等信息; ②从/data/anr/目录下的trace.txt文件查看app调用栈信息; ③代码检查</li>
</ol>
<h3 id="Android_界面卡顿怎么处理？Link">Android 界面卡顿怎么处理？<a href="http://charles-xiao.github.io/2015/08/30/Android%E5%BA%94%E7%94%A8%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">Link</a></h3><h3 id="Android子线程和UI线程交互的5种方式">Android子线程和UI线程交互的5种方式</h3><ol>
<li><p><strong>handler</strong>: 参考“实习项目总结”</p>
</li>
<li><p><strong>AsyncTask</strong>: 参考“实习项目总结”</p>
</li>
<li><p><strong>Activity.runOnUIThread(Runnable)</strong>  </p>
<p> <strong>子线程更新UI</strong>  </p>
<pre><code><span class="keyword">new</span> Thread() {  
    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{  
        <span class="comment">//这儿是耗时操作，完成之后更新UI；  </span>
        runOnUiThread(<span class="keyword">new</span> Runnable(){  

            <span class="annotation">@Override</span>  
            <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{  
                <span class="comment">//更新UI  </span>
                imageView.setImageBitmap(bitmap);  
            }  

        });  
    }  
}.start(); 
</code></pre><p> <strong>非Activity更新UI</strong></p>
<pre><code>Activity activity = (Activity) imageView.getContext();  
        activity.runOnUiThread(<span class="keyword">new</span> Runnable() {  

            <span class="annotation">@Override</span>  
            <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{  
                imageView.setImageBitmap(bitmap);  
            }  
});  
</code></pre></li>
<li><p><strong>View.Post(Runnable)</strong></p>
<pre><code>imageView.post(<span class="keyword">new</span> Runnable(){  

            <span class="annotation">@Override</span>  
            <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{  
                imageView.setImageBitmap(bitmap);  
            }  

});  
</code></pre></li>
<li><p><strong>View.PostDelayed(Runnabe,long)</strong></p>
</li>
</ol>
<h3 id="Activity四种启动模式和生命周期">Activity四种启动模式和生命周期</h3><ol>
<li><strong>Application</strong>: 应用程序是组件的集合，manifest文件中展现了application中组件的结构,加载app时会根据manifest去加载和实例化组件</li>
<li><strong>Process</strong>: 一个应用程序占据一个进程，一个运行中的dalvik虚拟机实例就占据一个进程; 但是我们可以给组件设置android:process = “name”来让组件运行在独立进程中</li>
<li><strong>Task</strong>: 一组以栈的形式来进行管理的相互关联的activity的集合，它是存在于framework层的一个跨应用的概念，控制界面的跳转和返回；task中所有的activity在一个叫做back stack的栈中进行管理</li>
<li><strong>四种启动模式</strong><ul>
<li><strong>standard</strong>: 默认的lauchmode, 同一个activity可以被实例化多次，在一个task栈中可以同时存在一个activity的多个实例，每次startActivity就新建一个实例入栈<br><img src="https://raw.githubusercontent.com/Charles-Xiao/Charles-Xiao.github.io/master/images/standard.png" class="full-image"></li>
<li><strong>singleTop</strong>: 先检查栈顶是否是该activity的实例，是则重用该实例，并且调用该实例的onNewIntent()方法，否则要新建实例压入栈顶<br><img src="https://raw.githubusercontent.com/Charles-Xiao/Charles-Xiao.github.io/master/images/singleTop.png" class="full-image">  </li>
<li><strong>singleTask</strong>: 先检查栈中是否包含该activity的实例，是则重用该实例，清理该实例上的所有activity并将其显示给用户；否则新建实例压入back stack<br><img src="https://raw.githubusercontent.com/Charles-Xiao/Charles-Xiao.github.io/master/images/singleTask.png" class="full-image"></li>
<li><strong>singleInstance</strong>: 以singleInstance模式启动的Activity具有全局唯一性，即整个系统中只会存在一个这样的实例；而且具备独占性，以该模式启动的Activity不能与其他Activity共存在一个task中<br><img src="https://raw.githubusercontent.com/Charles-Xiao/Charles-Xiao.github.io/master/images/singleInstance.png" class="full-image"></li>
</ul>
</li>
<li><p><strong>Activity以及Fragment生命周期</strong>:</p>
<p> <img src="https://raw.githubusercontent.com/Charles-Xiao/Charles-Xiao.github.io/master/images/activity_life.png" class="full-image" width="100%"></p>
<p> <img src="https://raw.githubusercontent.com/Charles-Xiao/Charles-Xiao.github.io/master/images/fragment_life.png" class="full-image" width="100%"></p>
</li>
<li><p><strong>Activity切换时生命周期交集</strong></p>
<ul>
<li><strong>当一个activity A启动了另外一个activity B，它们的生命周期是有交叉的</strong></li>
<li>首先A的onPause()被调用；之后B的onCrate(), onStart()及onResume() 方法会被调用（此时B拥有用户焦点）；最后，如果A在屏幕上不可见，onStop()方法被调用；</li>
<li>因此，我们在两个activities中传递数据，或者共享资源时（如数据库连接），需要在前一个activity的onPause()方法而不是onStop()方法中进行</li>
</ul>
</li>
<li><p><strong>onSaveInstanceState() 和 onRestoreInstanceState()</strong>： <a href="http://www.cnblogs.com/hanyonglu/archive/2012/03/28/2420515.html" target="_blank" rel="noopener">Link</a><br> ①当某个activity变得”容易”被系统销毁时，该activity的<strong>onSaveInstanceState()</strong>就会被执行，除非该activity是被用户主动销毁的，例如当用户按BACK键的时候；他的调用有<strong>5种情况</strong>：(1)、<strong>当用户按下HOME键时</strong>：这是显而易见的，系统不知道你按下HOME后要运行多少其他的程序，自然也不知道activity A是否会被销毁，因此系统会调用onSaveInstanceState()，让用户有机会保存某些非永久性的数据。以下几种情况的分析都遵循该原则 (2)、<strong>长按HOME键，选择运行其他的程序时</strong>。(3)、<strong>按下电源按键（关闭屏幕显示）时</strong>。(4)、<strong>从activity A中启动一个新的activity时</strong>。(5)、<strong>屏幕方向切换时，例如从竖屏切换到横屏时</strong>。在屏幕切换之前，系统会销毁activity A，在屏幕切换之后系统又会自动地创建activity A，所以onSaveInstanceState()一定会被执行，且也一定会执行onRestoreInstanceState()。<br> ②<strong>onRestoreInstanceState()</strong>被调用的前提是，activity A“确实”被系统销毁了，而如果仅仅是停留在有这种可能性的情况下，则该方法不会被调用，例如，当正在显示activity A的时候，用户按下HOME键回到主界面，然后用户紧接着又返回到activity A，这种情况下activity A一般不会因为内存的原因被系统销毁，故activity A的onRestoreInstanceState方法不会被执行 此也说明上二者，大多数情况下不成对被使用。</p>
</li>
<li><p><strong>如果一个以SingleTask启动的的Activity实例，再新建一个该实例，Activity的执行流程？？？</strong>singleTask保证了在栈中Activity的唯一性，如果被SingleTask标记的Activity处于栈底，上面的Activity都会被pop出栈，这个时候被标记过SingleTask的Activity生命周期会做出调整：onNewIntent-&gt;onStart-&gt;onResume, 不再调用onCreate函数</p>
</li>
<li><strong>android:taskAffinity</strong>：每个Activity都有taskAffinity属性，这个属性指出了它希望进入的Task。如果一个Activity没有显式的指明该 Activity的taskAffinity，那么它的这个属性就等于Application指明的taskAffinity，如果 Application也没有指明，那么该taskAffinity的值就等于包名；例如 android:taskAffinity=””的意思是不依附于任何task，也就是自己新建一个task</li>
</ol>
<h3 id="Service">Service</h3><p><strong>Service</strong>默认运行在主线程，Service主要运行在后台执行一些监测行为或者其他加载网页等后台操作，可以通过iBinder或者广播与Activity进行交互</p>
<ol>
<li><strong>Service两种类型:本地和远程service</strong>: <ul>
<li><strong>本地服务</strong>运行于主进程上的主线程,主进程被杀死后，服务便会终止;因为是在同一进程，因此不需要IPC，也不需要AIDL.</li>
<li><strong>远程服务</strong>运行于独立进程的主线程,不受其他进程影响，有利于为多个进程提供服务;但是会占用一定资源，并且使用AIDL进行IPC通信;对应的独立进程的名字格式为所在包名加上指定android:process字符串。</li>
</ul>
</li>
<li><strong>两种启动模式</strong>: <a href="http://www.jianshu.com/p/2fb6eb14fdec" target="_blank" rel="noopener">具体区别Link</a><ul>
<li><strong>startService</strong>方法一旦服务开启跟开启者就没有任何关系了;开启者退出了，服务还在后台长期的运行;开启者不能调用服务里面的方法</li>
<li>多次调用startService，该Service只能被创建一次，即该Service的onCreate方法只会被调用一次。但是每次调用startService，onStartCommand方法都会被调用;通过只能调用Context.stopService()方法结束服务</li>
<li><strong>bindService</strong>的方式开启并绑定服务，绑定者挂了，服务也会跟着挂掉.绑定者可以调用服务里面的方法</li>
<li>第一次执行bindService时，onCreate和onBind方法会被调用，但是多次执行bindService时，onCreate和onBind方法并不会被多次调用，即并不会多次创建服务和绑定服务;可以通过调用unbindService()方法来结束服务，调用该方法也会导致系统调用服务的onUnbind()—&gt;onDestroy()方法</li>
<li><strong>注意:对于既使用了startService同时也使用了bindService启动的服务我们如果需要停止该服务，应该同时调用stopService与unbindService方法;单独调用unbindService将不会停止Service，而必须调用stopService或Service的stopSelf 来停止服务</strong></li>
<li><strong>onDestroy方法中做清理工作</strong>例如停止在Service中创建并运行的线程。</li>
<li><strong>绑定者Activity如何调用service里的方法呢？</strong> <ul>
<li><strong>第一步</strong>自定义Service，在其内部重写onBind函数返回一个实现IBinder接口或者继承Binder的对象给绑定者—-这个自定义Binder是一个内部类，提供一个可以间接调用服务或者直接返回service对象的方法</li>
<li><strong>第二步</strong>在Activity中调用bindService方法,服务成功绑定之后，新建一个ServiceConnection的匿名内部类对象，在回调方法onServiceConnected中会传递过来一个IBinder对象给Activity使用</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Service生命周期</strong></p>
<p> <img src="https://raw.githubusercontent.com/Charles-Xiao/Charles-Xiao.github.io/master/images/service_life.png" class="full-image" width="100%"></p>
</li>
<li><p><strong>Service与Activity的通信机制</strong></p>
<ul>
<li>广播接收器: </li>
<li>iBinder机制: </li>
</ul>
</li>
<li><strong>IntentService</strong><ul>
<li><strong>为什么要用IntentService</strong>如果Service将要运行耗时或者可能被阻塞的操作时，例如直接把耗时操作放在 Service 的 onStartCommand()方法中可能会出现ANR错误；所以应该在Service中重新启动一个新的线程来进行这些操作，这时我们就可以用IntentService</li>
<li><strong>IntentService内部原理</strong>IntentService是一个用来处理异步请求的Service类的子类，当客户端通过startService(Intent)方法传递多个请求给IntentService；IntentService会在onCreate函数中新建HandlerThread去执行这些耗时操作，并新建ServiceHandler对象处理消息，当启动一个IntentService的时候接下来会调用onstart方法，该方法会给ServiceHandler发送消息，在ServiceHandler的handleMessage回调函数中调用onHandleIntent函数，<strong>因此我们可以在这个onHandleIntent方法里面处理我们的耗时工作</strong>；所以IntentService不仅有Service的功能,还有Handler处理和循环消息的功能  </li>
<li><strong>IntentService对多个异步请求的处理流程</strong>IntentService使用队列的方式将请求的Intent加入队列，然后开启一个工作线程来处理队列中的Intent，对于异步的多次startService请求，IntentService会处理完成一个之后再处理第二个，每一个请求都会在一个单独的worker thread中处理，不会阻塞应用程序的主线程;当任务执行完后，IntentService 会自动停止，而不需要我们去手动控制。</li>
</ul>
</li>
<li><strong>Service后台保活</strong>: <ul>
<li><strong>提高Service的优先级或者提高Service所在进程的优先级</strong>：这个，也只能说在系统内存不足需要回收资源的时候，优先级较高，不容易被回收；实现方法有<br>①startForeground()方法来设置 Service为前台服务，优先级和正在运行的 Activity类似<br>②在AndroidManifest.xml文件中对于intent-filter可以通过android:priority = “1000”这个属性设置最高优先级，1000是最高值，如果数字越小则优先级越低</li>
<li><strong>在onDestroy方法里重启service</strong>：这个倒还算挺有效的一个方法，但是，直接干掉进程的时候，onDestroy方法都进不来，更别想重启了</li>
<li><strong>broadcast广播</strong>：和第3种一样，没进入onDestroy，就不知道什么时候发广播了，另外，在Android4.4以上，程序完全退出后，就不好接收广播了，需要在发广播的地方特定处理</li>
<li><strong>Service的onStartCommand方法返回START_STICKY</strong>，这个也主要是针对系统资源不足而导致的服务被关闭。四个返回值<a href="http://www.jianshu.com/p/a9360c282ef0" target="_blank" rel="noopener">参考link</a>：start_sticky、start_no_sticky、START_REDELIVER_INTENT、START_STICKY_COMPATIBILITY</li>
<li><strong>App进程之间互相唤醒</strong></li>
<li><strong>通过JNI的方式（NDK编程），fork()出一个子线程作为守护进程，轮询监听服务状态</strong>。守护进程（Daemon）是运行在后台的一种特殊进程。它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。而守护进程的会话组和当前目录，文件描述符都是独立的。后台运行只是终端进行了一次fork，让程序在后台执行，这些都没有改变。</li>
</ul>
</li>
</ol>
<h3 id="BroadcastReceiver">BroadcastReceiver</h3><p><strong>广播接收器</strong>用于过滤接收并响应来自其他应用程序或者系统的广播消息；每次广播到来时, 会重新创建 BroadcastReceiver对象,并且调用onReceive()方法,执行完以后,该对象即被销毁。当onReceive()方法在 10 秒内没有执行完毕，就会导致ANR。如果需要执行长任务，那么就有必要使用Service；BroadcastReceiver会堵塞主线程。唯有onReceive()结束，主线程才得以继续进行。</p>
<ol>
<li><strong>种类和特点</strong>: <ul>
<li><strong>全局广播包括有序广播、同步广播等</strong>，即发出去的广播可以被其他任何应用程序接收到，并且我们也可以接收来自于其他任何应用程序的广播。</li>
<li>全局广播跨进程必然会造成安全问题，于是便有了<strong>本地广播</strong>：即只能在本应用程序中发送和接收广播。这就要使用到了LocalBroadcastManager这个类来对广播进行管理。</li>
</ul>
</li>
<li><strong>静态注册和动态注册</strong>：</li>
</ol>
<h3 id="ContentProvider">ContentProvider</h3><h3 id="Android_View事件分发机制">Android View事件分发机制</h3><p><img src="https://raw.githubusercontent.com/Charles-Xiao/Charles-Xiao.github.io/master/images/scroller.png" class="full-image" width="100%"></p>
<h3 id="Android_Touch事件分发">Android Touch事件分发</h3><ol>
<li>Touch事件传递的相关函数有dispatchTouchEvent(决定是否分发事件的函数)、onInterceptTouchEvent(决定是否截停事件的函数)、onTouchEvent(决定是否消费本次事件的函数)   </li>
<li>Touch事件会被封装成MotionEvent对象，该对象封装了手势按下、移动、松开等动作;事件类型分为ACTION_DOWN, ACTION_UP, ACTION_MOVE, ACTION_POINTER_DOWN, ACTION_POINTER_UP, ACTION_CANCEL，每个事件都是以ACTION_DOWN开始ACTION_UP结束。</li>
<li>Touch事件通常从Activity#dispatchTouchEvent发出，只要没有被消费，会一直往下传递，到最底层的View; 如果Touch事件传递到的每个View都不消费事件，那么Touch事件会反向向上传递,最终交由Activity#onTouchEvent处理. </li>
<li>Touch事件相关的类有View、ViewGroup、Activity, onInterceptTouchEvent为ViewGroup特有，可以拦截事件; Down事件到来时，如果一个View没有消费该事件，那么后续的MOVE/UP事件都不会再给它;OnTouchListener优先于onTouchEvent()对事件进行消费</li>
<li><strong>Touch事件分发详细图示</strong><br><img src="https://raw.githubusercontent.com/Charles-Xiao/Charles-Xiao.github.io/master/images/touch.png" class="full-image" width="100%"></li>
</ol>
<h3 id="Android平台中实现数据存储的5种方式">Android平台中实现数据存储的5种方式</h3><ol>
<li><strong>使用SharedPreferences存储数据</strong>：SharedPreferences是Android平台上一个轻量级的存储类，本质是基于XML文件存储key-value键值对数据，主要是保存一些常用的配置信息，提供了Long长整形、Int整形、String字符串型的保存。它分为多种权限，可以全局共享访问，最终是以xml方式来保存。SharedPreferences对象本身只能获取数据而不支持存储和修改，存储修改是通过Editor对象实现。<ul>
<li><strong>存储步骤</strong>:①根据Context获取SharedPreferences对象 ②利用edit()方法获取Editor对象。 ③通过Editor对象存储key-value键值对数据。 ④通过commit()方法提交数据。</li>
</ul>
</li>
<li><strong>文件存储数据</strong></li>
<li><strong>SQLite数据库存储数据</strong></li>
<li><strong>使用ContentProvider存储数据</strong></li>
<li><strong>网络存储数据</strong></li>
</ol>
<h3 id="Android_屏幕适配方法总结"><a href="http://www.jianshu.com/p/ec5a1a30694b" target="_blank" rel="noopener">Android 屏幕适配方法总结</a></h3><h3 id="Android进程间通信方法">Android进程间通信方法</h3><ol>
<li><strong>AIDL+Binder机制</strong><ul>
<li><strong>AIDL</strong>：即Android接口定义语言，一种帮助实现Binder通信的工具。由于<strong>Android不同的进程不能共享内存</strong>，所以为了解决进程间通讯的问题，Android使用一种接口定义语言来公开服务的接口，本质上，AIDL非常像一个接口，通过公开接口，让别的进程调用该接口，从而实现进程间的通讯。<strong>具体用法</strong>: 只要用几条简单的函数声明，AIDL就会帮忙生成一个JAVA文件，包括了一个Proxy和Stub的访问接口，以及用于它们之间通信的Parcel，并保证Parcel的输入输出的顺序一致性，其中Proxy用于客户端进程，Stub用于Service端进程.<a href="http://www.jianshu.com/p/b9b15252b3d6" target="_blank" rel="noopener">AIDL基本用法</a></li>
<li><strong>Binder机制</strong>：Android进程间通信是通过Binder来实现的，Binder机制使本地对象能够调用远程对象的方法，在不同进程中传递单向/双向消息。远程Service在Client绑定服务时，会在onBind()的回调中返回一个Binder，当Client调用bindService()与远程Service建立连接成功时，会拿到远程Binder实例，从而使用远程Service提供的服务。<strong>Binder优点</strong>是基于C/S通信模式，传输过程只需要一次拷贝，且为Client添加UID/PID身份，性能和安全性更好，并且Binder可以建立私有通道，这是linux的通信机制所无法实现的,因此Android进程间通信使用了Binder。</li>
<li><strong>Binder通信模型</strong>: Android系统Binder机制中的四个组件Client、Server、Service Manager和Binder驱动程序的关系如下图<ol>
<li>Client、Server和Service Manager实现在用户空间中，Binder驱动程序实现在内核空间中<ol>
<li>Binder驱动程序和Service Manager在Android平台中已经实现，开发者只需要在用户空间实现自己的Client和Server</li>
<li>Binder驱动程序提供设备文件/dev/binder与用户空间交互，Client、Server和Service Manager通过open和ioctl文件操作函数与Binder驱动程序进行通信</li>
<li>Client和Server之间的进程间通信通过Binder驱动程序间接实现</li>
<li>Service Manager是一个守护进程，用来管理Server，并向Client提供查询Server接口的能力<br><img src="https://raw.githubusercontent.com/Charles-Xiao/Charles-Xiao.github.io/master/images/Binder.jpg" class="full-image" width="100%"></li>
</ol>
</li>
</ol>
</li>
<li><strong>Binder CS通信流程</strong>:<ol>
<li><strong>Server</strong>作为众多Service的拥有者，当它想向Client提供服务时，得先去Service Manager（以后缩写成SM）那儿注册自己的服务。Server可以向SM注册一个或多个服务。</li>
<li><strong>Client</strong>作为Service的使用者，当它想使用服务时，得向SM申请自己所需要的服务。Client可以申请一个或多个服务。</li>
<li><strong>ServiceManager</strong>SM一方面管理Server所提供的服务，同时又响应Client的请求并为之分配相应的服务。</li>
</ol>
</li>
</ul>
</li>
<li><strong>Messenger</strong>：Messenger是基于AIDL实现的，服务端（被动方）提供一个Service来处理客户端（主动方）连接，维护一个Handler来创建Messenger，在onBind时返回Messenger的binder。<br>双方用Messenger来发送数据，用Handler来处理数据。Messenger处理数据依靠Handler，所以是串行的，也就是说，Handler接到多个message时，就要排队依次处理</li>
<li><strong>Socket通信</strong>: 在服务端定义ServerSocket并使用一个while循环监听客户端端口，客户端使用Socket来请求端口，连通后就可以进行通信<h3 id="Android数据共享">Android数据共享</h3></li>
<li><strong>ContentProvider</strong>: 系统四大组件之一，底层也是Binder实现，主要用来为不同应用程序之间提供数据共享；可以用文件，内存数据，数据库等一切来充当数据源</li>
<li><strong>Bundle/Intent传递数据</strong>：可传递基本类型，String，实现了Serializable或Parcellable接口的数据结构。Serializable是Java的序列化方法，Parcellable是Android的序列化方法，前者代码量少，但I/O开销较大，一般用于输出到磁盘或网卡；后者实现代码多，效率高，一般用户内存间序列化和反序列化传输</li>
<li><strong>本地文件共享</strong>：对同一个文件先后写读，从而实现传输，Linux机制下，可以对文件并发写，所以要注意同步。顺便一提，Windows下不支持并发读或写。</li>
<li><p><strong>SharedPreferences</strong>：Preference提供了一种轻量级的数据存取方法，应用场合主要是数据比较少的配置信息。它以“键-值”（是一个Map）对的方式将数据保存在一个XML配置文件中</p>
<pre><code><span class="keyword">Context</span> otherAppContext = createPackageContext(<span class="string">"com.gary.appdisplaycontrol"</span>, <span class="keyword">Context</span>.CONTEXT_IGNORE_SECURITY);
SharedPreferences sharedPreferences = otherAppContext.getSharedPreferences(<span class="string">"preferences"</span>,<span class="keyword">Context</span>.MODE_WORLD_READABLE|<span class="keyword">Context</span>.MODE_MULTI_PROCESS)
</code></pre></li>
</ol>
<h3 id="Json_VS_XML">Json VS XML</h3><p><a href="http://blog.csdn.net/wei78008023/article/details/44940579" target="_blank" rel="noopener">XML解析和Json解析简介以及两者的区别</a></p>
<h3 id="Android安全">Android安全</h3><ol>
<li>错误导出组件 </li>
<li>参数校验不严 </li>
<li>WebView引入各种安全问题,webview中的js注入 </li>
<li>不混淆、不防二次打包 </li>
<li>明文存储关键信息 </li>
<li>错误使用HTTPS </li>
<li>山寨加密方法 </li>
<li>滥用权限、内存泄露、使用debug签名</li>
</ol>
<h3 id="设备横竖屏切换的时候，接下来会发生什么？">设备横竖屏切换的时候，接下来会发生什么？</h3><ol>
<li>不设置Activity的android:configChanges时，切屏会重新调用各个生命周期，切横屏时会执行一次，切竖屏时会执行两次 </li>
<li>设置Activity的android:configChanges=”orientation”时，切屏还是会重新调用各个生命周期，切横、竖屏时只会执行一次 </li>
<li>设置Activity的android:configChanges=”orientation|keyboardHidden”时，切屏不会重新调用各个生命周期，只会执行onConfigurationChanged方法</li>
</ol>
<h3 id="谈谈你对Android中Context的理解?">谈谈你对Android中Context的理解?</h3><p>Context:包含上下文信息(外部值) 的一个参数. Android 中的 Context 分三种,Application Context ,Activity Context ,Service Context.<br>它描述的是一个应用程序环境的信息，通过它我们可以获取应用程序的资源和类，也包括一些应用级别操作，例如：启动一个Activity，发送广播，接受Intent信息等</p>
<h3 id="如何缩减APK包大小？">如何缩减APK包大小？</h3><ol>
<li><strong>代码</strong><br> 保持良好的编程习惯，不要重复或者不用的代码，谨慎添加libs，移除使用不到的libs。<br>使用proguard混淆代码，它会对不用的代码做优化，并且混淆后也能够减少安装包的大小。<br>native code的部分，大多数情况下只需要支持armabi与x86的架构即可。如果非必须，可以考虑拿掉x86的部分。 </li>
<li><strong>资源</strong><br>使用Lint工具查找没有使用到的资源。去除不使用的图片，String，XML等等。 assets目录下的资源请确保没有用不上的文件。<br>生成APK的时候，aapt工具本身会对png做优化，但是在此之前还可以使用其他工具如tinypng对图片进行进一步的压缩预处理。<br>jpeg还是png，根据需要做选择，在某些时候jpeg可以减少图片的体积。 对于9.png的图片，可拉伸区域尽量切小，另外可以通过使用9.png拉伸达到大图效果的时候尽量不要使用整张大图。 </li>
<li>策略<br>有选择性的提供hdpi，xhdpi，xxhdpi的图片资源。建议优先提供xhdpi的图片，对于mdpi，ldpi与xxxhdpi根据需要提供有差异的部分即可。<br>尽可能的重用已有的图片资源。例如对称的图片，只需要提供一张，另外一张图片可以通过代码旋转的方式实现。<br>能用代码绘制实现的功能，尽量不要使用大量的图片。例如减少使用多张图片组成animate-list的AnimationDrawable，这种方式提供了多张图片很占空间。</li>
</ol>
<h3 id="Android插件化与动态加载">Android插件化与动态加载</h3><ol>
<li><strong>为什么要插件化？？？And它是什么？有什么好处？</strong>当一个app的方法数超过了一个 Dex 最大方法数 65535 的上限，因而便有了插件化的概念，<strong>Android插件化</strong>指将一个程序划分为不同的部分，也就是将一个App划分为多个插件（Apk或相关格式）比如一般App的皮肤样式就可以看成一个插件; <strong>插件化的好处</strong>包括：(1) 模块解耦(2) 可以动态升级(3) 高效并行开发(编译速度更快) (4) 按需加载，内存占用更低 (5) 节省升级流量</li>
<li><strong>插件化的原理实际是 Java ClassLoader 的原理</strong>: Android 有自己的 ClassLoader，分为 dalvik.system.DexClassLoader 和 dalvik.system.PathClassLoader，区别在于: <ul>
<li><strong>PathClassLoader</strong>: 不能直接从 zip 包中得到 dex，因此只支持直接操作 dex 文件或者已经安装过的 apk（因为安装过的 apk 在 cache 中存在缓存的 dex 文件）</li>
<li><strong>DexClassLoader</strong> 可以加载外部文件系统中的 apk、jar 或 dex文件，并且会在指定的 outpath 路径存放其 dex 文件。</li>
<li><strong>此外还有URLClassLoader</strong> ：可以加载java中的jar，但是由于dalvik不能直接识别jar，所以此方法在Android中无法使用，尽管还有这个类</li>
</ul>
</li>
<li><strong>Android热加载或Android动态部署</strong>指App在运⾏状态下动态加载某个模块，从而新增功能或改变某⼀部分行为. 例如一个app（称之为宿主程序）去本地文件中动态加载apk文件并将其放在自己的进程中执行 </li>
<li><strong>为什么有dex文件以及为什么要有DexClassLoader？？？</strong>Android应用程序，本质上使用的是java开发，使用标准的java编译器编译出Class文件，和普通的java开发不同的地方是把class文件再重新打包成dex类型的文件，这种重新打包会对Class文件内部的各种函数表、变量表等进行优化，最终产生了dex文件。dex文件是一种经过android打包工具优化后的Class文件，因此加载这样特殊的Class文件就需要特殊的类装载器；所以android中提供了DexClassLoader类</li>
</ol>
<h3 id="AsyncTask和Handler,Looper">AsyncTask和Handler,Looper</h3><ol>
<li><strong>网络请求交互</strong>：参见百度锁屏项目</li>
<li><strong>Android AsynTask实现多任务下载管理</strong>:</li>
</ol>
<pre><code><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoAsyncTask</span> <span class="keyword">extends</span> <span class="title">AsyncTask</span>&lt;<span class="title">String</span>, <span class="title">Integer</span>, <span class="title">Bitmap</span>&gt; </span>{
    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPreExecute</span><span class="params">()</span> </span>{
        <span class="keyword">super</span>.onPreExecute();
    }

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">protected</span> Bitmap <span class="title">doInBackground</span><span class="params">(String... params)</span> </span>{
        <span class="keyword">return</span> <span class="keyword">null</span>;
    }   

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPostExecute</span><span class="params">(Bitmap result)</span> </span>{
        <span class="keyword">super</span>.onPostExecute(result);
    }

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onProgressUpdate</span><span class="params">(Integer... progress)</span> </span>{
        <span class="keyword">super</span>.onProgressUpdate(progress);
    }

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCancelled</span><span class="params">()</span> </span>{
        <span class="keyword">super</span>.onCancelled();
    }
}
</code></pre><ul>
<li><strong>AsyncTask<string,integer,bitmap>参数解析</string,integer,bitmap></strong><ol>
<li>params 启动任务执行的输入参数，比如HTTP请求的URL(doInBackground函数的参数类型)</li>
<li>progress 后台任务执行的百分比（onProgressUpdate函数的参数类型）</li>
<li>result 后台执行任务最终返回的结果，比如String(doInBackground返回的参数类型</li>
<li>new AsynTask.execute(url); execute方法内部调用executeOnExecutor()方法，执行之后AsyncTask会把任务交给线程池，由线程池来管理创建Thread和运行Therad执行任务</li>
<li>使用AsyncTask类，以下是几条必须遵守的准则：AsyncTask的实例必须在UI thread中创建; execute方法必须在UI thread中调用,并且只能调用一次；3.0版本之后的AsyncTask同时只能执行一个任务，但是提供executeOnExecutor(executor)来接收自定义ThreadPoolExecutor线程池，3.0之前默认为SerialExecutor，其核心线程池的大小是5，线程池总大小为128，缓存任务队列是10</li>
</ol>
</li>
<li><p><strong>AsyncTask内部实现原理</strong></p>
<ol>
<li>AsyncTask的本质是一个线程池，AsyncTask在构造函数中新建一个继承Callable接口的WorkerRunnable类对象，重载call方法，在call方法中执行语句<strong>return postResult(doInBackground(mParams));</strong>执行doInBackground中的异步任务；然后新建FutureTask接受WorkerRunnable作为参数，提交到线程池执行；在FutureTask的重载done函数中调用get方法接收线程执行的返回结果并定义任务状态变化后的操作（包括失败和成功），再调用postResult方法利用handler(一个static class InternalHandler extends Handler对象)发送message给UI线程 </li>
<li>AsyncTask派生出的子类可以实现不同的异步任务，这些任务都是提交到静态的线程池中执行; 线程池中的工作线程执行doInBackground(mParams)方法执行异步任务</li>
<li>当任务状态改变(例如进度更新，执行成功，取消)之后，线程池中的工作线程会向UI线程发送消息，UI线程中的AsyncTask内部的InternalHandler响应这些消息并进行处理；例如：如果当前任务被取消掉了，就会调用onCancelled()方法不再调用onPostExecute方法，如果没有被取消，则调用onPostExecute()方法，这样当前任务的执行就全部结束了</li>
</ol>
</li>
<li><p><strong>AsyncTask和Handler,Looper之间的区别联系</strong></p>
<ol>
<li>AsyncTask是对Handler与Thread的封装。</li>
<li>AsyncTask在代码上比Handler要轻量级别，但实际上比Handler更耗资源，因为AsyncTask底层是一个线程池，而Handler仅仅就是发送了一个消息队列。但是，如果异步任务的数据特别庞大，AsyncTask线程池比Handler节省开销，因为Handler需要不停的new Thread执行</li>
<li>AsyncTask的实例化只能在主线程，Handler可以随意，只和Looper有关系</li>
</ol>
</li>
</ul>
<ol>
<li><p><strong>Handler+Looper+MessageQueue异步信息处理系统模型</strong> <a href="http://m.blog.csdn.net/article/details?id=38377229" target="_blank" rel="noopener">Link</a></p>
<ul>
<li><strong>Handler+Looper+MessageQueue概念</strong> <strong>Looper</strong>本质是一个ThreadLocal变量，它持有一个MessageQueue消息队列，负责实现消息循环和消息派发; <strong>Handler</strong>通过post和sendMessage方法去负责收发Message,包括push新消息到MessageQueue或者接收Looper从其持有的MessageQueue中取出来的消息; MessageQueue是一个FIFO消息队列</li>
<li><p><strong>异步通信流程</strong>：<br>  ① <strong>消息分发和处理</strong>: 首先一个线程通过调用Looper.prepare()，为自己创建一个唯一的Looper对象，在该Looper对象的构造函数中会执行<strong>mQueue = new MessageQueue(quitAllowed);</strong>去创建一个消息队列；然后我们新建一个或者多个Handler并重载他们的handleMessage回调函数，用于处理其他线程中发送过来的消息；接下来我们调用<strong>Looper.loop</strong>方法，在该方法中会建立一个无限循环体，通过调用<strong>msg.target.dispatchMessage(msg);</strong>函数(其内部调用Handler的handleMessage回调函数)不断地从消息队列中取出message，分发给不同的Handler target.<br>  (注：在主线程中默认新建Looper对象不需要显示调用prepare和loop函数，Looper、MessageQueue和Handler都是在同一个线程中)  </p>
<p>  ② <strong>Handler发送消息</strong>: Handler在初始化时就会调用<strong>mLooper = Looper.myLooper(); mQueue = mLooper.mQueue;</strong>和Looper以及消息队列相关联，然后在子线程中调用post或者sendMessage方法发送消息插入到消息队列中，这两个函数内部的调用顺序大致为sendMessageDelayed—&gt; sendMessageAtTime—&gt; enqueueMessage，在enqueueMessage函数中会执行<em>msg.target = this;</em>这样Looper就可以识别每条信息来自于哪个Handler，以便于分发消息的正确性</p>
<p>  <img src="https://raw.githubusercontent.com/Charles-Xiao/Charles-Xiao.github.io/master/images/Looper.jpg" class="full-image" width="100%"></p>
</li>
<li><p><strong>Handler更新UI</strong>：Android系统中耗时操作不能放在主线程进行，例如网络请求、数据库操作、复杂计算等逻辑；所以他们一般放在AsyncTask或者新建子线程进行，然后通过Handler发送消息通知主线程；如果这些耗时操作涉及到UI界面的更新，可以借助于(Android系统UI的更新必须放在主线程进行)Handler发送消息给UI线程更新UI</p>
</li>
<li><p><strong>Handler更新UI实例</strong>：</p>
<pre><code> <span class="comment">// UI线程新建的Handler，在handleMessage()中更新UI</span>
 <span class="keyword">private</span> Handler mHandler = <span class="keyword">new</span> Handler() {
    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">handleMessage</span> <span class="params">(Message msg)</span> </span>{
        <span class="keyword">switch</span>(msg.what) {
        <span class="keyword">case</span> MSG_SUCCESS:
            mImageView.setImageBitmap((Bitmap) msg.obj);
            <span class="keyword">break</span>;
        <span class="keyword">case</span> MSG_FAILURE:
            <span class="keyword">break</span>;
        }
    }
};

<span class="comment">// 子线程中获取网络图片并发送message通知UI线程更新显示图片</span>
Runnable runnable = <span class="keyword">new</span> Runnable() {

    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
        HttpClient hc = <span class="keyword">new</span> DefaultHttpClient();
        HttpGet hg = <span class="keyword">new</span> HttpGet(<span class="string">"http://www.oschina.net/img/logo.gif"</span>);
        <span class="keyword">final</span> Bitmap bm;

        <span class="keyword">try</span> {
            HttpResponse hr = hc.execute(hg);
            bm = BitmapFactory.decodeStream(hr.getEntity().getContent());
        } <span class="keyword">catch</span> (Exception e) { 
            mHandler.obtainMessage(MSG_FAILURE).sendToTarget();     
            <span class="keyword">return</span>;
        }
        <span class="comment">// Handler发送消息可以new但是最好使用obtainMessage，因为Message内部</span>
        <span class="comment">// 通过next实现一个缓存消息链表,使用obtain方法获取Message使用完之后系统</span>
        <span class="comment">// 会调用recycle方法进行回收，节省内存</span>
        mHandler.obtainMessage(MSG_SUCCESS,bm).sendToTarget();
        }
};

<span class="keyword">new</span> Thread(runnable).start();                        
</code></pre></li>
<li><p><strong>子线程中Handler结合Looper处理其他线程发送过来的消息实例</strong></p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">LooperThread</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Thread</span> {</span>
      public <span class="type">Handler</span> mHandler;
      public void run() {
             <span class="type">Looper</span>.prepare();

             mHandler = <span class="keyword">new</span> <span class="type">Handler</span>() {
                      public void handleMessage(<span class="type">Message</span> msg) {

                      }                                                                                                                                                                                                                     };

             <span class="type">Looper</span>.loop();

      }
}
</code></pre></li>
<li><p>一个线程只能拥有一个Looper实例(该Looper对象可以通过Looper.myLooper()来获取)，对应着一个MessageQueue消息队列，但是可以拥有多个Handler; 主线程初始化时默认创建一个Looper对象，可以通过Looper.getMainLooper()来获取他；</p>
</li>
<li>主线程中可以直接新建Handler，但是子线程中新建Handler需要先调用Looper.prepare()</li>
<li>消息队列其实内部实现是一个管道通信机制，当队列为空时线程进入等待状态，不为空时才进入处理消息状态；enqueueMessage方法也分为2种情况，队列为空直接将新message添加到队列头部，否则需要将消息按照时间先后顺序插入到合适位置，因为消息要按照处理时间排序</li>
<li><p><strong>handler可能引发的内存泄露和解决方案</strong></p>
<ol>
<li>当使用内部类（包括匿名类）来创建Handler的时候，Handler对象会隐式地持有一个外部类对象（通常是一个Activity）的引用。而Handler通常会伴随着一个耗时的后台线程一起出现，这个后台线程在任务执行完毕之后，通过消息机制通知Handler，然后Handler把消息发送到UI线程。然而，如果用户在耗时线程执行过程中关闭了Activity（正常情况下Activity不再被使用，它就有可能在GC检查时被回收掉），由于这时线程尚未执行完，而该线程持有Handler的引用，这个Handler又持有Activity的引用，就导致该Activity暂时无法被回收（即内存泄露）</li>
<li><p>解决方案:</p>
<ul>
<li><p>Handler声明为静态内部类,不再持有外部类Activity,在其内部声明一个Activity的弱引用来操作Activity中的对象</p>
<pre><code>static <span class="class"><span class="keyword">class</span> <span class="title">TestHandler</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Handler</span> {</span>
    <span class="type">WeakReference</span>&lt;<span class="type">Activity</span> &gt; mActivityReference;

    <span class="type">TestHandler</span>(<span class="type">Activity</span> activity) {
        mActivityReference= <span class="keyword">new</span> <span class="type">WeakReference</span>&lt;<span class="type">Activity</span>&gt;(activity);
    }

    <span class="annotation">@Override</span>
    public void handleMessage(<span class="type">Message</span> msg) {
        <span class="keyword">final</span> <span class="type">Activity</span> activity = mActivityReference.get();
        <span class="keyword">if</span> (activity != <span class="literal">null</span>) {
            mImageView.setImageBitmap(mBitmap);
        }
    }
}
</code></pre></li>
<li><p>①在关闭Activity的时候停掉你的后台线程。线程停掉了，就相当于切断了Handler和外部连接的线，Activity自然会在合适的时候被回收；②如果你的Handler是被delay的Message持有了引用，那么使用相应的Handler的removeCallbacks()方法，把消息对象从消息队列移除        </p>
</li>
</ul>
</li>
</ol>
</li>
<li><strong>HandlerThread</strong>是一个Looper,Handler,Thread的组合实现；在其构造函数中对Looper进行初始化，并提供一个Looper对象给新创建的Handler对象，使得Handler处理消息事件在子线程中处理</li>
</ul>
</li>
</ol>

      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="../../tags/Android/"> #Android </a>
          
        </div>
      

      

      
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              实习项目总结
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2015-04-08
        </span>

        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="../../2015/04/08/实习项目总结/#comments">
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/04/08/实习项目总结/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        <h3 id="自我介绍_1min_慢，停顿">自我介绍 1min 慢，停顿</h3><ol>
<li>姓名 —-&gt; 学习经历(中大科大软件专业) 基于兴趣和职业规划 —-&gt; 本科到硕士都注重计算机基础知识积累，对Java语言基础，计算机网络/MySQL数据库原理，常见数据结构和算法比较熟悉，例如常见排序，链表，二叉树，队列栈等；平常对移动端和web端研发也具有浓厚兴趣</li>
<li>一直以来也比较注重实践，陆续参加了几个实习和项目，提现学习和工作能力(先后参与3份实习和2个校内科研项目，选择与岗位相符的两段经历进行1-2句话简述，做了什么和达到了什么成就) </li>
<li>业余爱好，羽毛球，健身，阅读和利用coursera进行业余学习</li>
<li>对目标岗位的理解和想法，应聘该岗位的强烈意愿以及自身吻合度</li>
<li>经历：前期社会活动兴趣的广泛性+后期对专业的专注性；性格：程序员中的外向型</li>
</ol>
<h3 id="网易">网易</h3><ol>
<li>学习Spring框架使用和原理</li>
<li>接口实现</li>
<li>网易实习时有挑战性的地方以及，最大的贡献<ul>
<li>自己扮演的角色应该是<strong>需求开发者和主动学习者的角色</strong> ①快速学习能力的体现以及快速学习的方法，学习使用redis，Spring框架开发restful 数据接口②沟通与合作：与产品，前端，测试之间分工合作②贡献818的部分核心需求，开奖时服务端通过张连接WebSocket主动推送给app开奖信息；设置一个观察者观察开奖数据；然后查表中未中奖用户的信息进行推送</li>
</ul>
</li>
</ol>
<h3 id="Kactus">Kactus</h3><ol>
<li>ECO餐厅食用油回收系统<ul>
<li>Android端缓存机制的实现，采用二级缓存，LRUcache内存缓存和DiskLruCache文件缓存，同时模拟浏览器缓存机制来分析http请求过程的请求头内容来确定cache-control策略<ol>
<li><strong>App请求server数据流程</strong>: 当我们第一次打开应用获取图片时，先到网络去下载图片，然后依次存入内存缓存，磁盘缓存;以后每次加载图片的时候都优先去LRUCache内存缓存当中读取，当读取不到的时候则回去DiskLruCache硬盘缓存中读取，而如果硬盘缓存仍然读取不到的话，就从网络上请求原始数据。</li>
<li><strong>App的二级缓存实现</strong>: 变化频繁的小数据(例如订单列表)都采用LRUCache,以<url, data="">的键值对形式存储数据, 缓存时间为应用开启到关闭时间段; 稳定的大文件数据(例如图片)采用DiskLruCache,缓存时间可以根据需求自定义;LruCache和DiskLruCache的原理实际上是LinkedHashMap和File;</url,></li>
<li><strong>缓存管理和清理策略</strong>：<ul>
<li>① <strong>现用方法</strong>App根据服务器响应头部里边的expires(缓存过期的时间（绝对时间）),Last-Modified(服务器响应的资源最终修改时间), Cache-Control(资源的有效期)等内容来确定是否需要将数据缓存到DiskLruCache中，以及缓存的保留时间，<strong>具体实现</strong> 每次请求url得到响应结果时会解析头部Cache-Control去判断该响应资源是否需要缓存以及缓存过期时间等内容；然后将资源URL和这些缓存时间相关的http头部信息(比如expires(缓存过期的时间))一起存储到SQLite数据库，然后每次加载资源都会先根据url查询数据库看本地缓存是否过期，是否需要重新发送网络请求并更新缓存        </li>
<li>② <strong>其它方法</strong>每次去读取缓存文件时先调用File.lastModified()方法得到文件的最后修改时间，与当前时间相减得到已缓存时间,然后根据自定义的缓存时间判断该缓存是否过期，如果过期则重新请求文件，不然直接从缓存加载，这样就能实现缓存文件定时清理</li>
<li>③ <strong>每次服务器资源变化时客户端怎么得到通知？</strong>, 客户端定时轮询请求某个指定url并解析返回的json判断某些数据是否变化，变化就重新请求该数据; 或者手动刷新，socket长连接</li>
</ul>
</li>
<li><ul>
<li><strong>FIFO</strong>First In First Out，先进先出;核心原则就是：如果一个数据最先进入缓存中，则应该最早淘汰掉。也就是说，当缓存满的时候，应当把最先进入缓存的数据给淘汰掉。</li>
<li><strong>LFU</strong>：Least Frequently Used，最不经常使用;在一段时间内，数据被使用次数最少的，优先被淘汰。</li>
<li><strong>LRU</strong>: Least Recently Used，最近最少使用策略，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高”；简单的说就是缓存一定量的数据，当超过设定的阈值时就把一些<strong>最近最少使用的数据</strong>删除掉;<strong>最常见的实现算法</strong>是使用一个链表保存缓存数据，①新数据插入到链表头部；②每当缓存命中（即缓存数据被访问），则将数据移到链表头部；③当链表满的时候，将链表尾部的数据丢弃。<a href="https://segmentfault.com/a/1190000003743083" target="_blank" rel="noopener">LRUCache双向链表+HashMap实现</a> <a href="https://segmentfault.com/a/1190000005922083" target="_blank" rel="noopener">LRUCache LinkedHashMap实现</a></li>
<li><strong>LRU-K</strong>中的K代表最近使用的次数，因此LRU可以认为是LRU-1。LRU-K的主要目的是为了解决LRU算法“缓存污染”的问题，其核心思想是将“最近使用过1次”的判断标准扩展为“最近使用过K次”。<strong>实现</strong>：相比LRU，LRU-K需要多维护一个队列，用于记录所有缓存数据被访问的历史。只有当数据的访问次数达到K次的时候，才将数据放入缓存。当需要淘汰数据时，LRU-K会淘汰第K次访问时间距当前时间最大的数据</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ol>
<pre><code>缓存图片举例：


        <span class="comment">// 获取应用可占内存的1/8作为缓存</span>
        <span class="built_in">int</span> maxSize = (<span class="built_in">int</span>) (Runtime.getRuntime().maxMemory() / <span class="number">8</span>);
        <span class="comment">// 实例化LruCaceh对象</span>
        mLruCache = <span class="keyword">new</span> LruCache&lt;<span class="keyword">String</span>, Bitmap&gt;(maxSize) {
            @Override
            <span class="keyword">protected</span> <span class="built_in">int</span> sizeOf(<span class="keyword">String</span> <span class="variable">key</span>, Bitmap bitmap) {
                <span class="keyword">return</span> bitmap.getRowBytes() * bitmap.getHeight();
            }
        };
         mDiskLruCache=DiskLruCache.<span class="built_in">open</span>(getDiskCacheDir(context.getApplicationContext(),
         <span class="string">"xxxxx"</span>),     getAppVersion(context), <span class="number">1</span>, DISKMAXSIZE);
        <span class="comment">// 缓存操作</span>
        mLruCache.<span class="built_in">get</span>(url);
        mLruCache.put(url, bitmap);
        bitmap = BitmapFactory.decodeStream(mDiskLruCache.<span class="built_in">get</span>(url).getInputStream(<span class="number">0</span>));
        DiskLruCache.Editor editor = mDiskLruCache.edit(<span class="variable">key</span>);
        OutputStream outputStream = editor.newOutputStream(<span class="number">0</span>);
        editor.commit();
</code></pre><ol>
<li><p>采用Java WebSocket编程取代传统的非实时http请求连接模式</p>
<ul>
<li><p><strong>为什么要用WebSocket实时交互数据？</strong>: 传统Web应用的信息交互过程通常是客户端发出一个请求，服务器端接收和审核完请求后进行处理并返回结果给客户端，然后客户端浏览器将信息呈现出来，但是对于那些实时要求比较高的应用来说，比如说在线游戏、新闻在线播报、RSS 订阅推送等等，当客户端浏览器准备呈现这些信息的时候，这些信息在服务器端可能已经过时了;所以我们考虑采用webSocket    <strong>常见的模拟实时应用方法</strong> </p>
<p>  <strong>轮询</strong>：最早的一种实现实时 Web 应用的方案。客户端以一定的时间间隔向服务端发出请求，以频繁请求的方式来保持客户端和服务器端的同步。服务器端的数据可能并没有更新但是依然请求，会带来很多无谓的网络传输，所以这是一种非常低效的实时方案。  </p>
<p>  <strong>长轮询</strong>：为了降低无效的网络传输，当服务器端没有数据更新的时候，连接会保持一段时间周期直到数据或状态改变或者时间过期，通过这种机制来减少无效的客户端和服务器间的交互  </p>
<p>  <strong>流</strong>： 流技术方案通常就是在客户端的页面使用一个隐藏的窗口向服务端发出一个长连接的请求。服务器端接到这个请求后作出回应并不断更新连接状态以保证客户端和服务器端的连接不过期。通过这种机制可以将服务器端的信息源源不断地推向客户端。这种机制需要针对不同的浏览器设计不同的方案来改进用户体验，同时这种机制在并发比较大的情况下，对服务器端的资源是一个极大的考验。</p>
<p>  <strong>WebSocket原理和建立过程</strong>: WebSocket是一个基于TCP连接的双向通道；为了建立一个 WebSocket 连接，客户端浏览器首先要向服务器发起一个 HTTP 请求，这个请求和通常的 HTTP 请求不同，包含了一些附加头信息，其中附加头信息”Upgrade: WebSocket”表明这是一个申请协议升级的 HTTP 请求，服务器端解析这些附加的头信息然后产生应答信息返回给客户端，客户端和服务器端的 WebSocket 连接就建立起来了，双方就可以通过这个连接通道自由的传递信息，并且这个连接会持续存在直到客户端或者服务器端的某一方主动的关闭连接。    </p>
<pre><code><span class="annotation">@ServerEndpoint</span>(<span class="string">"/websocket"</span>)
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSocketTest</span> </span>{

  <span class="annotation">@OnMessage</span>
  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(String message, Session session)</span>
    <span class="keyword">throws</span> IOException, InterruptedException </span>{

    System.out.println(<span class="string">"Received: "</span> + message);

    <span class="comment">// Send the first message to the client</span>
    session.getBasicRemote().sendText(<span class="string">"This is the first server message"</span>);

    <span class="comment">// Send 3 messages to the client every 5 seconds</span>
    <span class="keyword">int</span> sentMessages = <span class="number">0</span>;
    <span class="keyword">while</span>(sentMessages &lt; <span class="number">3</span>){
      Thread.sleep(<span class="number">5000</span>);
      session.getBasicRemote().
        sendText(<span class="string">"This is an intermediate server message. Count: "</span>
          + sentMessages);
      sentMessages++;
    }

    <span class="comment">// Send a final message to the client</span>
    session.getBasicRemote().sendText(<span class="string">"This is the last server message"</span>);
  }

  <span class="annotation">@OnOpen</span>
  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onOpen</span><span class="params">()</span> </span>{
    System.out.println(<span class="string">"Client connected"</span>);
  }

  <span class="annotation">@OnClose</span>
  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClose</span><span class="params">()</span> </span>{
    System.out.println(<span class="string">"Connection closed"</span>);
  }

}
</code></pre><p>  <strong>如何使用Encoder和Decoder传输更复杂的数据</strong>：Websocket使用Decoder将文本消息转换成Java对象，然后传给@OnMessage方法处理; 而当对象写入到session中时，Websocket将使用Encoder将Java对象转换成文本，再发送给客户端。</p>
</li>
<li><p>整个项目从简单的多线程优化到采用线程池来实现xml数据文件的获取</p>
</li>
<li>总体项目图<br><img src="https://raw.githubusercontent.com/Charles-Xiao/Charles-Xiao.github.io/master/images/kactus项目.JPG" width="100%"></li>
</ul>
</li>
</ol>
<h3 id="Baidu">Baidu</h3><ol>
<li><p>Duwear项目短信管理模块: 目的是将手机短信库的变化情况通知到wear端</p>
<ol>
<li><strong>SMSObserver</strong>继承ContentProvider类实现观察者模式，注册了一个短信数据库的观察者，发生变化该类都会被通知；在重载函数onChange中进行操作比对判断数据库变化情况，只知道变化，但是不知道具体操作？如何判断用户是标为已读还是删除，新建短信</li>
<li><strong>SmsReceivedListener接口</strong>：两个回调函数，作为一个接口参数传到SMSObserver的构造函数中，然后一旦判断是新短信还是短信已读，就调用其回调函数</li>
<li><strong>SmsRpcService类</strong>：继承自上边的接口，在回调函数中将这个操作判断出来发送给手表</li>
<li><strong>SmsUtils</strong>: 4个函数，查询短信数据库，标为已读的数据库操作函数</li>
<li><p>SMSObserver类中的具体的判断方式和优化过程</p>
<ul>
<li>从维护所有信息的set到只维护未读信息的内容，信息实体占用内存很大，内存优化；</li>
<li><p>ArrayList到HashSet对比与区别：防止出现重复信息，去重速度很快因为使用HashTable中的hashCode()以及equals进行查找去重；</p>
</li>
<li><p>多次读取unreadSet并对两个set进行比对，removeAll和AddAll求补集并集来比对两个未读信息集合;两个方法都用到了hashCode和equals，所以SmsEntity对象中hashcode和equals方法的同时重载；直接removeAll新set可以判断出哪些信息被标为已读，AddAll新set再removeAll旧set可以判断得到新增加的短信；比如1，2，3和1，2，4，5</p>
</li>
<li><p><strong>java集合中的浅复制和深复制，clone集合不影响原集合</strong></p>
<ol>
<li><p><strong>浅复制</strong>: 复制后的对象与原对象所有变量的值相同，包括引用变量，浅复制时只会复制引用变量本身，不会复制它指向的对象本身</p>
</li>
<li><p><strong>深复制</strong>: 复制后的对象与原对象所有变量的值相同，但是不包括引用变量，深复制时会复制引用变量指向的对象本身，所以引用值发生改变</p>
</li>
<li><p><strong>Clone()方法和Cloneable接口</strong>: Cloneable接口是一个不包含方法的标志接口，一个类必须先继承它才能在其内部调用super.clone()方法，否则会抛出不支持clone的异常;clone()方法是一个native方法，拷贝对象时已经包括一部分原对象信息，效率优于使用新建对象再一一复制变量的方式;重写clone()方法需要先调用super.clone()方法，该方法会开辟一块新的内存用于拷贝原对象，将原对象的内容一一复制到新对象的内存空间中，它是一种浅复制;如果要实现深复制，需要对复制的对象中的所有引用变量对应的对象也进行复制(具体操作:重写引用对象的clone方法，在其中调用super.clone，然后在上层对象的重载clone方法中调用该对象的clone方法)</p>
</li>
<li><p><strong>序列化实现深复制</strong>: 序列化主要用于将内存中对象状态写入数据库或者文件，以及利用Socket在网络中传输对象;一个对象要能够被序列化需要该类实现Serializable接口，可序列化类的子类默认也是可以被序列化的，不需要再次实现Serializable接口；利用序列化进行深复制的前提是该对象及其内部的引用到的对象都是可序列化的，这样对对象序列化时才能递归地保存对象及其引用对象的数据</p>
<pre><code>deepClone() {    
   <span class="comment">//序列化:将内存中对象状态转化为字节流，写入目标输出流</span>
   ByteArrayOutoutStream bo=<span class="keyword">new</span> ByteArrayOutputStream();    
   ObjectOutputStream oo=<span class="keyword">new</span> ObjectOutputStream(bo);
   <span class="comment">//    </span>
   oo.writeObject(<span class="keyword">this</span>);    
   <span class="comment">//反序列化:读取源输入流中的字节流重建一个内存中相同状态的对象     </span>
   ByteArrayInputStream bi=<span class="keyword">new</span> ByteArrayInputStream(bo.toByteArray());    
   ObjectInputStream oi=<span class="keyword">new</span> ObjectInputStream(bi);    
   <span class="keyword">return</span>(oi.readObject());    
}
</code></pre></li>
<li><p>当一个类声明要实现Serializable接口时，只是表明该类参加序列化协议;Java提供的ObjectInputStream和ObjectOutputStream将数据流功能扩展至可读写对象 。在ObjectInputStream中用readObject()方法可以直接读取一个对象，ObjectOutputStream中用writeObject()方法可以直接将对象保存到输出流中; 序列化只能保存对象的非静态成员变量，不能保存任何的成员方法和静态成员变量，而且序列化保存的只是变量的值，对于变量的任何修饰符都不能保存。          </p>
</li>
</ol>
</li>
</ul>
</li>
<li><strong>工厂模式</strong>生产手表View：需要生成许多不同的CardView，利用CardFactory中的BuildPage函数<ul>
<li>简单工厂模式:工程类+抽象产品类+具体产品类；根据参数的不同返回不同类的实例。专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类</li>
<li>工厂方法模式: 抽象产品角色，具体产品角色，抽象工厂角色，具体工厂角色;工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类;一个抽象产品类，可以派生出多个具体产品类。一个抽象工厂类，可以派生出多个具体工厂类。每个具体工厂类只能创建一个具体产品类的实例。</li>
<li>抽象工厂模式: 多个抽象产品类，每个抽象产品类可以派生出多个具体产品类。一个抽象工厂类，可以派生出多个具体工厂类。每个具体工厂类可以创建多个具体产品类的实例。</li>
</ul>
</li>
</ol>
</li>
<li><p>百度锁屏项目: <a href="https://charles-xiao.github.io/2016/05/18/Android%E8%87%AA%E5%AE%9A%E4%B9%89View%E5%AE%9E%E7%8E%B0%E6%80%BB%E7%BB%93-%E4%BB%A5%E7%99%BE%E5%BA%A6%E9%94%81%E5%B1%8F%E9%A1%B9%E7%9B%AE%E7%95%8C%E9%9D%A2%E4%B8%BA%E4%BE%8B/">View的自定义绘制与组合原理过程</a></p>
</li>
</ol>
<ol>
<li><p><strong>网络通信的优化和实现过程</strong>http从同步的主线程发送get请求优化为异步的子线程发送post请求, 加强了数据传输的安全性和长度，解决了应用程序无响应的应用体验问题; httpClient和HttpUrlConnection的区别对比;最后学习和使用Volley以及OkHttp通信库<br><a href="http://www.jianshu.com/p/3141d4e46240#Volley&amp;OkHttp" target="_blank" rel="noopener">参考链接</a></p>
<ol>
<li><p>异步的get和post请求实现过程(HttpUrlConnection)</p>
</li>
<li><p><strong>httpClient和httpUrlConnection, OKHttp对比</strong>：</p>
<ul>
<li>httpClient是apache的开源实现，API数量多，非常稳定</li>
<li>httpUrlConnection是java自带的模块: ①可以直接支持GZIP压缩,而HttpClient虽然也支持GZIP，但要自己写代码处理 ②httpUrlConnection直接在系统层面做了缓存策略处理，加快重复请求的速度 ③API简单，体积较小,而且直接支持系统级连接池，即打开的连接不会直接关闭，在一段时间内所有程序可共用</li>
<li>HttpURLConnection在Android2.2之前有个重大Bug，调用close()函数会影响连接池，导致连接复用失效，需要关闭keepAlive;因此在2.2之前http请求都是用httpClient，2.2之后则是使用HttpURLConnection</li>
<li>但是!!!现在!!!Android不再推荐这两种方式！二是直接使用OKHttp这种成熟方案！支持Android 2.3及其以上版本; 什么是OKHttp?</li>
</ul>
</li>
<li><strong>Volley原理和OkHttp实现原理和应用方法以及优缺点</strong> <ul>
<li><strong>Volley的调用过程</strong>，通过 newRequestQueue(…) 函数新建并启动一个请求队列RequestQueue后，只需要往这个RequestQueue不断 add Request 即可</li>
<li><strong>Volley</strong>：Volley 对外暴露的 API，通过 newRequestQueue(…) 函数新建并启动一个请求队列RequestQueue。</li>
<li><strong>Request</strong>：表示一个请求的抽象类。StringRequest、JsonRequest、ImageRequest 都是它的子类，表示某种类型的请求。</li>
<li><strong>RequestQueue</strong>：表示请求队列，里面包含一个CacheDispatcher(用于处理走缓存请求的调度线程)、NetworkDispatcher数组(用于处理走网络请求的调度线程)，一个ResponseDelivery(返回结果分发接口)，通过 start() 函数启动时会启动CacheDispatcher和NetworkDispatchers。        </li>
<li><strong>HttpStack</strong>：处理 Http 请求，返回请求结果。目前 Volley 中有基于 HttpURLConnection 的HurlStack和 基于 Apache HttpClient 的HttpClientStack，也可以内部采用OKHttp实现 </li>
<li><strong>CacheDispatcher.java</strong>：继承自Thread，用于调度处理「缓存请求」。启动后会不断从缓存请求队列中取请求处理，队列为空则等待，请求处理结束则将结果传递给ResponseDelivery去执行后续处理。当结果未缓存过、缓存失效或缓存需要刷新的情况下，该请求都需要重新进入NetworkDispatcher去调度处理。</li>
<li><strong>NetworkDispatcher.java</strong>：继承自Thread，用于调度处理「网络请求」。启动后会不断从网络请求队列中取请求处理，队列为空则等待，请求处理结束则将结果传递给ResponseDelivery去执行后续处理，并判断结果是否要进行缓存。 </li>
</ul>
</li>
</ol>
<ul>
<li><p><strong>Volley与Activity生命周期联动与取消请求</strong>:为了在Activity退出或销毁的时候，取消对应的网络请求，避免网络请求在后台浪费资源；我们使用Volley的话，可以在Activity停止的时候，同时取消所有或部分未完成的网络请求，这些请求将不会被返回给主线程，取消操作一般在onStop()函数里边执行</p>
<pre><code> <span class="comment">// 遍历整个Activity中的请求集合，例如List</span>
 <span class="keyword">for</span> (Request &lt;?&gt; req : mRequestQueue) {  
    req.cancel();  
}
<span class="comment">// 取消整个队列中的请求 </span>
mRequestQueue.cancelAll(<span class="keyword">this</span>);
<span class="comment">// 根据RequestFilter或者Tag来终止某些请求</span>
mRequestQueue.cancelAll( <span class="keyword">new</span> RequestFilter() {});    
mRequestQueue.cancelAll(<span class="keyword">new</span> <span class="built_in">Object</span>());
</code></pre></li>
<li><p><strong>流程图解</strong>：<br>  第一步：主线程根据优先级把请求加入缓存队列<br>  第二步：「缓存调度线程」CacheDispatcher从缓存队列中取出一个请求，如果缓存命中，就读取缓存响应并解析，然后将结果返回到主线程<br>  第三步：缓存未命中，该请求被加入网络请求队列，「网络调度线程」NetworkDispatcher(一个默认值为4的线程池)从网络队列中轮询取出请求，进行HTTP请求传输，解析响应，写入缓存，然后将结果返回到主线程  </p>
<p><img src="https://raw.githubusercontent.com/Charles-Xiao/Charles-Xiao.github.io/master/images/Volley.png" class="full-image" width="100%">    </p>
<p><a href="http://a.codekk.com/detail/Android/grumoon/Volley%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90" target="_blank" rel="noopener">Volley源码分析</a></p>
<p><strong>Volley用法</strong>  </p>
<pre><code> RequestQueue mQueue <span class="subst">=</span> Volley<span class="built_in">.</span>newRequestQueue(context);
 StringRequest stringRequest <span class="subst">=</span> <span class="literal">new</span> StringRequest
 (Method<span class="built_in">.</span>POST, <span class="string">"http://www.baidu.com"</span>,  
<span class="literal">new</span> Response<span class="built_in">.</span>Listener<span class="subst">&lt;</span><span class="built_in">String</span><span class="subst">&gt;</span>() {  
    @Override  
    <span class="keyword">public</span> <span class="literal">void</span> onResponse(<span class="built_in">String</span> response) {  
        <span class="keyword">Log</span><span class="built_in">.</span>d(<span class="string">"TAG"</span>, response);  
    }  
}, <span class="literal">new</span> Response<span class="built_in">.</span>ErrorListener() {  
    @Override  
    <span class="keyword">public</span> <span class="literal">void</span> onErrorResponse(VolleyError error) {  
        <span class="keyword">Log</span><span class="built_in">.</span>e(<span class="string">"TAG"</span>, error<span class="built_in">.</span>getMessage(), error);  
    }  
}){
@Override  
 <span class="keyword">protected</span> <span class="built_in">Map</span><span class="subst">&lt;</span><span class="built_in">String</span>, <span class="built_in">String</span><span class="subst">&gt;</span> getParams() throws AuthFailureError {  
     <span class="built_in">Map</span><span class="subst">&lt;</span><span class="built_in">String</span>, <span class="built_in">String</span><span class="subst">&gt;</span> <span class="built_in">map</span> <span class="subst">=</span> <span class="literal">new</span> HashMap<span class="subst">&lt;</span><span class="built_in">String</span>, <span class="built_in">String</span><span class="subst">&gt;</span>();  
     <span class="built_in">map</span><span class="built_in">.</span>put(<span class="string">"params1"</span>, <span class="string">"value1"</span>);  
     <span class="built_in">map</span><span class="built_in">.</span>put(<span class="string">"params2"</span>, <span class="string">"value2"</span>);  
     <span class="keyword">return</span> <span class="built_in">map</span>;  
 }  
}; 
 mQueue<span class="built_in">.</span>add(stringRequest); 
</code></pre></li>
</ul>
</li>
</ol>
<p><strong>OkHttp用法</strong><a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0326/2643.html" target="_blank" rel="noopener">源码分析</a></p>
<p><img src="https://raw.githubusercontent.com/Charles-Xiao/Charles-Xiao.github.io/master/images/OkHttp.png" class="full-image"></p>
<pre><code>OkHttpClient mOkHttpClient = <span class="keyword">new</span> OkHttpClient();
FormEncodingBuilder builder = <span class="keyword">new</span> FormEncodingBuilder();   
builder.add(<span class="string">"username"</span>,<span class="string">"value"</span>);

Request request = <span class="keyword">new</span> Request.Builder()
                   .url(url)
                .post(builder.build())
                .build();
mOkHttpClient.newCall(request).enqueue(<span class="keyword">new</span> Callback(){
    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Request request, IOException e)</span>
    </span>{
    }

    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(<span class="keyword">final</span> Response response)</span> <span class="keyword">throws</span> IOException
    </span>{
            <span class="comment">//String htmlStr =  response.body().string();</span>
    }
});
</code></pre><h3 id="毕设-WebCrawler项目">毕设-WebCrawler项目</h3><p>java优先级队列；Java多线程处理，线程池，html页面解析等</p>
<p>单例模式enum实现对MySQL数据库操作的优势</p>
<h3 id="开放性问题">开放性问题</h3><ol>
<li>说一个你曾独立或者作为核心去解决了的一个“有趣有难度”且过程很详细的步步深入优化的<strong>技术问题or项目</strong><ul>
<li>贡献和成果: 核心问题的效率优化过程与方法</li>
<li>困难:体现解决问题的方法与能力</li>
<li><strong>思路</strong>：如果说有趣有难度的项目的话，我想说说kactus的食用油回收项目；在这个项目中参与时间长达半年，技术成长较大；<strong>这个项目主要是用来开发</strong>一个后台管理系统和Android app，包括司机和经理，用于订单处理和发布；在这个项目中，<strong>我参与了整个项目的研发</strong>，包括3个主要部分，①通过Java http和WebSocket请求订单数据，利用生产者消费者模式和多线程池提高并发读写效率 ②操作数据库制作RESTful API给移动端app使用 ③移动端app的开发以及二级缓存的优化实现</li>
</ul>
</li>
<li><strong>成就感最大的一件事</strong>: 比如学习,比赛,需要体现<strong>创新性的成果和idea</strong>：高德LBS的比赛全国八强，做了什么？为什么有成就感？从日常生活出发想出一个创新的idea，然后结合课程理论进行实践，到最后拿奖这样一个过程。</li>
<li>团队合作沟通能力和Team领导力</li>
<li><p><strong>如何白板写代码？？？</strong></p>
<ul>
<li>Show your idea,，例如白板写代码，遇到新问题即使不知道也可以开始分析，手动画图描述问题的解决过程，从思路到设计测试用例手动输入，一步步归纳出最终解法，转化成代码</li>
<li>解决问题的多角度性，从小问题和具体性问题开始入手，一步步递进归纳算法；遇到细节性或者较难实现的问题，可以先声明一个函数及其相应功能，留到后边再完善，代码效率的优化同样可以放到后边再做，思路的流畅性和清晰很重要。</li>
<li>主动单元测试，边缘情况测试，null，空字符串，StringUtils.isBlank(str)</li>
</ul>
</li>
<li><p>遇到生活学习上的<strong>印象中最大的困难或者挫折</strong>？最后怎么解决的？</p>
<ul>
<li>留学的DIY过程是一个比较困难的过程。为什么？绝大多数人会选择找中介，会省事很多，整个流程和材料的准备都不需要自己动手，但是我选择了自己DIY，所以在这一路的申请过程中遇到不少的挫折和困难，①对于留学的讯息了解不够 , ②准备考雅思 ③文书材料的撰写和修改；</li>
<li>最终这一路申请过程中虽然遇到各种困难，但是最终还是受益颇多，其实我本来自己DIY的原因就是我自己觉得申请过程其实是一次很好的审视自我的过程，也为我自己才是最了解我自己的人；不管结果如何，申请这个过程就是一段很好的人生经历，虽然遇到各种困难，但是一一克服，最终也有了一个比较好的结果，拿到了几家不错的offer</li>
</ul>
</li>
<li><p><strong>最大缺点</strong>: 这个问题好难回答啊！我想想……</p>
<pre><code><span class="bullet">* </span>我的缺点是比较专注和执着，比如在技术方面比较爱钻研，有的时候会为了研究一个技术问题，不断地沉浸在里边，不弄明白不罢休，到饭点了都能忘，晚上在公司研究到很晚才撤退。最近出的那个电脑端和手机端同步功能就很好，可以利用零碎时间看博客解决问题了
<span class="bullet">* </span>还有就是，工作比较按部就班，总是按照项目经管的要求完成任务。另外的缺点是，总在息的工作范围内有创新意识，并没有扩展给其他同事。这些问题我想我可以进入公司后以最短的时间来解决，我的学习能力很强，我相信可以很快融入公司的企业文化，进入工作状态。我想就这些吧。
</code></pre></li>
<li><strong>最大的特点或者优势</strong>：基础知识+创新能力</li>
<li><strong>最感兴趣的课程</strong> 本科阶段的话，最感兴趣的是移动端开发，</li>
<li><strong>最感兴趣的运动或者业余爱好，长期坚持的爱好</strong>: 羽毛球，吉他</li>
<li><strong>性格特征</strong><ul>
<li><strong>对感兴趣的技术会在业余时间去主动学习</strong>，刷刷coursera学习普林斯顿的算法课程学习常见算法堆排，买机器学习的书学KNN, 决策树 mapreduce相关知识</li>
<li><strong>学习和做工程时愿意深入了解和钻研，多问为什么？</strong>例如做Kactus的回收油系统，从做移动端应用开发，我就会去考虑我拿的数据怎么来的，所以就会自己写程序去拿数据，拿到数据存到数据库，怎么做API把数据给移动端用，也自己做了，还会主动考虑着怎么去优化客户端体验，做二级缓存，怎么并行化收发数据来提高效率，怎么比较不同的http库去提高网络请求效率</li>
<li><strong>能够发现生活细节，主动去发现问题，提出想法</strong>:比如高德项目，项目来源就是出去旅游发现人文景点不知道典故不好玩，看到有导游，怎么不用手机APP来做？，当时也有一些其他想法，比如运动分享记录APP</li>
<li><strong>程序员中的外向者，善于与人交流沟通和参与社会活动</strong>从本科阶段的支教，社会调研等社会活动可以看出来</li>
</ul>
</li>
<li><strong>三个词形容自己</strong>：专注深入，发现问题(细心)，淡定(有耐心的解决问题)</li>
<li><strong>职业规划</strong>: ：我希望从现在开始，1-2年之内能够在我目前的这个职位上沉淀下来，通过不断的努力后，最好能有晋升，希望3-5年内可以通过在现有的开发岗位上的不断学习和历练，基于现在的项目和平台，包括现在项目所提供的数据背景，条件，能够培养自己的大局观，逐步地从开发到架构，提升自己的业务水平</li>
<li>对比一下网易和百度的不同？整体的规范性，团队年轻，沟通非常顺利</li>
<li><strong>这么多实习过程中最大的收获？</strong>①将理论和实践相结合的机会，了解到为什么学理论，并将学到的付诸于实践，做出真正可用的给成千上万的用户带去便利的产品，是件很有成就感的事情②大公司的开发规范和流程</li>
<li><strong>为什么来北京？</strong>一方面是因为北京互联网工作机会多，类似于BAT之类的好公司好平台都在北京，是一个增长见识，锻炼自我的环境；二. 最优秀的人也在北京，在这样一个充满竞争的平台里，把握机会，成就自我。</li>
<li><strong>你对薪资的要求？</strong>关于薪资的话，我个人倒是没有什么特别的要求，首先，我觉得公司提供的平台和成长更为重要，我会更加关注在这个良好的平台带来的自我能力的提升，这个才是比较长远的；另外，我也相信XX作为一家知名公司，在薪酬待遇上肯定不会差，而且校招也有一个合理的市场offer价格，如果公司对我的能力认同的话，肯定能协商出一个双方满意的offer待遇</li>
<li><strong>如果公司录用你，你将怎样融入新团队开展工作？</strong>作为一个开发工程师而言，进入一个新的工作环境，参与一个新的产品项目我想我首先要积极融入团队，不管是生活上还是工作上，积极主动的沟通才能让我更快地了解整个团队，整个项目，多提问，多思考才能快速进步；然后要对部门的主营业务要有一个了解，了解公司的业务组成部分、业务的发展方向。第二了解我参与项目的开发方式，开发技术栈，架构方式，尽快投入具体的开发工作中。</li>
<li>加入新团队的挑战？你怎么融入？？？新的大模块的从无到有的项目接手的挑战；融入初期的担忧；技术的全局了解和深入快速学习；和团队人员之间的磨合，怎么磨合？</li>
<li>对公司的了解如何？希望获得什么？看中技术沉淀和业务前景；加班多么？压力大么？</li>
</ol>
<h3 id="Tips">Tips</h3><ol>
<li>面试时不要有“我记得 我认为 应该”，可以说我回想一下！一定要慢！声音大！有停顿！</li>
<li>不要说自己的工作简单！！！应该说自己快速高效完成，游刃有余，还能挤出时间自学；这是一个有难度的工作</li>
<li>压力面试时一定要淡定，即使不会也要有自信，有条不紊的回答问题，遭受质疑时要有理有据地说出自己的观点和自己知道的内容，并主动询问面试官的建议</li>
<li>记得问问题。</li>
</ol>
<h3 id="QA">QA</h3><ol>
<li><p>如果在贵司移动开发部门做开发，主要是做哪些产品研发以及需要用到哪些技术知识和基础，我需要在哪些方面进行努力</p>
</li>
<li><p>面试过程中有没有什么地方讲得太快或者不清楚的地方，我可以补充的</p>
</li>
<li><p>如果可以，可否评价一下面试表现，提供一下您的建议和看法</p>
</li>
<li><p>跨平台应用研发，web轻应用和native app的开发前景比较看法</p>
</li>
<li><p>他们做什么业务，用些什么技术，希望面试者具备哪些方面的能力，对于做这个方向的人有什么建议，觉得我在技术上有什么优点和不足这种</p>
</li>
</ol>

      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="../../tags/实习/"> #实习 </a>
          
            <a href="../../tags/项目/"> #项目 </a>
          
        </div>
      

      

      
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              计算机网络基础知识
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2015-03-10
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分类于
            
              <a href="../../categories/编程知识/">编程知识</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="../../2015/03/10/计算机网络基础知识/#comments">
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/03/10/计算机网络基础知识/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        <h2 id="OSI分层模型">OSI分层模型</h2><p><img src="https://raw.githubusercontent.com/Charles-Xiao/Charles-Xiao.github.io/master/images/OSI.png" class="full-image" width="100%"></p>
<h2 id="TCP/IP四层参考模型">TCP/IP四层参考模型</h2><p><a href="http://www.cnblogs.com/BlueTzar/articles/811160.html" target="_blank" rel="noopener">TCP/IP四层参考模型，每一层对应的协议， TCP/IP报文格式，UDP和TCP数据段格式，IP头部（报头）格式以及各字段含义，TCP头部结构,套接字</a></p>
<h2 id="Http/Https/UDP/TCP/Socket区别与联系">Http/Https/UDP/TCP/Socket区别与联系</h2><p><img src="https://raw.githubusercontent.com/Charles-Xiao/Charles-Xiao.github.io/master/images/http0.png" class="full-image" width="100%"></p>
<h2 id="TCP协议">TCP协议</h2><h3 id="TCP报文Header">TCP报文Header</h3><p><img src="https://raw.githubusercontent.com/Charles-Xiao/Charles-Xiao.github.io/master/images/TCP-header.jpg" class="full-image" width="100%"></p>
<ol>
<li><strong>ACK</strong> ：TCP协议规定，只有ACK=1时有效，也规定连接建立后所有发送的报文的ACK必须为1</li>
<li><strong>SYN(SYNchronization)</strong> ： 在连接建立时用来同步序号。当SYN=1而ACK=0时，表明这是一个连接请求报文。对方若同意建立连接，则应在响应报文中使SYN=1和ACK=1. 因此,  SYN置1就表示这是一个连接请求或连接接受报文。</li>
<li><strong>FIN （finis）</strong>即完，终结的意思，用来释放一个连接。当 FIN = 1 时，表明此报文段的发送方的数据已经发送完毕，并要求释放连接。</li>
</ol>
<h3 id="TCP协议中的三次握手和四次挥手"><a href="http://blog.csdn.net/oney139/article/details/8103223" target="_blank" rel="noopener">TCP协议中的三次握手和四次挥手</a></h3><ol>
<li><p><strong>TCP三次握手</strong>：实质是client和server之间的报文段交换过程，三次握手之后client和server之间才能相互发送包含数据的报文段</p>
<ul>
<li><strong>第一次握手</strong>：客户端发送一个SYN报文段(该报文段头部SYN标志位=1, ACK标志位=0,起始序号seq=x)到服务器进行连接请求，等待服务器回复确认；此时客户端进入SYN_SENT状态</li>
<li><strong>第二次握手</strong>：服务器收到客户端发送的连接请求报文段之后,给这个TCP连接分配TCP缓存和变量等资源，并回复一个允许连接的确认报文段叫做SYNACK报文段(SYN=1,ACK=1,seq=y，确认号ack=x+1)，此时服务器进入SYN_RECV状态</li>
<li><strong>第三次握手</strong>：客户端收到服务器的SYNACK报文段之后，也给这个TCP连接分配TCP缓存和变量等资源，并向服务器发送确认ACK报文段(ack=y+1，ACK=1,seq=x+1)，发送完毕之后客户端和服务器进入ESTABLISHED状态，完成三次握手</li>
<li><strong>如图所示</strong>：<br><img src="https://raw.githubusercontent.com/Charles-Xiao/Charles-Xiao.github.io/master/images/TCP3.jpg" class="full-image" width="100%"></li>
</ul>
</li>
<li><p><strong>TCP四次挥手</strong>：实质是client和server之间的报文段交换过程,TCP是全双工模式需要client和server双方各自关闭,比如server接收到client发来的FIN报文段时只意味client将没有数据再发来，但是自己还是可以继续发送数据，client不能发送数据但是依旧可以接收数据。</p>
<p> <img src="https://raw.githubusercontent.com/Charles-Xiao/Charles-Xiao.github.io/master/images/TCP4.jpg" class="full-image" width="100%"></p>
</li>
<li><p><strong>相关问题</strong>：</p>
<ul>
<li><strong>为什么连接的时候是三次握手，关闭的时候却是四次握手？</strong><br>答：因为在三次握手时，当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文，其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手</li>
<li><strong>为什么需要三次握手而不是两次，客户端为什么最后还要发送一次确认？</strong><br>答：主要目的是为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误；<strong>例如</strong>：当client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段，但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。</li>
<li><strong>为什么需要图中的起始序号seq=x是一个随机值？</strong><br>答：采用随机产生的初始化序列号进行请求，这样做主要是出于网络安全的因素着想；如果不是随机产生初始序列号，黑客将会以很容易的方式获取到你与其他主机之间通信的初始化序列号，并且伪造序列号进行攻击，这已经成为一种很常见的网络攻击手段</li>
<li><strong>为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？</strong><br>答：虽然按道理，四次握手之后四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假设网络是不可靠的，有可能最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文</li>
</ul>
</li>
</ol>
<h3 id="TCP流量控制和拥塞控制"><a href="http://blog.csdn.net/yechaodechuntian/article/details/25429143" target="_blank" rel="noopener">TCP流量控制和拥塞控制</a></h3><h3 id="发展历程">发展历程</h3><ol>
<li>最开始的TCP拥塞控制由“慢启动（slow start）”和“拥塞避免（congestion avoidance）”组成；后来TCP Reno版本中又针对性的加入了“快速重传”、“快速恢复”算法；再后来TCP NewReno中又改进了“快速恢复”；最近又出现了选择性应答（SACK）的算法。</li>
<li>TCP拥塞控制主要依赖于“拥塞窗口（cwnd）”，TCP还有一个对端通告的接收窗口(rwnd)用于流量控制。窗口值的大小就代表能够发送出去的但还没有收到ACK的最大数据报文段，显然窗口越大那么数据发送的速度也就越快，但是也有越可能使得网络出现拥塞。TCP的拥塞控制算法就是要在这两者之间权衡，选取最好的cwnd值，从而使得网络吞吐量最大化且不产生拥塞。</li>
<li>由于需要考虑拥塞控制和流量控制两个方面的内容，因此TCP的真正的发送窗口=min(rwnd, cwnd)。但是rwnd是由对端确定的，网络环境对其没有影响，所以在考虑拥塞的时候我们一般不考虑rwnd的值。我们暂时只讨论如何确定cwnd值的大小。关于cwnd的单位，在TCP中是以Byte来做单位的，我们假设TCP每次传输都是按照MSS大小来发送数据的，因此你可以认为cwnd按照数据包个数来做单位也可以理解，所以有时我们说cwnd增加1也就是相当于字节数增加1个MSS大小。</li>
</ol>
<h3 id="慢启动">慢启动</h3><p>   方法：根据网络情况逐步增加每次发送的数据量。</p>
<p>   原因：最初的TCP在连接建立成功后会向网络中发送大量的数据包，这样很容易导致网络中路由器缓存空间耗尽，从而发生拥塞。</p>
<p>   描述：当新建连接时，cwnd初始化为1个最大报文段(MSS)大小，发送端开始按照拥塞窗口大小发送数据，每当有一个报文段被确认，cwnd就增加1个MSS大小。这样cwnd的值就随着网络往返时间(Round Trip Time,RTT)呈指数级增长，事实上，慢启动的速度一点也不慢，只是它的起点比较低一点而已。如果带宽为W，那么经过RTT*log2W时间就可以占满带宽。  </p>
<p>   <img src="https://raw.githubusercontent.com/Charles-Xiao/Charles-Xiao.github.io/master/images/ssca1.png" class="full-image" width="100%"></p>
<p>   <strong>慢启动引发的性能问题</strong></p>
<p>   在海量用户高并发访问的大型网站后台，有一些基本的系统维护需求。比如迁移海量小文件，就是从一些机器拷贝海量小碎文件到另一些机器，来完成一些系统维护的基本需求。</p>
<p>   举个简单的例子，我们对每个文件都采用独立的TCP连接来传输（循环使用scp拷贝就是这个例子的实际场景，很常见的用法）。那么工作过程应该是，每传输一个文件建立一个连接，然后连接处于慢启动阶段，传输小文件，每个小文件几乎都处于独立连接的慢启动阶段被传输，这样传输过程所用的TCP包的总量就会增多。更细致的说一说这个事，如果在慢启动过程中传输一个小文件，我们可能需要2至3个小包，而在一个已经完成慢启动的TCP通道中（TCP通道已进入在高速传输阶段），我们传输这个文件可能只需要1个大包。网络拷贝文件的时间基本上全部消耗都在网络传输的过程中（发数据过去等对端ACK，ACK确认归来继续再发，这样的数据来回交互相比较本机的文件读写非常耗时间），撇开三次握手和四次握手那些包，粗略来说，慢启动阶段传输这些文件所用的包的数目是高速通道传输这些文件的包的数目的2-3倍！那么时间上应该也是2-3倍的关系！如果文件的量足够大，这个总时间就会被放大到需求难以忍受的地步。</p>
<p>   因此，在迁移海量小文件的需求下，我们不能使用“对每个文件都采用独立的TCP连接来传输（循环使用scp拷贝）“这样的策略，它会使每个文件的传输都处于在一个独立TCP的慢启动阶段。</p>
<p>   <strong>如何避免慢启动，提升性能</strong></p>
<p>   很简单，尽量把大量小文件放在一个TCP连接中排队传输。起初的一两个文件处于慢启动过程传输，后续的文件传输全部处于高速通道中传输，用这样的方式来减少发包的数目，进而降低时间消耗。</p>
<p>   实际上这种传输策略带来的性能提升的功劳不仅仅归于避免慢启动，事实上也避免了大量的3次握手和四次握手，这个对海量小文件传输的性能消耗也非常致命。</p>
<p>   随着多核服务器的兴起，以及现代网卡的多通道技术的迅猛发展，现在我们解决这一问题的通常做法是绑定多CPU的多核到网卡的多个通道，然后由CPU的核来均分传输这些小文件，每个核用一个TCP连接来排队发送分到的小文件。</p>
<ol>
<li><p><strong>拥塞避免</strong></p>
<p>条件：TCP使用了一个叫慢启动门限(ssthresh)的变量，当cwnd超过该值后，慢启动过程结束，进入拥塞避免阶段。对于大多数TCP实现来说，ssthresh的值是65536(同样以字节计算)。</p>
<p>原因：从慢启动可以看到，cwnd可以很快的增长上来，从而最大程度利用网络带宽资源，但是cwnd不能一直这样无限增长下去，一定需要某个限制。</p>
<p>描述：拥塞避免的主要思想是加法增大，也就是cwnd的值不再指数级往上升，开始加法增加。此时当窗口中所有的报文段都被确认时，cwnd的大小加1，cwnd的值就随着RTT开始线性增加，这样就可以避免增长过快导致网络拥塞，慢慢的增加调整到网络的最佳值。<br> <strong>发生拥塞以后怎么办</strong></p>
<p>拥塞发生：TCP认为网络拥塞的主要依据是它重传了一个报文段。上面提到过，TCP对每一个报文段都有一个定时器，称为重传定时器(RTO)，当RTO超时且还没有得到数据确认，那么TCP就会对该报文段进行重传，当发生超时时，那么出现拥塞的可能性就很大，某个报文段可能在网络中某处丢失，并且后续的报文段也没有了消息。</p>
<p>TCP反应：<br><img src="https://raw.githubusercontent.com/Charles-Xiao/Charles-Xiao.github.io/master/images/ssca2.png" class="full-image" width="100%"></p>
</li>
<li><p><strong>快速重传</strong></p>
<p>条件：其实TCP还有一种情况会进行重传：那就是收到3个相同的ACK。TCP在收到乱序到达包时就会立即发送ACK，TCP利用3个相同的ACK来判定数据包的丢失，此时进行快速重传。</p>
<p>描述：<br>   <img src="https://raw.githubusercontent.com/Charles-Xiao/Charles-Xiao.github.io/master/images/ssca3.png" class="full-image" width="100%"></p>
</li>
<li><strong>快速恢复</strong></li>
</ol>
<ul>
<li><p>当收到3个重复ACK时，TCP最后进入的不是拥塞避免阶段，而是快速恢复阶段。快速重传和快速恢复算法一般同时使用。</p>
<p> 思想：“数据包守恒”原则，即同一个时刻在网络中的数据包数量是恒定的，只有当“老”数据包离开了网络后，才能向网络中发送一个“新”的数据包，如果发送方收到一个重复的ACK，那么根据TCP的ACK机制就表明有一个数据包离开了网络，于是cwnd加1。如果能够严格按照该原则那么网络中很少会发生拥塞，事实上拥塞控制的目的也就在修正违反该原则的地方。</p>
<p> 描述：</p>
<pre><code>&lt;img <span class="variable">src=</span><span class="string">"https://raw.githubusercontent.com/Charles-Xiao/Charles-Xiao.github.io/master/images/ssca4.png"</span> <span class="variable">class=</span><span class="string">"full-image"</span> <span class="variable">width=</span><span class="string">"100%"</span>/&gt;
</code></pre></li>
<li>快速重传算法首次出现在4.3BSD的Tahoe版本，快速恢复首次出现在4.3BSD的Reno版本，也称之为Reno版的TCP拥塞控制算法。<br>可以看出Reno的快速重传算法是针对一个包的重传情况的，然而在实际中，一个重传超时可能导致许多的数据包的重传，因此当多个数据包从一个数据窗口中丢失时并且触发快速重传和快速恢复算法时，问题就产生了。因此NewReno出现了，它在Reno快速恢复的基础上稍加了修改，可以恢复一个窗口内多个包丢失的情况。具体来讲就是：Reno在收到一个新的数据的ACK时就退出了快速恢复状态了，而NewReno需要收到该窗口内所有数据包的确认后才会退出快速恢复状态，从而更一步提高吞吐量。</li>
</ul>
<h2 id="UDP协议">UDP协议</h2><h2 id="HTTP协议">HTTP协议</h2><h3 id="Http1-0,_1-1，2-0和https之间的区别">Http1.0, 1.1，2.0和https之间的区别</h3><ol>
<li><strong>HTTP1.0</strong>：规定浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个单独的TCP连接，服务器完成请求处理后立即断开释放TCP连接，服务器不跟踪每个客户也不记录过去的请求。此外，由于大多数网页的流量都比较小，一次TCP连接很少能通过slow-start区，不利于提高带宽利用率。HTTP1.0要建立长连接，可以在请求消息中包含Connection: Keep-Alive头域</li>
<li><strong>HTTP 1.1</strong>支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟。例如：一个包含有许多图像的网页文件的多个请求和应答可以在一个连接中传输，但每个单独的网页文件的请求和应答仍然需要使用各自的连接</li>
<li><strong>HTTP 1.1</strong>还允许客户端不用等待上一次请求结果返回，就可以发出下一次请求，但服务器端必须按照接收到客户端请求的先后顺序依次回送响应结果，以保证客户端能够区分出每次请求的响应内容，这样也显著地减少了整个过程所需要的时间</li>
<li><a href="https://www.jianshu.com/p/be29d679cbff" target="_blank" rel="noopener">三者区别参考链接</a></li>
</ol>
<h3 id="Http的get和post之间的区别">Http的get和post之间的区别</h3><h3 id="Header和响应码">Header和响应码</h3><p><img src="https://raw.githubusercontent.com/Charles-Xiao/Charles-Xiao.github.io/master/images/http1.png" class="full-image" width="100%"></p>
<p><img src="https://raw.githubusercontent.com/Charles-Xiao/Charles-Xiao.github.io/master/images/HttpRequest.jpeg" class="full-image" width="100%"></p>
<p><img src="https://raw.githubusercontent.com/Charles-Xiao/Charles-Xiao.github.io/master/images/HttpResponse.png" class="full-image" width="100%"></p>
<p><img src="https://raw.githubusercontent.com/Charles-Xiao/Charles-Xiao.github.io/master/images/http头部字段.png" class="full-image" width="100%"></p>
<h3 id="缓存对应的响应头部字段">缓存对应的响应头部字段</h3><ol>
<li><strong><a href="http://www.cnblogs.com/skynet/archive/2012/11/28/2792503.html" target="_blank" rel="noopener">浏览器缓存机制</a></strong><ul>
<li><strong>Expires</strong>是Web服务器响应消息头字段，在响应http请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求;不过Expires 是HTTP 1.0的东西，现在默认浏览器均默认使用HTTP 1.1，所以它的作用基本忽略</li>
<li><strong>Cache-Control</strong>与Expires的作用一致，都是指明当前资源的有效期，控制浏览器是否直接从浏览器缓存取数据还是重新发请求到服务器取数据。只不过Cache-Control的选择更多，设置更细致，如果同时设置的话，其优先级高于Expires</li>
<li><strong>Last-Modified</strong>：标示这个响应资源的最后修改时间。web服务器在响应请求时，告诉浏览器资源的最后修改时间。</li>
<li><strong>Etag</strong>：web服务器响应请求时，告诉浏览器当前资源在服务器的唯一标识（生成规则由服务器觉得）。Apache中，ETag的值，默认是对文件的索引节（INode），大小（Size）和最后修改时间（MTime）进行Hash后得到的。</li>
<li><strong>既生Last-Modified何生Etag？</strong>：<ul>
<li>Last-Modified标注的最后修改只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，它将不能准确标注文件的修改时间</li>
<li>如果某些文件会被定期生成，当有时内容并没有任何变化，但Last-Modified却改变了，导致文件没法使用缓存</li>
<li>有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致等情形</li>
<li>Etag是服务器自动生成或者由开发者生成的对应资源在服务器端的唯一标识符，能够更加准确的控制缓存。Last-Modified与ETag是可以一起使用的，服务器会优先验证ETag，一致的情况下，才会继续比对Last-Modified，最后才决定是否返回304</li>
</ul>
</li>
<li><strong>浏览器缓存检查流程</strong><br><img src="https://raw.githubusercontent.com/Charles-Xiao/Charles-Xiao.github.io/master/images/browser_cache.png" class="full-image" width="100%"></li>
</ul>
</li>
</ol>
<h2 id="Socket协议">Socket协议</h2><ol>
<li><strong>套接字（socket）</strong>是支持TCP/IP协议的网络通信的基本操作单元，也可以说是应用层和传输层之间的一个软件抽象层；<strong>它包含进行网络通信必须的五种信息</strong>：连接使用的协议，本地主机的IP地址，本地进程的协议端口，远程主机的IP地址，远程进程的协议端口。在创建Socket连接时，可以指定使用的传输层协议，Socket可以支持不同的传输层协议（TCP或UDP），当使用TCP协议进行连接时，该Socket连接就是一个TCP连接</li>
<li><strong>应用层通过传输层进行数据通信时，TCP会遇到同时为多个应用程序进程提供并发服务的问题</strong>：多个TCP连接或多个应用程序进程可能需要通过同一个TCP协议端口传输数据。为了区别不同的应用程序进程和连接，许多计算机操作系统为应用程序与TCP／IP协议交互提供了套接字(Socket)接口。应用层可以和传输层通过Socket接口，区分来自不同应用程序进程或网络连接的通信，实现数据传输的并发服务</li>
<li><strong>套接字之间的连接过程分为三个步骤：服务器监听，客户端请求，连接确认。</strong><ul>
<li><strong>服务器监听</strong>：服务器端套接字并不定位具体的客户端套接字，而是处于等待连接的状态，实时监控网络状态，等待客户端的连接请求。</li>
<li><strong>客户端请求</strong>：指客户端的套接字提出连接请求，要连接的目标是服务器端的套接字。为此，客户端的套接字必须首先描述它要连接的服务器的套接字，指出服务器端套接字的地址和端口号，然后就向服务器端套接字提出连接请求。</li>
<li><strong>连接确认</strong>：当服务器端套接字监听到或者说接收到客户端套接字的连接请求时，就响应客户端套接字的请求，建立一个新的线程，把服务器端套接字的描述发给客户端，一旦客户端确认了此描述，双方就正式建立连接。而服务器端套接字继续处于监听状态，继续接收其他客户端套接字的连接请求</li>
</ul>
</li>
<li><strong>Socket连接与HTTP连接相结合</strong><ul>
<li>通常情况下Socket连接其实就是一个TCP连接，因此Socket连接一旦建立，通信双方即可开始相互发送数据内容，直到双方连接断开。但在实际网络应用中，客户端到服务器之间的通信往往需要穿越多个中间节点，例如路由器、网关、防火墙等，大部分防火墙默认会关闭长时间处于非活跃状态的连接而导致 Socket 连接断连，因此也需要通过http轮询告诉网络，该连接处于活跃状态。</li>
<li>HTTP连接使用的是“请求—响应”的方式，不仅在请求时需要先建立连接，而且需要客户端向服务器发出请求后，服务器端才能回复数据。</li>
<li>很多情况下，我们需要服务器端主动向客户端推送数据，保持客户端与服务器数据的实时与同步。此时若双方建立的是Socket连接，服务器就可以直接将数据传送给客户端；若双方建立的是HTTP连接，则服务器需要等到客户端发送一次请求后才能将数据传回给客户端，因此，客户端定时向服务器端发送连接请求，不仅可以保持在线，同时也是在“询问”服务器是否有新的数据，如果有就将数据传给客户端<h2 id="其它协议">其它协议</h2></li>
</ul>
</li>
</ol>

      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="../../tags/Network/"> #Network </a>
          
        </div>
      

      

      
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              Java多进程和多线程编程总结
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2015-03-09
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分类于
            
              <a href="../../categories/java学习笔记/">java学习笔记</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="../../2015/03/09/Java多进程和多线程编程总结/#comments">
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/03/09/Java多进程和多线程编程总结/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        <h3 id="进程与线程之间关系">进程与线程之间关系</h3><p>一个进程对应一个程序的执行，它具有文本、数据、堆栈片段以及它自己的资源；而一个线程则是进程执行过程中的一个单独的执行序列，线程有时候也被称为轻量级进程. 一个进程可以包含多个线程，这些线程共享进程的资源。  </p>
<p>首先我们明确一点，就是我们创建的每一个Java程序都是运行在一个单独的Java虚拟机进程中的，每启动一个java程序就会同时开启一个单独对应的JVM进程(也叫做JVM实例)，然后JVM进程会开始初始化类，包括初始化静态变量和静态代码块，普通变量，构造器等；然后再去寻找main()主线程作为程序执行入口,继续执行其他线程直至结束.(Android应用程序和dalvik虚拟机的关系也一样如此)</p>
<h3 id="常见的进程间通信方式(IPC)">常见的进程间通信方式(IPC)</h3><ol>
<li><strong>管道与命名管道</strong>：管道允许一个进程和另一个与它有共同祖先的进程之间进行通信，命名管道允许无亲缘关系的进程间的通信,命名管道在文件系统中有对应的文件名,通过命令mkfifo或系统调用mkfifo来创建</li>
<li><strong>套接字</strong>：可用于不同机器之间的进程间通信</li>
<li><strong>共享内存</strong>：多个进程可以访问同一块内存空间，是最快的可用IPC形式</li>
<li><strong>文件内存映射</strong>：内存映射允许任何多个进程间通信，每一个使用该机制的进程通过把一个共享的文件映射到自己的进程地址空间来实现它; 需要文件锁做同步</li>
<li><strong>信号量</strong>：主要作为进程间以及同一进程不同线程之间的同步手段</li>
<li><strong>信号（Signal）</strong>：信号是比较复杂的通信方式，用于通知接受进程有某种事件发生，除了用于进程间通信外，进程还可以发送信号给进程本身</li>
<li><strong>消息队列</strong>：消息队列是消息的链接表，包括Posix消息队列和system V消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息</li>
</ol>
<h3 id="进程的状态:就绪-运行-阻塞">进程的状态:就绪-运行-阻塞</h3><p><img src="https://raw.githubusercontent.com/Charles-Xiao/Charles-Xiao.github.io/master/images/Linux_ps.png" class="full-image" width="100%"></p>
<h3 id="多线程之间通信方式">多线程之间通信方式</h3><ol>
<li>“共享变量”：实现Runnable接口实现线程的共享变量或者内部类共享外围类的变量</li>
<li><p>“管道流”：</p>
<pre><code><span class="comment">/* 管道输出流和生产者线程绑定, 管道输入流和消费者线程绑定,输入输出流绑定，启动两个线程互相之间通过write和read函数就行通信 */</span>
<span class="type">PipedOutputStream</span> pos = <span class="keyword">new</span> <span class="type">PipedOutputStream</span>();
<span class="type">Producer</span> p = <span class="keyword">new</span> <span class="type">Producer</span>(pos);
<span class="type">PipedInputStream</span> pis = <span class="keyword">new</span> <span class="type">PipedInputStream</span>();
<span class="type">Consumer</span> c = <span class="keyword">new</span> <span class="type">Consumer</span>(pis);
pos.connect(pis);
p.start();
c.start();

<span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Thread</span> {</span>
    <span class="keyword">private</span> <span class="type">PipedOutputStream</span> pos;
    public <span class="type">Producer</span>(<span class="type">PipedOutputStream</span> pos) {
        <span class="keyword">this</span>.pos = pos;
    }
    public void run() {
        int i = <span class="number">8</span>;
        <span class="keyword">try</span> {
            pos.write(i);
            <span class="comment">// pis.read()</span>
        } <span class="keyword">catch</span> (<span class="type">IOException</span> e) {
            e.printStackTrace();
        }
    }
}
</code></pre></li>
</ol>
<h3 id="线程的四种创建方式">线程的四种创建方式</h3><ol>
<li>定义<strong>Thread类</strong>的子类，并重写该类的run()方法；创建Thread子类的实例，即创建了线程对象，调用线程对象的start()方法来启动该线程</li>
<li>定义<strong>Runnable接口</strong>的实现类，并重写该接口的run()方法，创建Runnable实现类的实例，并以此实例作为Thread的参数来创建Thread对象，该Thread对象才是真正的线程对象；然后调用线程对象的start()方法来启动线程</li>
<li><p>创建<strong>Callable接口</strong>的实现类，并实现call()方法，该call()方法有返回值；创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值，使用FutureTask对象作为Thread对象的target创建并启动新线程，调用FutureTask对象的get()方法来获得子线程执行结束后的返回值</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> MyCallableTest <span class="keyword">implements</span> Callable&lt;Integer&gt;{
    <span class="comment">// 实现call方法，作为线程执行体</span>
    <span class="keyword">public</span> Integer <span class="keyword">call</span>(){
        <span class="keyword">int</span> i = <span class="number">0</span>;
        <span class="keyword">for</span> ( ; i &lt; <span class="number">100</span> ; i++ ){
            System.out.<span class="keyword">println</span>(Thread.currentThread().getName()+ <span class="string">"\t"</span> + i);
        }
        <span class="comment">// call()方法可以有返回值，而且可以抛出异常</span>
        <span class="keyword">return</span> i;
    }
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) {
        <span class="comment">// 创建Callable对象</span>
        MyCallableTest myCallableTest = <span class="keyword">new</span> MyCallableTest();
        <span class="comment">// 使用FutureTask来包装Callable对象</span>
        FutureTask&lt;Integer&gt; <span class="keyword">task</span> = <span class="keyword">new</span> FutureTask&lt;Integer&gt;(myCallableTest);
        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">100</span> ; i++){
            System.out.<span class="keyword">println</span>(Thread.currentThread().getName()+ <span class="string">" \t"</span> + i);
            <span class="keyword">if</span> (i == <span class="number">20</span>){
                <span class="comment">// 实质还是以Callable对象来创建、并启动线程</span>
                <span class="keyword">new</span> Thread(<span class="keyword">task</span> , <span class="string">"callable"</span>).start();
                <span class="comment">// 线程池执行FutureTask</span>
                Executor executor = Executors.newSingleThreadExecutor();
                executor.execute(<span class="keyword">task</span>);
            }
        }
        <span class="keyword">try</span>{
            <span class="comment">// 获取线程返回值</span>
            System.out.<span class="keyword">println</span>(<span class="string">"callable返回值："</span> + <span class="keyword">task</span>.get());
        }
        <span class="keyword">catch</span> (Exception ex){
            ex.printStackTrace();
        }
    }
}
</code></pre></li>
<li><p><strong>线程池</strong>: </p>
<ul>
<li>线程池的<strong>好处1</strong>在于可以更好地控制并发线程数目，提高资源利用率并防止阻塞</li>
<li><strong>好处2</strong>可以更好地重用线程, 减少线程创建和销毁带来的系统开销,可以设置线程定时定期执行</li>
<li><strong>核心构造函数ThreadPoolExecutor</strong>,可以在参数中设置核心池大小，最大线程数等</li>
<li><strong>ExecutorService接口用于实现和管理线程池,其生命周期包括三种状态：运行、关闭、终止</strong>。</li>
<li><strong>线程池四个基本组成部分</strong>：<ol>
<li><strong>线程池管理器（ThreadPool）</strong>：用于创建并管理线程池，包括 创建线程池，销毁线程池，添加新任务；</li>
<li><strong>工作线程（PoolWorker）</strong>：线程池中线程，在没有任务时处于等待状态，可以循环的执行任务；</li>
<li><strong>任务接口（Task）</strong>：每个任务必须实现的接口，以供工作线程调度任务的执行，它主要规定了任务的入口，任务执行完后的收尾工作，任务的执行状态等；</li>
<li><strong>任务队列（taskQueue）</strong>：用于存放没有处理的任务, 提供一种缓冲机制。</li>
</ol>
</li>
<li><p>四种Executors接口提供的通过ThreadFactory新建的线程池</p>
<ol>
<li><p>newFixedThreadPool(): 固定数目线程池，任意时间点最多只能有固定数目的活动线程存在；有新任务到达时创建线程，只能放在另外的队列中等待，直到达到线程池最大大小为止，有异常则补充    </p>
<pre><code>ExecutorService threadPool = Executor.newFixedThreadPool(<span class="number">3</span>);
Runnable r = <span class="keyword">new</span> Runnable() {
    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{

    }
};
<span class="comment">// 参数可以是Thread以及Runnable对象</span>
threadPool.execute(r);
</code></pre></li>
<li><p>newCachedThreadPool：缓存型线程池，新任务到达则新建线程，当线程数目大于处理需要时，则回收空闲的线程，无大小限制</p>
</li>
<li>newSingleThreadExecutor: 单线程池，只创建唯一的工作线程来执行任务，保证任务被顺序执行</li>
<li>newScheduledThreadPool: 调度型线程池，固定线程数目，而且提供任务被定时和周期性执行的功能</li>
</ol>
</li>
<li><p><strong>自定义线程池</strong></p>
<pre><code> ThreadPoolExecutor(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span> keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler)

<span class="comment">/*
corePoolSize - 核心池中所保存的线程数，包括空闲线程；也就是正在运行的线程数目。
maximumPoolSize-线程池中允许的最大线程数
keepAliveTime - 当线程池的工作线程空闲后，保持存活的时间
unit - keepAliveTime 参数的时间单位
workQueue - 执行前用于保持任务的队列。此队列仅保持由 execute方法提交的 Runnable任务
threadFactory - 执行程序创建新线程时使用的工厂
handler - 由于超出线程范围和队列容量而使新到达的任务被阻塞时采取的处理策略，
默认为AbortPolicy，表示无法处理新任务时抛出异常；DiscardPolicy：不能执行的任务将被删除
ThreadPoolExecutor是Executors类的底层实现
*/</span>

 <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolTest</span></span>{   
    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>{   
        <span class="comment">//创建等待队列   </span>
        BlockingQueue&lt;Runnable&gt; bqueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="number">20</span>);   
        <span class="comment">//创建线程池，池中保存的线程数为3，允许的最大线程数为5  </span>
        ThreadPoolExecutor pool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">3</span>,<span class="number">5</span>,<span class="number">50</span>,TimeUnit.MILLISECONDS,bqueue);   
        <span class="comment">//创建七个任务   </span>
        Runnable t1 = <span class="keyword">new</span> MyThread();   
        Runnable t2 = <span class="keyword">new</span> MyThread();   
        Runnable t3 = <span class="keyword">new</span> MyThread();   
        Runnable t4 = <span class="keyword">new</span> MyThread();   
        Runnable t5 = <span class="keyword">new</span> MyThread();   
        Runnable t6 = <span class="keyword">new</span> MyThread();   
        Runnable t7 = <span class="keyword">new</span> MyThread();   
        <span class="comment">//每个任务会在一个线程上执行  </span>
        pool.execute(t1);   
        pool.execute(t2);   
        pool.execute(t3);   
        pool.execute(t4);   
        pool.execute(t5);   
        pool.execute(t6);   
        pool.execute(t7);   
        <span class="comment">//关闭线程池   </span>
        pool.shutdown();   
    }   
}   

<span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>{   
    <span class="annotation">@Override</span>   
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>{   
        System.out.println(Thread.currentThread().getName() + <span class="string">"正在执行。。。"</span>);   
        <span class="keyword">try</span>{   
            Thread.sleep(<span class="number">100</span>);   
        }<span class="keyword">catch</span>(InterruptedException e){   
            e.printStackTrace();   
        }   
    }   
}  
</code></pre></li>
<li><strong>线程池工作流程</strong><br>   <img src="https://raw.githubusercontent.com/Charles-Xiao/Charles-Xiao.github.io/master/images/threadpool-procedure.jpg" class="full-image">    </li>
<li><p><strong>线程池的排队策略</strong>    </p>
<ol>
<li><strong>默认选项是SynchronousQueue</strong>，它将任务直接提交给线程而不保持它们，一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态</li>
<li><strong>无界队列</strong>。使用无界队列（例如，不具有预定义容量的 LinkedBlockingQueue）将导致在所有 corePoolSize 线程都忙时新任务在队列中等待。这样，创建的线程就不会超过corePoolSize。（因此，maximumPoolSize的值也就无效了。）当每个任务完全独立于其他任务，即任务执行互不影响时，适合于使用无界队列；例如，在 Web页服务器中。这种排队可用于处理瞬态突发请求，当命令以超过队列所能处理的平均数连续到达时，此策略允许无界线程具有增长的可能性。</li>
<li><strong>有界队列</strong>。当使用有限的 maximumPoolSizes时，有界队列（如 ArrayBlockingQueue）有助于防止资源耗尽，但是可能较难调整和控制。队列大小和最大池大小可能需要相互折衷：使用大型队列和小型池可以最大限度地降低 CPU 使用率、操作系统资源和上下文切换开销，但是可能导致人工降低吞吐量。如果任务频繁阻塞（例如，如果它们是 I/O边界），则系统可能为超过您许可的更多线程安排时间。使用小型队列通常要求较大的池大小，CPU使用率较高，但是可能遇到不可接受的调度开销，这样也会降低吞吐量。 </li>
<li><strong>PriorityBlockingQueue</strong>: 一个具有优先级的无限阻塞队列</li>
</ol>
</li>
<li><p><strong>线程池的风险</strong></p>
<ol>
<li>死锁: 死锁的产生是因为一组线程或者进程互相等待资源的释放而永远互相等待;线程池中容易产生一种新的死锁: 当核心池中所有线程都在等待阻塞队列中的某个线程的执行结果，但是该线程却因为池中没有空闲线程而没有办法执行，这样就导致互相等待的死锁.</li>
<li>并发错误: 线程池和其它排队机制依靠使用 wait() 和 notify() 方法,易出现问题 </li>
</ol>
</li>
<li><p><strong>线程池的执行</strong>: execute和submit两个方法都可以向线程池提交任务， <strong>execute()方法</strong>的返回类型是void，它定义在Executor接口中；<strong>submit()方法</strong>可以返回持有计算结果的Future对象，它定义在ExecutorService接口中，它扩展了Executor接口，便于捕获异常，利用FutureTask.get()函数</p>
</li>
<li><p><strong>线程池的关闭</strong></p>
<ol>
<li>通过调用线程池的shutdown或shutdownNow方法来关闭线程池，它们的原理是遍历线程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程，所以无法响应中断的任务可能永远无法终止。但是它们存在一定的区别，shutdownNow首先将线程池的状态设置成STOP，然后尝试停止所有的正在执行或暂停任务的线程，并返回等待执行任务的列表，而shutdown只是将线程池的状态设置成SHUTDOWN状态，然后中断所有没有正在执行任务的线程。</li>
</ol>
</li>
</ul>
<ol>
<li>只要调用了这两个关闭方法的其中一个，isShutdown方法就会返回true。当所有的任务都已关闭后,才表示线程池关闭成功，这时调用isTerminaed方法会返回true。至于我们应该调用哪一种方法来关闭线程池，应该由提交到线程池的任务特性决定，通常调用shutdown来关闭线程池，如果任务不一定要执行完，则可以调用shutdownNow。 </li>
</ol>
<ul>
<li><strong>合理配置线程池</strong>       <ol>
<li>任务的性质：CPU密集型任务，IO密集型任务和混合型任务；CPU密集型任务配置尽可能小的线程，如配置Ncpu+1个线程的线程池。IO密集型任务则由于线程并不是一直在执行任务，则配置尽可能多的线程，如2*Ncpu</li>
<li>任务的优先级：高，中和低；PriorityBlockingQueue会导致优先级低的线程永远不被执行</li>
<li>任务的执行时间：长，中和短；</li>
<li>任务的依赖性：是否依赖其他系统资源，如数据库连接：依赖数据库连接池的任务，因为线程提交SQL后需要等待数据库返回结果，如果等待的时间越长CPU空闲时间就越长，那么线程数应该设置越大，这样才能更好的利用CPU。    </li>
</ol>
</li>
</ul>
</li>
</ol>
<h3 id="线程的状态变化">线程的状态变化</h3><p><img src="https://raw.githubusercontent.com/Charles-Xiao/Charles-Xiao.github.io/master/images/multiThread.png" class="full-image"></p>
<h3 id="死锁及其解决办法">死锁及其解决办法</h3><pre><code><span class="comment">/**
 * 一个简单的死锁类 当DeadLock类的对象flag==1时（td1），先锁定o1,睡眠500毫秒
 * 而td1在睡眠的时候另一个flag==0的对象（td2）线程启动，先锁定o2,睡眠500毫秒
 * td1睡眠结束后需要锁定o2才能继续执行，而此时o2已被td2锁定； td2睡眠结束后需要锁定o1才能继续执行，而此时o1已被td1锁定；
 * td1、td2相互等待，都需要得到对方锁定的资源才能继续执行，从而死锁
 */</span>
<span class="keyword">public</span> class DeadLock implements Runnable {
    <span class="keyword">public</span> <span class="built_in">int</span> flag = <span class="number">1</span>;
    <span class="comment">// 静态对象是类的所有对象共享的</span>
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">Object</span> o1 = <span class="keyword">new</span> <span class="keyword">Object</span>(), o2 = <span class="keyword">new</span> <span class="keyword">Object</span>();

    <span class="keyword">public</span> <span class="keyword">void</span> run() {
        System.out.<span class="built_in">println</span>(<span class="string">"flag="</span> + flag);
        <span class="keyword">if</span> (flag == <span class="number">1</span>) {
            <span class="keyword">synchronized</span> (o1) {
                System.out.<span class="built_in">println</span>(<span class="string">"thread1锁定 o1"</span>);
                <span class="keyword">try</span> {
                    Thread.sleep(<span class="number">500</span>);
                } <span class="keyword">catch</span> (Exception e) {
                    e.printStackTrace();
                }
                <span class="comment">// thread1等待资源o2释放</span>
                <span class="keyword">synchronized</span> (o2) {
                    System.out.<span class="built_in">println</span>(<span class="string">"1"</span>);
                }
            }
        }
        <span class="keyword">if</span> (flag == <span class="number">2</span>) {
            <span class="keyword">synchronized</span> (o2) {
                System.out.<span class="built_in">println</span>(<span class="string">"thread2锁定 o2"</span>);
                <span class="keyword">try</span> {
                    Thread.sleep(<span class="number">500</span>);
                } <span class="keyword">catch</span> (Exception e) {
                    e.printStackTrace();
                }
                <span class="comment">// thread2等待资源o1释放</span>
                <span class="keyword">synchronized</span> (o1) {
                    System.out.<span class="built_in">println</span>(<span class="string">"2"</span>);
                }
            }
        }
    }

    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) {

        DeadLock td1 = <span class="keyword">new</span> DeadLock();
        DeadLock td2 = <span class="keyword">new</span> DeadLock();
        td1.flag = <span class="number">1</span>;
        td2.flag = <span class="number">2</span>;
        <span class="comment">// td1,td2都处于可执行状态，但JVM线程调度先执行哪个线程是不确定的。</span>
        <span class="comment">// td2的run()可能在td1的run()之前运行</span>
        <span class="keyword">new</span> Thread(td1).start();
        <span class="keyword">new</span> Thread(td2).start();

    }
}
</code></pre><ol>
<li><strong>死锁的必要条件</strong>死锁是指是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待对方占有的资源的现象，若无外力作用，它们都将无法推进下去。<ul>
<li><strong>互斥条件</strong>：指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。</li>
<li><strong>请求和保持条件</strong>：指进程请求新资源发生阻塞时对自己已经获得的其它资源保持不放。</li>
<li><strong>不剥夺条件</strong>：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。</li>
<li><strong>环路等待条件</strong>：指在发生死锁时，进程之间会形成一种头尾相接的循环等待资源关系，即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。</li>
</ul>
</li>
<li><strong>死锁的避免、预防和解决方法</strong><ul>
<li>采用资源有序分配法，破坏环路等待形成</li>
<li>允许进程剥夺其他进程占有的资源</li>
<li>银行家算法:把操作系统看作是银行家，操作系统管理的资源相当于银行家管理的资金，进程向操作系统请求分配资源相当于用户向银行家贷款。操作系统按照银行家制定的规则为进程分配资源，当进程首次申请资源时，要测试该进程对资源的最大需求量，如果系统现存的资源可以满足它的最大需求量则按当前的申请量分配资源，否则就推迟分配。当进程在执行中继续申请资源时，先测试该进程已占用的资源数与本次申请的资源数之和是否超过了该进程对资源的最大需求量。若超过则拒绝分配资源，若没有超过则再测试系统现存的资源能否满足该进程尚需的最大资源量，若能满足则按当前的申请量分配资源，否则也要推迟分配。</li>
<li>互斥条件无法被破坏</li>
</ul>
</li>
</ol>
<h3 id="多线程相关问题">多线程相关问题</h3><ol>
<li><strong>yield</strong>表示暂停当前线程，执行其他线程(包括自身线程)由cpu决定</li>
<li><strong>join</strong>：阻塞所在线程，等调用它的线程执行完毕，再向下执行</li>
<li><strong>sleep()方法</strong>属于Thread类中的，而<strong>wait()方法</strong>则是属于Object类；sleep()方法导致了程序暂停执行指定的时间，让出cpu给其他线程，但是他的监控状态依然保持，当指定的时间到了又会自动恢复运行状态，线程不会释放对象锁；而当调用wait()方法的时候，线程会放弃对象锁，只有针对此对象调用notify()方法后本线程才进入对象锁定池准备就绪</li>
</ol>
<h3 id="多线程同步的方法">多线程同步的方法</h3><ol>
<li>Synchronized代码块</li>
<li>Synchronized方法</li>
<li>RetrantLock可重入锁</li>
<li>ThreadLocal线程局部变量</li>
<li>Volatile可见变量</li>
</ol>

      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="../../tags/java/"> #java </a>
          
            <a href="../../tags/多线程/"> #多线程 </a>
          
        </div>
      

      

      
      
    </div>
  </div>


    
  </div>

  
  <div class="pagination">
    <a class="extend prev" rel="prev" href="../16/">&laquo;</a><a class="page-number" href="../../">1</a><span class="space">&hellip;</span><a class="page-number" href="../16/">16</a><span class="page-number current">17</span>
  </div>


        </div>

        
      </div>


      
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <div id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      <div class="site-overview">
        <div class="site-author motion-element">
          <img class="site-author-image" src="/images/avatar.jpg" alt="CharlesXiao">
          <p class="site-author-name">CharlesXiao</p>
        </div>
        <p class="site-description motion-element">在码农炼成之路不断挣扎……stay hungry……keep learning……</p>
        <div class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="../../archives">
              <span class="site-state-item-count">84</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            <a href="../../categories">
              <span class="site-state-item-count">17</span>
              <span class="site-state-item-name">分类</span>
              </a>
          </div>

          <div class="site-state-item site-state-tags">
            <a href="../../tags">
              <span class="site-state-item-count">76</span>
              <span class="site-state-item-name">标签</span>
              </a>
          </div>

        </div>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
              <a href="https://github.com/Charles-Xiao" target="_blank">github</a>
            </span>
            
              <span class="links-of-author-item">
              <a href="http://weibo.com/2262300105/profile?topnav=1&wvr=6" target="_blank">weibo</a>
            </span>
            
              <span class="links-of-author-item">
              <a href="http://daijiale.github.io/" target="_blank">Daijiale的个人站点</a>
            </span>
            
          
        </div>

        
        

      </div>

      

    </div>
  </div>


    </div>

    <div id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">
  
  &copy; &nbsp;  2015.05.16 - 
  2018
  <span class="with-love">
    <i class="icon-heart"></i>
  </span>
  <span class="author">CharlesXiao</span>
</div>

<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_pv">
  本站访客数:<span id="busuanzi_value_site_pv"></span>
</span>
</div>

<div class="theme-info">
  <span class="post-count">博客全站共165.6k字</span>
</div>
<!--
<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>
-->



      </div>
    </div>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="../../vendors/jquery/index.js?v=2.1.3"></script>

  
  

  
  <script type="text/javascript" src="../../vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript">
    $(document).ready(function() {
      $('.content img').each(function () {
        var $image = $(this);
        var $imageWrapLink = $image.parent('a');

        if ($imageWrapLink.size() < 1) {
          $imageWrapLink = $image.wrap('<a href="' + this.getAttribute('src') + '"></a>').parent('a');
        }
        $imageWrapLink.addClass('fancybox');
      });
    });
    $('.fancybox').fancybox({
      helpers: {
        overlay: {
          locked: false
        }
      }
    });
  </script>


  <script type="text/javascript">
  function hasMobileUA () {
    var nav = window.navigator;
    var ua = nav.userAgent;
    var pa = /iPad|iPhone|Android|Opera Mini|BlackBerry|webOS|UCWEB|Blazer|PSP|IEMobile|Symbian/g;

    return pa.test(ua);
  }

  function isDesktop () {
    return screen.width > 991 && !hasMobileUA();
  }

  function isTablet () {
    return screen.width < 992 && screen.width > 767 && hasMobileUA();
  }

  function isMobile () {
    return screen.width < 767 && hasMobileUA();
  }

  function escapeSelector (selector) {
    return selector.replace(/[!"$%&'()*+,.\/:;<=>?@[\\\]^`{|}~]/g, "\\$&")
  }
</script>

  

  <script type="text/javascript" src="../../vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="../../vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" id="motion.global">
  $(document).ready(function () {
    var body = $('body');
    var isSidebarVisible = false;
    var sidebarToggle = $('.sidebar-toggle');
    var sidebarToggleLine1st = $('.sidebar-toggle-line-first')
    var sidebarToggleLine2nd = $('.sidebar-toggle-line-middle');
    var sidebarToggleLine3rd = $('.sidebar-toggle-line-last');
    var sidebar = $('.sidebar');

    var SIDEBAR_WIDTH = '320px';
    var SIDEBAR_DISPLAY_DURATION = 300;

    var sidebarToogleLineStatusInit = {width: '100%', opacity: 1, left: 0, rotateZ: 0, top: 0};

    var sidebarToggleLine1stStatusInit = sidebarToogleLineStatusInit;
    var sidebarToggleLine1stStatusArrow = {width: '50%', rotateZ: '-45deg', top: '2px'};
    var sidebarToogleLine1stStatusClose = {width: '100%', rotateZ: '-45deg', top: '5px'};

    var sidebarToggleLine2ndStatusInit = sidebarToogleLineStatusInit;
    var sidebarToggleLine2ndStatusArrow = {width: '90%'};
    var sidebarToogleLine2ndStatusClose = {opacity: 0};

    var sidebarToggleLine3rdStatusInit = sidebarToogleLineStatusInit;
    var sidebarToggleLine3rdStatusArrow = {width: '50%', rotateZ: '45deg', top: '-2px'};
    var sidebarToogleLine3rdStatusClose = {width: '100%', rotateZ: '45deg', top: '-5px'};

    LogoAndMenuMotion();
    sidebatToggleMotion();
    postsListMotion();
    backToTopMotion();


    $(document)
      .on('sidebar.isShowing', function () {
        isDesktop() && body.velocity(
          {paddingRight: SIDEBAR_WIDTH},
          SIDEBAR_DISPLAY_DURATION
        );
        sidebarContentMotion();
      })
      .on('sidebar.isHiding', function () {});

    function LogoAndMenuMotion() {
      $.Velocity.RunSequence([
        { e: $('.brand'), p: { opacity: 1 }, o: { duration: 100 } },
        { e: $('.logo'), p: { opacity: 1, top: 0 }, o: { duration: 50} },
        
        { e: $('.logo-line-before i'), p: { translateX: "100%" }, o: { duration: 500, sequenceQueue: false } },
        { e: $('.logo-line-after i'), p: { translateX: "-100%" }, o: { duration: 500, sequenceQueue: false } },
        
        { e: $('.site-title'), p: { opacity: 1, top: 0 }, o: { duration: 200 } }
      ]);
      $('.menu-item').velocity('transition.slideDownIn', {display: null});
    }


    function backToTopMotion () {
      var b2top = $('.back-to-top');
      b2top.on('click', function () {
        body.velocity('scroll');
      });
    }

    function sidebarShowMotion () {

      sidebarToggleLine1st.velocity(sidebarToogleLine1stStatusClose);
      sidebarToggleLine2nd.velocity(sidebarToogleLine2ndStatusClose);
      sidebarToggleLine3rd.velocity(sidebarToogleLine3rdStatusClose);

      sidebar.velocity({width: SIDEBAR_WIDTH}, {
        display: 'block',
        duration: SIDEBAR_DISPLAY_DURATION,
        complete: function () {
          sidebar.addClass('sidebar-active');
          sidebar.trigger('sidebar.didShow');
        }
      });
      sidebar.trigger('sidebar.isShowing');
    }

    function sidebarHideMotion () {
      isDesktop() && body.velocity({paddingRight: 0});
      sidebar.velocity('reverse');

      sidebarToggleLine1st.velocity(sidebarToggleLine1stStatusInit);
      sidebarToggleLine2nd.velocity(sidebarToggleLine2ndStatusInit);
      sidebarToggleLine3rd.velocity(sidebarToggleLine3rdStatusInit);

      sidebar.removeClass('sidebar-active');
      sidebar.trigger('sidebar.isHiding');
    };

    function sidebarContentMotion () {
      $('.sidebar .motion-element').velocity(
        'transition.slideRightIn',
        {stagger: 50, drag: true}
      );
    }

    function postsListMotion () {
      var postMotionOptions = window.postMotionOptions || {stagger: 300, drag: true};
      $('.post').velocity('transition.slideDownIn', postMotionOptions);
    }

    function sidebatToggleMotion () {
      sidebarToggle.on('click', function () {
        isSidebarVisible ? sidebarHideMotion() : sidebarShowMotion();
        isSidebarVisible = !isSidebarVisible;
      });

      sidebarToggle.hover(function () {
        if (isSidebarVisible) {return}
        sidebarToggleLine1st.velocity('stop').velocity(sidebarToggleLine1stStatusArrow);
        sidebarToggleLine2nd.velocity('stop').velocity(sidebarToggleLine2ndStatusArrow);
        sidebarToggleLine3rd.velocity('stop').velocity(sidebarToggleLine3rdStatusArrow);
      }, function () {
        if (isSidebarVisible) {return}
        sidebarToggleLine1st.velocity('stop').velocity(sidebarToggleLine1stStatusInit);
        sidebarToggleLine2nd.velocity('stop').velocity(sidebarToggleLine2ndStatusInit);
        sidebarToggleLine3rd.velocity('stop').velocity(sidebarToggleLine3rdStatusInit);
      });
    }
  });

</script>





  

  
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
  });
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for (i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>


  
  
  


  

  
</body>
</html>
