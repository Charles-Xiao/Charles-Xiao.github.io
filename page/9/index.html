<!doctype html>
<html class="theme-next use-motion theme-next-mist">
<head>
  

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






  <link rel="stylesheet" type="text/css" href="../../vendors/fancybox/source/jquery.fancybox.css?v=2.1.5"/>


<link rel="stylesheet" type="text/css" href="../../css/main.css?v=0.4.2"/>


    <meta name="description" content="在码农炼成之路不断挣扎……stay hungry……keep learning……" />



  <meta name="keywords" content="java,android,life,CharlesXiao" />





  <link rel="shorticon icon" type="image/x-icon" href="../..//favicon.ico?v=0.4.2" />



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?6749450";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>


  <title> CharlesXiao‘s Blog </title>
</head>

<body>
<!--[if lte IE 8]> <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'> <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode"><img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820" alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari." style='margin-left:auto;margin-right:auto;display: block;'/></a></div> <![endif]-->
  <div class="container one-column 
   page-home 
">
    <div class="headband"></div>

    <div id="header" class="header">
      <div class="header-inner">
        <h1 class="site-meta">
  <span class="logo-line-before"><i></i></span>
  <a href="/" class="brand">
      <span class="logo">
        <i class="icon-logo"></i>
      </span>
      <span class="site-title">CharlesXiao‘s Blog</span>
  </a>
  <span class="logo-line-after"><i></i></span>
</h1>


  <ul id="menu" class="menu">
     
    <!--增加swiftype搜索功能-->
    <form class="menu-item menu-item-search">
      <input type="text" id="st-search-input" class="st-search-input st-default-search-input" />
    </form>
    
    <script type="text/javascript">
      (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
      (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
      e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
      })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

      _st('install','yxUhPQ2aHyszT_1btxX9','2.0.0');
    </script>
    <!--增加swiftype搜索功能end-->
    
    
      
      <li class="menu-item menu-item-home">
        <a href="../..//">
          <i class="menu-item-icon icon-home"></i> <br />
          首页
        </a>
      </li>
    
      
      <li class="menu-item menu-item-categories">
        <a href="../..//categories">
          <i class="menu-item-icon icon-categories"></i> <br />
          分类
        </a>
      </li>
    
      
      <li class="menu-item menu-item-about">
        <a href="../..//about">
          <i class="menu-item-icon icon-about"></i> <br />
          关于
        </a>
      </li>
    
      
      <li class="menu-item menu-item-archives">
        <a href="../..//archives">
          <i class="menu-item-icon icon-archives"></i> <br />
          归档
        </a>
      </li>
    
      
      <li class="menu-item menu-item-tags">
        <a href="../..//tags">
          <i class="menu-item-icon icon-tags"></i> <br />
          标签
        </a>
      </li>
    
  </ul>


      </div>
    </div>

    <div id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content">
          
  <div id="posts" class="posts-expand">
    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="../../2015/04/08/实习项目总结/">
                实习项目总结
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2015-04-08
        </span>

        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="../../2015/04/08/实习项目总结/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/04/08/实习项目总结/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <h3 id="自我介绍_1min_慢，停顿">自我介绍 1min 慢，停顿</h3><ol>
<li>姓名 —-&gt; 学习经历(中大科大软件专业) 基于兴趣和职业规划 —-&gt; 本科到硕士都注重计算机基础知识积累，对Java语言基础，计算机网络/MySQL数据库原理，常见数据结构和算法比较熟悉，例如常见排序，链表，二叉树，队列栈等；平常对移动端和web端研发也具有浓厚兴趣</li>
<li>一直以来也比较注重实践，陆续参加了几个实习和项目，提现学习和工作能力(先后参与3份实习和2个校内科研项目，选择与岗位相符的两段经历进行1-2句话简述，做了什么和达到了什么成就) </li>
<li>业余爱好，羽毛球，健身，阅读和利用coursera进行业余学习</li>
<li>对目标岗位的理解和想法，应聘该岗位的强烈意愿以及自身吻合度</li>
<li>经历：前期社会活动兴趣的广泛性+后期对专业的专注性；性格：程序员中的外向型</li>
</ol>
<h3 id="网易">网易</h3><ol>
<li>学习Spring框架使用和原理</li>
<li>接口实现</li>
<li>网易实习时有挑战性的地方以及，最大的贡献<ul>
<li>自己扮演的角色应该是<strong>需求开发者和主动学习者的角色</strong> ①快速学习能力的体现以及快速学习的方法，学习使用redis，Spring框架开发restful 数据接口②沟通与合作：与产品，前端，测试之间分工合作②贡献818的部分核心需求，开奖时服务端通过张连接WebSocket主动推送给app开奖信息；设置一个观察者观察开奖数据；然后查表中未中奖用户的信息进行推送</li>
</ul>
</li>
</ol>
<h3 id="Kactus">Kactus</h3><ol>
<li>ECO餐厅食用油回收系统<ul>
<li>Android端缓存机制的实现，采用二级缓存，LRUcache内存缓存和DiskLruCache文件缓存，同时模拟浏览器缓存机制来分析http请求过程的请求头内容来确定cache-control策略<ol>
<li><strong>App请求server数据流程</strong>: 当我们第一次打开应用获取图片时，先到网络去下载图片，然后依次存入内存缓存，磁盘缓存;以后每次加载图片的时候都优先去LRUCache内存缓存当中读取，当读取不到的时候则回去DiskLruCache硬盘缓存中读取，而如果硬盘缓存仍然读取不到的话，就从网络上请求原始数据。</li>
<li><strong>App的二级缓存实现</strong>: 变化频繁的小数据(例如订单列表)都采用LRUCache,以<url, data="">的键值对形式存储数据, 缓存时间为应用开启到关闭时间段; 稳定的大文件数据(例如图片)采用DiskLruCache,缓存时间可以根据需求自定义;LruCache和DiskLruCache的原理实际上是LinkedHashMap和File;</url,></li>
<li><strong>缓存管理和清理策略</strong>：<ul>
<li>① <strong>现用方法</strong>App根据服务器响应头部里边的expires(缓存过期的时间（绝对时间）),Last-Modified(服务器响应的资源最终修改时间), Cache-Control(资源的有效期)等内容来确定是否需要将数据缓存到DiskLruCache中，以及缓存的保留时间，<strong>具体实现</strong> 每次请求url得到响应结果时会解析头部Cache-Control去判断该响应资源是否需要缓存以及缓存过期时间等内容；然后将资源URL和这些缓存时间相关的http头部信息(比如expires(缓存过期的时间))一起存储到SQLite数据库，然后每次加载资源都会先根据url查询数据库看本地缓存是否过期，是否需要重新发送网络请求并更新缓存        </li>
<li>② <strong>其它方法</strong>每次去读取缓存文件时先调用File.lastModified()方法得到文件的最后修改时间，与当前时间相减得到已缓存时间,然后根据自定义的缓存时间判断该缓存是否过期，如果过期则重新请求文件，不然直接从缓存加载，这样就能实现缓存文件定时清理</li>
<li>③ <strong>每次服务器资源变化时客户端怎么得到通知？</strong>, 客户端定时轮询请求某个指定url并解析返回的json判断某些数据是否变化，变化就重新请求该数据; 或者手动刷新，socket长连接</li>
</ul>
</li>
<li><ul>
<li><strong>FIFO</strong>First In First Out，先进先出;核心原则就是：如果一个数据最先进入缓存中，则应该最早淘汰掉。也就是说，当缓存满的时候，应当把最先进入缓存的数据给淘汰掉。</li>
<li><strong>LFU</strong>：Least Frequently Used，最不经常使用;在一段时间内，数据被使用次数最少的，优先被淘汰。</li>
<li><strong>LRU</strong>: Least Recently Used，最近最少使用策略，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高”；简单的说就是缓存一定量的数据，当超过设定的阈值时就把一些<strong>最近最少使用的数据</strong>删除掉;<strong>最常见的实现算法</strong>是使用一个链表保存缓存数据，①新数据插入到链表头部；②每当缓存命中（即缓存数据被访问），则将数据移到链表头部；③当链表满的时候，将链表尾部的数据丢弃。<a href="https://segmentfault.com/a/1190000003743083" target="_blank" rel="external">LRUCache双向链表+HashMap实现</a> <a href="https://segmentfault.com/a/1190000005922083" target="_blank" rel="external">LRUCache LinkedHashMap实现</a></li>
<li><strong>LRU-K</strong>中的K代表最近使用的次数，因此LRU可以认为是LRU-1。LRU-K的主要目的是为了解决LRU算法“缓存污染”的问题，其核心思想是将“最近使用过1次”的判断标准扩展为“最近使用过K次”。<strong>实现</strong>：相比LRU，LRU-K需要多维护一个队列，用于记录所有缓存数据被访问的历史。只有当数据的访问次数达到K次的时候，才将数据放入缓存。当需要淘汰数据时，LRU-K会淘汰第K次访问时间距当前时间最大的数据</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ol>
<pre><code>缓存图片举例：


        <span class="comment">// 获取应用可占内存的1/8作为缓存</span>
        <span class="built_in">int</span> maxSize = (<span class="built_in">int</span>) (Runtime.getRuntime().maxMemory() / <span class="number">8</span>);
        <span class="comment">// 实例化LruCaceh对象</span>
        mLruCache = <span class="keyword">new</span> LruCache&lt;<span class="keyword">String</span>, Bitmap&gt;(maxSize) {
            @Override
            <span class="keyword">protected</span> <span class="built_in">int</span> sizeOf(<span class="keyword">String</span> <span class="variable">key</span>, Bitmap bitmap) {
                <span class="keyword">return</span> bitmap.getRowBytes() * bitmap.getHeight();
            }
        };
         mDiskLruCache=DiskLruCache.<span class="built_in">open</span>(getDiskCacheDir(context.getApplicationContext(),
         <span class="string">"xxxxx"</span>),     getAppVersion(context), <span class="number">1</span>, DISKMAXSIZE);
        <span class="comment">// 缓存操作</span>
        mLruCache.<span class="built_in">get</span>(url);
        mLruCache.put(url, bitmap);
        bitmap = BitmapFactory.decodeStream(mDiskLruCache.<span class="built_in">get</span>(url).getInputStream(<span class="number">0</span>));
        DiskLruCache.Editor editor = mDiskLruCache.edit(<span class="variable">key</span>);
        OutputStream outputStream = editor.newOutputStream(<span class="number">0</span>);
        editor.commit();
</code></pre><ol>
<li><p>采用Java WebSocket编程取代传统的非实时http请求连接模式</p>
<ul>
<li><p><strong>为什么要用WebSocket实时交互数据？</strong>: 传统Web应用的信息交互过程通常是客户端发出一个请求，服务器端接收和审核完请求后进行处理并返回结果给客户端，然后客户端浏览器将信息呈现出来，但是对于那些实时要求比较高的应用来说，比如说在线游戏、新闻在线播报、RSS 订阅推送等等，当客户端浏览器准备呈现这些信息的时候，这些信息在服务器端可能已经过时了;所以我们考虑采用webSocket    <strong>常见的模拟实时应用方法</strong> </p>
<p>  <strong>轮询</strong>：最早的一种实现实时 Web 应用的方案。客户端以一定的时间间隔向服务端发出请求，以频繁请求的方式来保持客户端和服务器端的同步。服务器端的数据可能并没有更新但是依然请求，会带来很多无谓的网络传输，所以这是一种非常低效的实时方案。  </p>
<p>  <strong>长轮询</strong>：为了降低无效的网络传输，当服务器端没有数据更新的时候，连接会保持一段时间周期直到数据或状态改变或者时间过期，通过这种机制来减少无效的客户端和服务器间的交互  </p>
<p>  <strong>流</strong>： 流技术方案通常就是在客户端的页面使用一个隐藏的窗口向服务端发出一个长连接的请求。服务器端接到这个请求后作出回应并不断更新连接状态以保证客户端和服务器端的连接不过期。通过这种机制可以将服务器端的信息源源不断地推向客户端。这种机制需要针对不同的浏览器设计不同的方案来改进用户体验，同时这种机制在并发比较大的情况下，对服务器端的资源是一个极大的考验。</p>
<p>  <strong>WebSocket原理和建立过程</strong>: WebSocket是一个基于TCP连接的双向通道；为了建立一个 WebSocket 连接，客户端浏览器首先要向服务器发起一个 HTTP 请求，这个请求和通常的 HTTP 请求不同，包含了一些附加头信息，其中附加头信息”Upgrade: WebSocket”表明这是一个申请协议升级的 HTTP 请求，服务器端解析这些附加的头信息然后产生应答信息返回给客户端，客户端和服务器端的 WebSocket 连接就建立起来了，双方就可以通过这个连接通道自由的传递信息，并且这个连接会持续存在直到客户端或者服务器端的某一方主动的关闭连接。    </p>
<pre><code><span class="annotation">@ServerEndpoint</span>(<span class="string">"/websocket"</span>)
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSocketTest</span> </span>{

  <span class="annotation">@OnMessage</span>
  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(String message, Session session)</span>
    <span class="keyword">throws</span> IOException, InterruptedException </span>{

    System.out.println(<span class="string">"Received: "</span> + message);

    <span class="comment">// Send the first message to the client</span>
    session.getBasicRemote().sendText(<span class="string">"This is the first server message"</span>);

    <span class="comment">// Send 3 messages to the client every 5 seconds</span>
    <span class="keyword">int</span> sentMessages = <span class="number">0</span>;
    <span class="keyword">while</span>(sentMessages &lt; <span class="number">3</span>){
      Thread.sleep(<span class="number">5000</span>);
      session.getBasicRemote().
        sendText(<span class="string">"This is an intermediate server message. Count: "</span>
          + sentMessages);
      sentMessages++;
    }

    <span class="comment">// Send a final message to the client</span>
    session.getBasicRemote().sendText(<span class="string">"This is the last server message"</span>);
  }

  <span class="annotation">@OnOpen</span>
  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onOpen</span><span class="params">()</span> </span>{
    System.out.println(<span class="string">"Client connected"</span>);
  }

  <span class="annotation">@OnClose</span>
  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClose</span><span class="params">()</span> </span>{
    System.out.println(<span class="string">"Connection closed"</span>);
  }

}
</code></pre><p>  <strong>如何使用Encoder和Decoder传输更复杂的数据</strong>：Websocket使用Decoder将文本消息转换成Java对象，然后传给@OnMessage方法处理; 而当对象写入到session中时，Websocket将使用Encoder将Java对象转换成文本，再发送给客户端。</p>
</li>
<li><p>整个项目从简单的多线程优化到采用线程池来实现xml数据文件的获取</p>
</li>
<li>总体项目图<br><img src="https://raw.githubusercontent.com/Charles-Xiao/Charles-Xiao.github.io/master/images/kactus项目.JPG" width="100%"></li>
</ul>
</li>
</ol>
<h3 id="Baidu">Baidu</h3><ol>
<li><p>Duwear项目短信管理模块: 目的是将手机短信库的变化情况通知到wear端</p>
<ol>
<li><strong>SMSObserver</strong>继承ContentProvider类实现观察者模式，注册了一个短信数据库的观察者，发生变化该类都会被通知；在重载函数onChange中进行操作比对判断数据库变化情况，只知道变化，但是不知道具体操作？如何判断用户是标为已读还是删除，新建短信</li>
<li><strong>SmsReceivedListener接口</strong>：两个回调函数，作为一个接口参数传到SMSObserver的构造函数中，然后一旦判断是新短信还是短信已读，就调用其回调函数</li>
<li><strong>SmsRpcService类</strong>：继承自上边的接口，在回调函数中将这个操作判断出来发送给手表</li>
<li><strong>SmsUtils</strong>: 4个函数，查询短信数据库，标为已读的数据库操作函数</li>
<li><p>SMSObserver类中的具体的判断方式和优化过程</p>
<ul>
<li>从维护所有信息的set到只维护未读信息的内容，信息实体占用内存很大，内存优化；</li>
<li><p>ArrayList到HashSet对比与区别：防止出现重复信息，去重速度很快因为使用HashTable中的hashCode()以及equals进行查找去重；</p>
</li>
<li><p>多次读取unreadSet并对两个set进行比对，removeAll和AddAll求补集并集来比对两个未读信息集合;两个方法都用到了hashCode和equals，所以SmsEntity对象中hashcode和equals方法的同时重载；直接removeAll新set可以判断出哪些信息被标为已读，AddAll新set再removeAll旧set可以判断得到新增加的短信；比如1，2，3和1，2，4，5</p>
</li>
<li><p><strong>java集合中的浅复制和深复制，clone集合不影响原集合</strong></p>
<ol>
<li><p><strong>浅复制</strong>: 复制后的对象与原对象所有变量的值相同，包括引用变量，浅复制时只会复制引用变量本身，不会复制它指向的对象本身</p>
</li>
<li><p><strong>深复制</strong>: 复制后的对象与原对象所有变量的值相同，但是不包括引用变量，深复制时会复制引用变量指向的对象本身，所以引用值发生改变</p>
</li>
<li><p><strong>Clone()方法和Cloneable接口</strong>: Cloneable接口是一个不包含方法的标志接口，一个类必须先继承它才能在其内部调用super.clone()方法，否则会抛出不支持clone的异常;clone()方法是一个native方法，拷贝对象时已经包括一部分原对象信息，效率优于使用新建对象再一一复制变量的方式;重写clone()方法需要先调用super.clone()方法，该方法会开辟一块新的内存用于拷贝原对象，将原对象的内容一一复制到新对象的内存空间中，它是一种浅复制;如果要实现深复制，需要对复制的对象中的所有引用变量对应的对象也进行复制(具体操作:重写引用对象的clone方法，在其中调用super.clone，然后在上层对象的重载clone方法中调用该对象的clone方法)</p>
</li>
<li><p><strong>序列化实现深复制</strong>: 序列化主要用于将内存中对象状态写入数据库或者文件，以及利用Socket在网络中传输对象;一个对象要能够被序列化需要该类实现Serializable接口，可序列化类的子类默认也是可以被序列化的，不需要再次实现Serializable接口；利用序列化进行深复制的前提是该对象及其内部的引用到的对象都是可序列化的，这样对对象序列化时才能递归地保存对象及其引用对象的数据</p>
<pre><code>deepClone() {    
   <span class="comment">//序列化:将内存中对象状态转化为字节流，写入目标输出流</span>
   ByteArrayOutoutStream bo=<span class="keyword">new</span> ByteArrayOutputStream();    
   ObjectOutputStream oo=<span class="keyword">new</span> ObjectOutputStream(bo);
   <span class="comment">//    </span>
   oo.writeObject(<span class="keyword">this</span>);    
   <span class="comment">//反序列化:读取源输入流中的字节流重建一个内存中相同状态的对象     </span>
   ByteArrayInputStream bi=<span class="keyword">new</span> ByteArrayInputStream(bo.toByteArray());    
   ObjectInputStream oi=<span class="keyword">new</span> ObjectInputStream(bi);    
   <span class="keyword">return</span>(oi.readObject());    
}
</code></pre></li>
<li><p>当一个类声明要实现Serializable接口时，只是表明该类参加序列化协议;Java提供的ObjectInputStream和ObjectOutputStream将数据流功能扩展至可读写对象 。在ObjectInputStream中用readObject()方法可以直接读取一个对象，ObjectOutputStream中用writeObject()方法可以直接将对象保存到输出流中; 序列化只能保存对象的非静态成员变量，不能保存任何的成员方法和静态成员变量，而且序列化保存的只是变量的值，对于变量的任何修饰符都不能保存。          </p>
</li>
</ol>
</li>
</ul>
</li>
<li><strong>工厂模式</strong>生产手表View：需要生成许多不同的CardView，利用CardFactory中的BuildPage函数<ul>
<li>简单工厂模式:工程类+抽象产品类+具体产品类；根据参数的不同返回不同类的实例。专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类</li>
<li>工厂方法模式: 抽象产品角色，具体产品角色，抽象工厂角色，具体工厂角色;工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类;一个抽象产品类，可以派生出多个具体产品类。一个抽象工厂类，可以派生出多个具体工厂类。每个具体工厂类只能创建一个具体产品类的实例。</li>
<li>抽象工厂模式: 多个抽象产品类，每个抽象产品类可以派生出多个具体产品类。一个抽象工厂类，可以派生出多个具体工厂类。每个具体工厂类可以创建多个具体产品类的实例。</li>
</ul>
</li>
</ol>
</li>
<li><p>百度锁屏项目: <a href="https://charles-xiao.github.io/2016/05/18/Android%E8%87%AA%E5%AE%9A%E4%B9%89View%E5%AE%9E%E7%8E%B0%E6%80%BB%E7%BB%93-%E4%BB%A5%E7%99%BE%E5%BA%A6%E9%94%81%E5%B1%8F%E9%A1%B9%E7%9B%AE%E7%95%8C%E9%9D%A2%E4%B8%BA%E4%BE%8B/" target="_blank" rel="external">View的自定义绘制与组合原理过程</a></p>
</li>
</ol>
<ol>
<li><p><strong>网络通信的优化和实现过程</strong>http从同步的主线程发送get请求优化为异步的子线程发送post请求, 加强了数据传输的安全性和长度，解决了应用程序无响应的应用体验问题; httpClient和HttpUrlConnection的区别对比;最后学习和使用Volley以及OkHttp通信库<br><a href="http://www.jianshu.com/p/3141d4e46240#Volley&amp;OkHttp" target="_blank" rel="external">参考链接</a></p>
<ol>
<li><p>异步的get和post请求实现过程(HttpUrlConnection)</p>
</li>
<li><p><strong>httpClient和httpUrlConnection, OKHttp对比</strong>：</p>
<ul>
<li>httpClient是apache的开源实现，API数量多，非常稳定</li>
<li>httpUrlConnection是java自带的模块: ①可以直接支持GZIP压缩,而HttpClient虽然也支持GZIP，但要自己写代码处理 ②httpUrlConnection直接在系统层面做了缓存策略处理，加快重复请求的速度 ③API简单，体积较小,而且直接支持系统级连接池，即打开的连接不会直接关闭，在一段时间内所有程序可共用</li>
<li>HttpURLConnection在Android2.2之前有个重大Bug，调用close()函数会影响连接池，导致连接复用失效，需要关闭keepAlive;因此在2.2之前http请求都是用httpClient，2.2之后则是使用HttpURLConnection</li>
<li>但是!!!现在!!!Android不再推荐这两种方式！二是直接使用OKHttp这种成熟方案！支持Android 2.3及其以上版本; 什么是OKHttp?</li>
</ul>
</li>
<li><strong>Volley原理和OkHttp实现原理和应用方法以及优缺点</strong> <ul>
<li><strong>Volley的调用过程</strong>，通过 newRequestQueue(…) 函数新建并启动一个请求队列RequestQueue后，只需要往这个RequestQueue不断 add Request 即可</li>
<li><strong>Volley</strong>：Volley 对外暴露的 API，通过 newRequestQueue(…) 函数新建并启动一个请求队列RequestQueue。</li>
<li><strong>Request</strong>：表示一个请求的抽象类。StringRequest、JsonRequest、ImageRequest 都是它的子类，表示某种类型的请求。</li>
<li><strong>RequestQueue</strong>：表示请求队列，里面包含一个CacheDispatcher(用于处理走缓存请求的调度线程)、NetworkDispatcher数组(用于处理走网络请求的调度线程)，一个ResponseDelivery(返回结果分发接口)，通过 start() 函数启动时会启动CacheDispatcher和NetworkDispatchers。        </li>
<li><strong>HttpStack</strong>：处理 Http 请求，返回请求结果。目前 Volley 中有基于 HttpURLConnection 的HurlStack和 基于 Apache HttpClient 的HttpClientStack，也可以内部采用OKHttp实现 </li>
<li><strong>CacheDispatcher.java</strong>：继承自Thread，用于调度处理「缓存请求」。启动后会不断从缓存请求队列中取请求处理，队列为空则等待，请求处理结束则将结果传递给ResponseDelivery去执行后续处理。当结果未缓存过、缓存失效或缓存需要刷新的情况下，该请求都需要重新进入NetworkDispatcher去调度处理。</li>
<li><strong>NetworkDispatcher.java</strong>：继承自Thread，用于调度处理「网络请求」。启动后会不断从网络请求队列中取请求处理，队列为空则等待，请求处理结束则将结果传递给ResponseDelivery去执行后续处理，并判断结果是否要进行缓存。 </li>
</ul>
</li>
</ol>
<ul>
<li><p><strong>Volley与Activity生命周期联动与取消请求</strong>:为了在Activity退出或销毁的时候，取消对应的网络请求，避免网络请求在后台浪费资源；我们使用Volley的话，可以在Activity停止的时候，同时取消所有或部分未完成的网络请求，这些请求将不会被返回给主线程，取消操作一般在onStop()函数里边执行</p>
<pre><code> <span class="comment">// 遍历整个Activity中的请求集合，例如List</span>
 <span class="keyword">for</span> (Request &lt;?&gt; req : mRequestQueue) {  
    req.cancel();  
}
<span class="comment">// 取消整个队列中的请求 </span>
mRequestQueue.cancelAll(<span class="keyword">this</span>);
<span class="comment">// 根据RequestFilter或者Tag来终止某些请求</span>
mRequestQueue.cancelAll( <span class="keyword">new</span> RequestFilter() {});    
mRequestQueue.cancelAll(<span class="keyword">new</span> <span class="built_in">Object</span>());
</code></pre></li>
<li><p><strong>流程图解</strong>：<br>  第一步：主线程根据优先级把请求加入缓存队列<br>  第二步：「缓存调度线程」CacheDispatcher从缓存队列中取出一个请求，如果缓存命中，就读取缓存响应并解析，然后将结果返回到主线程<br>  第三步：缓存未命中，该请求被加入网络请求队列，「网络调度线程」NetworkDispatcher(一个默认值为4的线程池)从网络队列中轮询取出请求，进行HTTP请求传输，解析响应，写入缓存，然后将结果返回到主线程  </p>
<p><img src="https://raw.githubusercontent.com/Charles-Xiao/Charles-Xiao.github.io/master/images/Volley.png" class="full-image" width="100%">    </p>
<p><a href="http://a.codekk.com/detail/Android/grumoon/Volley%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90" target="_blank" rel="external">Volley源码分析</a></p>
<p><strong>Volley用法</strong>  </p>
<pre><code> RequestQueue mQueue <span class="subst">=</span> Volley<span class="built_in">.</span>newRequestQueue(context);
 StringRequest stringRequest <span class="subst">=</span> <span class="literal">new</span> StringRequest
 (Method<span class="built_in">.</span>POST, <span class="string">"http://www.baidu.com"</span>,  
<span class="literal">new</span> Response<span class="built_in">.</span>Listener<span class="subst">&lt;</span><span class="built_in">String</span><span class="subst">&gt;</span>() {  
    @Override  
    <span class="keyword">public</span> <span class="literal">void</span> onResponse(<span class="built_in">String</span> response) {  
        <span class="keyword">Log</span><span class="built_in">.</span>d(<span class="string">"TAG"</span>, response);  
    }  
}, <span class="literal">new</span> Response<span class="built_in">.</span>ErrorListener() {  
    @Override  
    <span class="keyword">public</span> <span class="literal">void</span> onErrorResponse(VolleyError error) {  
        <span class="keyword">Log</span><span class="built_in">.</span>e(<span class="string">"TAG"</span>, error<span class="built_in">.</span>getMessage(), error);  
    }  
}){
@Override  
 <span class="keyword">protected</span> <span class="built_in">Map</span><span class="subst">&lt;</span><span class="built_in">String</span>, <span class="built_in">String</span><span class="subst">&gt;</span> getParams() throws AuthFailureError {  
     <span class="built_in">Map</span><span class="subst">&lt;</span><span class="built_in">String</span>, <span class="built_in">String</span><span class="subst">&gt;</span> <span class="built_in">map</span> <span class="subst">=</span> <span class="literal">new</span> HashMap<span class="subst">&lt;</span><span class="built_in">String</span>, <span class="built_in">String</span><span class="subst">&gt;</span>();  
     <span class="built_in">map</span><span class="built_in">.</span>put(<span class="string">"params1"</span>, <span class="string">"value1"</span>);  
     <span class="built_in">map</span><span class="built_in">.</span>put(<span class="string">"params2"</span>, <span class="string">"value2"</span>);  
     <span class="keyword">return</span> <span class="built_in">map</span>;  
 }  
}; 
 mQueue<span class="built_in">.</span>add(stringRequest); 
</code></pre></li>
</ul>
</li>
</ol>
<p><strong>OkHttp用法</strong><a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0326/2643.html" target="_blank" rel="external">源码分析</a></p>
<p><img src="https://raw.githubusercontent.com/Charles-Xiao/Charles-Xiao.github.io/master/images/OkHttp.png" class="full-image"></p>
<pre><code>OkHttpClient mOkHttpClient = <span class="keyword">new</span> OkHttpClient();
FormEncodingBuilder builder = <span class="keyword">new</span> FormEncodingBuilder();   
builder.add(<span class="string">"username"</span>,<span class="string">"value"</span>);

Request request = <span class="keyword">new</span> Request.Builder()
                   .url(url)
                .post(builder.build())
                .build();
mOkHttpClient.newCall(request).enqueue(<span class="keyword">new</span> Callback(){
    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Request request, IOException e)</span>
    </span>{
    }

    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(<span class="keyword">final</span> Response response)</span> <span class="keyword">throws</span> IOException
    </span>{
            <span class="comment">//String htmlStr =  response.body().string();</span>
    }
});
</code></pre><h3 id="毕设-WebCrawler项目">毕设-WebCrawler项目</h3><p>java优先级队列；Java多线程处理，线程池，html页面解析等</p>
<p>单例模式enum实现对MySQL数据库操作的优势</p>
<h3 id="开放性问题">开放性问题</h3><ol>
<li>说一个你曾独立或者作为核心去解决了的一个“有趣有难度”且过程很详细的步步深入优化的<strong>技术问题or项目</strong><ul>
<li>贡献和成果: 核心问题的效率优化过程与方法</li>
<li>困难:体现解决问题的方法与能力</li>
<li><strong>思路</strong>：如果说有趣有难度的项目的话，我想说说kactus的食用油回收项目；在这个项目中参与时间长达半年，技术成长较大；<strong>这个项目主要是用来开发</strong>一个后台管理系统和Android app，包括司机和经理，用于订单处理和发布；在这个项目中，<strong>我参与了整个项目的研发</strong>，包括3个主要部分，①通过Java http和WebSocket请求订单数据，利用生产者消费者模式和多线程池提高并发读写效率 ②操作数据库制作RESTful API给移动端app使用 ③移动端app的开发以及二级缓存的优化实现</li>
</ul>
</li>
<li><strong>成就感最大的一件事</strong>: 比如学习,比赛,需要体现<strong>创新性的成果和idea</strong>：高德LBS的比赛全国八强，做了什么？为什么有成就感？从日常生活出发想出一个创新的idea，然后结合课程理论进行实践，到最后拿奖这样一个过程。</li>
<li>团队合作沟通能力和Team领导力</li>
<li><p><strong>如何白板写代码？？？</strong></p>
<ul>
<li>Show your idea,，例如白板写代码，遇到新问题即使不知道也可以开始分析，手动画图描述问题的解决过程，从思路到设计测试用例手动输入，一步步归纳出最终解法，转化成代码</li>
<li>解决问题的多角度性，从小问题和具体性问题开始入手，一步步递进归纳算法；遇到细节性或者较难实现的问题，可以先声明一个函数及其相应功能，留到后边再完善，代码效率的优化同样可以放到后边再做，思路的流畅性和清晰很重要。</li>
<li>主动单元测试，边缘情况测试，null，空字符串，StringUtils.isBlank(str)</li>
</ul>
</li>
<li><p>遇到生活学习上的<strong>印象中最大的困难或者挫折</strong>？最后怎么解决的？</p>
<ul>
<li>留学的DIY过程是一个比较困难的过程。为什么？绝大多数人会选择找中介，会省事很多，整个流程和材料的准备都不需要自己动手，但是我选择了自己DIY，所以在这一路的申请过程中遇到不少的挫折和困难，①对于留学的讯息了解不够 , ②准备考雅思 ③文书材料的撰写和修改；</li>
<li>最终这一路申请过程中虽然遇到各种困难，但是最终还是受益颇多，其实我本来自己DIY的原因就是我自己觉得申请过程其实是一次很好的审视自我的过程，也为我自己才是最了解我自己的人；不管结果如何，申请这个过程就是一段很好的人生经历，虽然遇到各种困难，但是一一克服，最终也有了一个比较好的结果，拿到了几家不错的offer</li>
</ul>
</li>
<li><p><strong>最大缺点</strong>: 这个问题好难回答啊！我想想……</p>
<pre><code><span class="bullet">* </span>我的缺点是比较专注和执着，比如在技术方面比较爱钻研，有的时候会为了研究一个技术问题，不断地沉浸在里边，不弄明白不罢休，到饭点了都能忘，晚上在公司研究到很晚才撤退。最近出的那个电脑端和手机端同步功能就很好，可以利用零碎时间看博客解决问题了
<span class="bullet">* </span>还有就是，工作比较按部就班，总是按照项目经管的要求完成任务。另外的缺点是，总在息的工作范围内有创新意识，并没有扩展给其他同事。这些问题我想我可以进入公司后以最短的时间来解决，我的学习能力很强，我相信可以很快融入公司的企业文化，进入工作状态。我想就这些吧。
</code></pre></li>
<li><strong>最大的特点或者优势</strong>：基础知识+创新能力</li>
<li><strong>最感兴趣的课程</strong> 本科阶段的话，最感兴趣的是移动端开发，</li>
<li><strong>最感兴趣的运动或者业余爱好，长期坚持的爱好</strong>: 羽毛球，吉他</li>
<li><strong>性格特征</strong><ul>
<li><strong>对感兴趣的技术会在业余时间去主动学习</strong>，刷刷coursera学习普林斯顿的算法课程学习常见算法堆排，买机器学习的书学KNN, 决策树 mapreduce相关知识</li>
<li><strong>学习和做工程时愿意深入了解和钻研，多问为什么？</strong>例如做Kactus的回收油系统，从做移动端应用开发，我就会去考虑我拿的数据怎么来的，所以就会自己写程序去拿数据，拿到数据存到数据库，怎么做API把数据给移动端用，也自己做了，还会主动考虑着怎么去优化客户端体验，做二级缓存，怎么并行化收发数据来提高效率，怎么比较不同的http库去提高网络请求效率</li>
<li><strong>能够发现生活细节，主动去发现问题，提出想法</strong>:比如高德项目，项目来源就是出去旅游发现人文景点不知道典故不好玩，看到有导游，怎么不用手机APP来做？，当时也有一些其他想法，比如运动分享记录APP</li>
<li><strong>程序员中的外向者，善于与人交流沟通和参与社会活动</strong>从本科阶段的支教，社会调研等社会活动可以看出来</li>
</ul>
</li>
<li><strong>三个词形容自己</strong>：专注深入，发现问题(细心)，淡定(有耐心的解决问题)</li>
<li><strong>职业规划</strong>: ：我希望从现在开始，1-2年之内能够在我目前的这个职位上沉淀下来，通过不断的努力后，最好能有晋升，希望3-5年内可以通过在现有的开发岗位上的不断学习和历练，基于现在的项目和平台，包括现在项目所提供的数据背景，条件，能够培养自己的大局观，逐步地从开发到架构，提升自己的业务水平</li>
<li>对比一下网易和百度的不同？整体的规范性，团队年轻，沟通非常顺利</li>
<li><strong>这么多实习过程中最大的收获？</strong>①将理论和实践相结合的机会，了解到为什么学理论，并将学到的付诸于实践，做出真正可用的给成千上万的用户带去便利的产品，是件很有成就感的事情②大公司的开发规范和流程</li>
<li><strong>为什么来北京？</strong>一方面是因为北京互联网工作机会多，类似于BAT之类的好公司好平台都在北京，是一个增长见识，锻炼自我的环境；二. 最优秀的人也在北京，在这样一个充满竞争的平台里，把握机会，成就自我。</li>
<li><strong>你对薪资的要求？</strong>关于薪资的话，我个人倒是没有什么特别的要求，首先，我觉得公司提供的平台和成长更为重要，我会更加关注在这个良好的平台带来的自我能力的提升，这个才是比较长远的；另外，我也相信XX作为一家知名公司，在薪酬待遇上肯定不会差，而且校招也有一个合理的市场offer价格，如果公司对我的能力认同的话，肯定能协商出一个双方满意的offer待遇</li>
<li><strong>如果公司录用你，你将怎样融入新团队开展工作？</strong>作为一个开发工程师而言，进入一个新的工作环境，参与一个新的产品项目我想我首先要积极融入团队，不管是生活上还是工作上，积极主动的沟通才能让我更快地了解整个团队，整个项目，多提问，多思考才能快速进步；然后要对部门的主营业务要有一个了解，了解公司的业务组成部分、业务的发展方向。第二了解我参与项目的开发方式，开发技术栈，架构方式，尽快投入具体的开发工作中。</li>
<li>加入新团队的挑战？你怎么融入？？？新的大模块的从无到有的项目接手的挑战；融入初期的担忧；技术的全局了解和深入快速学习；和团队人员之间的磨合，怎么磨合？</li>
<li>对公司的了解如何？希望获得什么？看中技术沉淀和业务前景；加班多么？压力大么？</li>
</ol>
<h3 id="Tips">Tips</h3><ol>
<li>面试时不要有“我记得 我认为 应该”，可以说我回想一下！一定要慢！声音大！有停顿！</li>
<li>不要说自己的工作简单！！！应该说自己快速高效完成，游刃有余，还能挤出时间自学；这是一个有难度的工作</li>
<li>压力面试时一定要淡定，即使不会也要有自信，有条不紊的回答问题，遭受质疑时要有理有据地说出自己的观点和自己知道的内容，并主动询问面试官的建议</li>
<li>记得问问题。</li>
</ol>
<h3 id="QA">QA</h3><ol>
<li><p>如果在贵司移动开发部门做开发，主要是做哪些产品研发以及需要用到哪些技术知识和基础，我需要在哪些方面进行努力</p>
</li>
<li><p>面试过程中有没有什么地方讲得太快或者不清楚的地方，我可以补充的</p>
</li>
<li><p>如果可以，可否评价一下面试表现，提供一下您的建议和看法</p>
</li>
<li><p>跨平台应用研发，web轻应用和native app的开发前景比较看法</p>
</li>
<li><p>他们做什么业务，用些什么技术，希望面试者具备哪些方面的能力，对于做这个方向的人有什么建议，觉得我在技术上有什么优点和不足这种</p>
</li>
</ol>

        
      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="../../tags/实习/"> #实习 </a>
          
            <a href="../../tags/项目/"> #项目 </a>
          
        </div>
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="../../2015/03/10/计算机网络基础知识/">
                计算机网络基础知识
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2015-03-10
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分类于
            
              <a href="../../categories/编程知识/">编程知识</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="../../2015/03/10/计算机网络基础知识/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/03/10/计算机网络基础知识/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <h2 id="OSI分层模型">OSI分层模型</h2><p><img src="https://raw.githubusercontent.com/Charles-Xiao/Charles-Xiao.github.io/master/images/OSI.png" class="full-image" width="100%"></p>
<h2 id="TCP/IP四层参考模型">TCP/IP四层参考模型</h2><p><a href="http://www.cnblogs.com/BlueTzar/articles/811160.html" target="_blank" rel="external">TCP/IP四层参考模型，每一层对应的协议， TCP/IP报文格式，UDP和TCP数据段格式，IP头部（报头）格式以及各字段含义，TCP头部结构,套接字</a></p>
<h2 id="Http/Https/UDP/TCP/Socket区别与联系">Http/Https/UDP/TCP/Socket区别与联系</h2><p><img src="https://raw.githubusercontent.com/Charles-Xiao/Charles-Xiao.github.io/master/images/http0.png" class="full-image" width="100%"></p>
<h2 id="TCP协议">TCP协议</h2><h3 id="TCP报文Header">TCP报文Header</h3><p><img src="https://raw.githubusercontent.com/Charles-Xiao/Charles-Xiao.github.io/master/images/TCP-header.jpg" class="full-image" width="100%"></p>
<ol>
<li><strong>ACK</strong> ：TCP协议规定，只有ACK=1时有效，也规定连接建立后所有发送的报文的ACK必须为1</li>
<li><strong>SYN(SYNchronization)</strong> ： 在连接建立时用来同步序号。当SYN=1而ACK=0时，表明这是一个连接请求报文。对方若同意建立连接，则应在响应报文中使SYN=1和ACK=1. 因此,  SYN置1就表示这是一个连接请求或连接接受报文。</li>
<li><strong>FIN （finis）</strong>即完，终结的意思，用来释放一个连接。当 FIN = 1 时，表明此报文段的发送方的数据已经发送完毕，并要求释放连接。</li>
</ol>
<h3 id="TCP协议中的三次握手和四次挥手"><a href="http://blog.csdn.net/oney139/article/details/8103223" target="_blank" rel="external">TCP协议中的三次握手和四次挥手</a></h3><ol>
<li><p><strong>TCP三次握手</strong>：实质是client和server之间的报文段交换过程，三次握手之后client和server之间才能相互发送包含数据的报文段</p>
<ul>
<li><strong>第一次握手</strong>：客户端发送一个SYN报文段(该报文段头部SYN标志位=1, ACK标志位=0,起始序号seq=x)到服务器进行连接请求，等待服务器回复确认；此时客户端进入SYN_SENT状态</li>
<li><strong>第二次握手</strong>：服务器收到客户端发送的连接请求报文段之后,给这个TCP连接分配TCP缓存和变量等资源，并回复一个允许连接的确认报文段叫做SYNACK报文段(SYN=1,ACK=1,seq=y，确认号ack=x+1)，此时服务器进入SYN_RECV状态</li>
<li><strong>第三次握手</strong>：客户端收到服务器的SYNACK报文段之后，也给这个TCP连接分配TCP缓存和变量等资源，并向服务器发送确认ACK报文段(ack=y+1，ACK=1,seq=x+1)，发送完毕之后客户端和服务器进入ESTABLISHED状态，完成三次握手</li>
<li><strong>如图所示</strong>：<br><img src="https://raw.githubusercontent.com/Charles-Xiao/Charles-Xiao.github.io/master/images/TCP3.jpg" class="full-image" width="100%"></li>
</ul>
</li>
<li><p><strong>TCP四次挥手</strong>：实质是client和server之间的报文段交换过程,TCP是全双工模式需要client和server双方各自关闭,比如server接收到client发来的FIN报文段时只意味client将没有数据再发来，但是自己还是可以继续发送数据，client不能发送数据但是依旧可以接收数据。</p>
<p> <img src="https://raw.githubusercontent.com/Charles-Xiao/Charles-Xiao.github.io/master/images/TCP4.jpg" class="full-image" width="100%"></p>
</li>
<li><p><strong>相关问题</strong>：</p>
<ul>
<li><strong>为什么连接的时候是三次握手，关闭的时候却是四次握手？</strong><br>答：因为在三次握手时，当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文，其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手</li>
<li><strong>为什么需要三次握手而不是两次，客户端为什么最后还要发送一次确认？</strong><br>答：主要目的是为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误；<strong>例如</strong>：当client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段，但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。</li>
<li><strong>为什么需要图中的起始序号seq=x是一个随机值？</strong><br>答：采用随机产生的初始化序列号进行请求，这样做主要是出于网络安全的因素着想；如果不是随机产生初始序列号，黑客将会以很容易的方式获取到你与其他主机之间通信的初始化序列号，并且伪造序列号进行攻击，这已经成为一种很常见的网络攻击手段</li>
<li><strong>为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？</strong><br>答：虽然按道理，四次握手之后四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假设网络是不可靠的，有可能最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文</li>
</ul>
</li>
</ol>
<h3 id="TCP流量控制和拥塞控制"><a href="http://blog.csdn.net/yechaodechuntian/article/details/25429143" target="_blank" rel="external">TCP流量控制和拥塞控制</a></h3><h3 id="发展历程">发展历程</h3><ol>
<li>最开始的TCP拥塞控制由“慢启动（slow start）”和“拥塞避免（congestion avoidance）”组成；后来TCP Reno版本中又针对性的加入了“快速重传”、“快速恢复”算法；再后来TCP NewReno中又改进了“快速恢复”；最近又出现了选择性应答（SACK）的算法。</li>
<li>TCP拥塞控制主要依赖于“拥塞窗口（cwnd）”，TCP还有一个对端通告的接收窗口(rwnd)用于流量控制。窗口值的大小就代表能够发送出去的但还没有收到ACK的最大数据报文段，显然窗口越大那么数据发送的速度也就越快，但是也有越可能使得网络出现拥塞。TCP的拥塞控制算法就是要在这两者之间权衡，选取最好的cwnd值，从而使得网络吞吐量最大化且不产生拥塞。</li>
<li>由于需要考虑拥塞控制和流量控制两个方面的内容，因此TCP的真正的发送窗口=min(rwnd, cwnd)。但是rwnd是由对端确定的，网络环境对其没有影响，所以在考虑拥塞的时候我们一般不考虑rwnd的值。我们暂时只讨论如何确定cwnd值的大小。关于cwnd的单位，在TCP中是以Byte来做单位的，我们假设TCP每次传输都是按照MSS大小来发送数据的，因此你可以认为cwnd按照数据包个数来做单位也可以理解，所以有时我们说cwnd增加1也就是相当于字节数增加1个MSS大小。</li>
</ol>
<h3 id="慢启动">慢启动</h3><p>   方法：根据网络情况逐步增加每次发送的数据量。</p>
<p>   原因：最初的TCP在连接建立成功后会向网络中发送大量的数据包，这样很容易导致网络中路由器缓存空间耗尽，从而发生拥塞。</p>
<p>   描述：当新建连接时，cwnd初始化为1个最大报文段(MSS)大小，发送端开始按照拥塞窗口大小发送数据，每当有一个报文段被确认，cwnd就增加1个MSS大小。这样cwnd的值就随着网络往返时间(Round Trip Time,RTT)呈指数级增长，事实上，慢启动的速度一点也不慢，只是它的起点比较低一点而已。如果带宽为W，那么经过RTT*log2W时间就可以占满带宽。  </p>
<p>   <img src="https://raw.githubusercontent.com/Charles-Xiao/Charles-Xiao.github.io/master/images/ssca1.png" class="full-image" width="100%"></p>
<p>   <strong>慢启动引发的性能问题</strong></p>
<p>   在海量用户高并发访问的大型网站后台，有一些基本的系统维护需求。比如迁移海量小文件，就是从一些机器拷贝海量小碎文件到另一些机器，来完成一些系统维护的基本需求。</p>
<p>   举个简单的例子，我们对每个文件都采用独立的TCP连接来传输（循环使用scp拷贝就是这个例子的实际场景，很常见的用法）。那么工作过程应该是，每传输一个文件建立一个连接，然后连接处于慢启动阶段，传输小文件，每个小文件几乎都处于独立连接的慢启动阶段被传输，这样传输过程所用的TCP包的总量就会增多。更细致的说一说这个事，如果在慢启动过程中传输一个小文件，我们可能需要2至3个小包，而在一个已经完成慢启动的TCP通道中（TCP通道已进入在高速传输阶段），我们传输这个文件可能只需要1个大包。网络拷贝文件的时间基本上全部消耗都在网络传输的过程中（发数据过去等对端ACK，ACK确认归来继续再发，这样的数据来回交互相比较本机的文件读写非常耗时间），撇开三次握手和四次握手那些包，粗略来说，慢启动阶段传输这些文件所用的包的数目是高速通道传输这些文件的包的数目的2-3倍！那么时间上应该也是2-3倍的关系！如果文件的量足够大，这个总时间就会被放大到需求难以忍受的地步。</p>
<p>   因此，在迁移海量小文件的需求下，我们不能使用“对每个文件都采用独立的TCP连接来传输（循环使用scp拷贝）“这样的策略，它会使每个文件的传输都处于在一个独立TCP的慢启动阶段。</p>
<p>   <strong>如何避免慢启动，提升性能</strong></p>
<p>   很简单，尽量把大量小文件放在一个TCP连接中排队传输。起初的一两个文件处于慢启动过程传输，后续的文件传输全部处于高速通道中传输，用这样的方式来减少发包的数目，进而降低时间消耗。</p>
<p>   实际上这种传输策略带来的性能提升的功劳不仅仅归于避免慢启动，事实上也避免了大量的3次握手和四次握手，这个对海量小文件传输的性能消耗也非常致命。</p>
<p>   随着多核服务器的兴起，以及现代网卡的多通道技术的迅猛发展，现在我们解决这一问题的通常做法是绑定多CPU的多核到网卡的多个通道，然后由CPU的核来均分传输这些小文件，每个核用一个TCP连接来排队发送分到的小文件。</p>
<ol>
<li><p><strong>拥塞避免</strong></p>
<p>条件：TCP使用了一个叫慢启动门限(ssthresh)的变量，当cwnd超过该值后，慢启动过程结束，进入拥塞避免阶段。对于大多数TCP实现来说，ssthresh的值是65536(同样以字节计算)。</p>
<p>原因：从慢启动可以看到，cwnd可以很快的增长上来，从而最大程度利用网络带宽资源，但是cwnd不能一直这样无限增长下去，一定需要某个限制。</p>
<p>描述：拥塞避免的主要思想是加法增大，也就是cwnd的值不再指数级往上升，开始加法增加。此时当窗口中所有的报文段都被确认时，cwnd的大小加1，cwnd的值就随着RTT开始线性增加，这样就可以避免增长过快导致网络拥塞，慢慢的增加调整到网络的最佳值。<br> <strong>发生拥塞以后怎么办</strong></p>
<p>拥塞发生：TCP认为网络拥塞的主要依据是它重传了一个报文段。上面提到过，TCP对每一个报文段都有一个定时器，称为重传定时器(RTO)，当RTO超时且还没有得到数据确认，那么TCP就会对该报文段进行重传，当发生超时时，那么出现拥塞的可能性就很大，某个报文段可能在网络中某处丢失，并且后续的报文段也没有了消息。</p>
<p>TCP反应：<br><img src="https://raw.githubusercontent.com/Charles-Xiao/Charles-Xiao.github.io/master/images/ssca2.png" class="full-image" width="100%"></p>
</li>
<li><p><strong>快速重传</strong></p>
<p>条件：其实TCP还有一种情况会进行重传：那就是收到3个相同的ACK。TCP在收到乱序到达包时就会立即发送ACK，TCP利用3个相同的ACK来判定数据包的丢失，此时进行快速重传。</p>
<p>描述：<br>   <img src="https://raw.githubusercontent.com/Charles-Xiao/Charles-Xiao.github.io/master/images/ssca3.png" class="full-image" width="100%"></p>
</li>
<li><strong>快速恢复</strong></li>
</ol>
<ul>
<li><p>当收到3个重复ACK时，TCP最后进入的不是拥塞避免阶段，而是快速恢复阶段。快速重传和快速恢复算法一般同时使用。</p>
<p> 思想：“数据包守恒”原则，即同一个时刻在网络中的数据包数量是恒定的，只有当“老”数据包离开了网络后，才能向网络中发送一个“新”的数据包，如果发送方收到一个重复的ACK，那么根据TCP的ACK机制就表明有一个数据包离开了网络，于是cwnd加1。如果能够严格按照该原则那么网络中很少会发生拥塞，事实上拥塞控制的目的也就在修正违反该原则的地方。</p>
<p> 描述：</p>
<pre><code>&lt;img <span class="variable">src=</span><span class="string">"https://raw.githubusercontent.com/Charles-Xiao/Charles-Xiao.github.io/master/images/ssca4.png"</span> <span class="variable">class=</span><span class="string">"full-image"</span> <span class="variable">width=</span><span class="string">"100%"</span>/&gt;
</code></pre></li>
<li>快速重传算法首次出现在4.3BSD的Tahoe版本，快速恢复首次出现在4.3BSD的Reno版本，也称之为Reno版的TCP拥塞控制算法。<br>可以看出Reno的快速重传算法是针对一个包的重传情况的，然而在实际中，一个重传超时可能导致许多的数据包的重传，因此当多个数据包从一个数据窗口中丢失时并且触发快速重传和快速恢复算法时，问题就产生了。因此NewReno出现了，它在Reno快速恢复的基础上稍加了修改，可以恢复一个窗口内多个包丢失的情况。具体来讲就是：Reno在收到一个新的数据的ACK时就退出了快速恢复状态了，而NewReno需要收到该窗口内所有数据包的确认后才会退出快速恢复状态，从而更一步提高吞吐量。</li>
</ul>
<h2 id="UDP协议">UDP协议</h2><h2 id="HTTP协议">HTTP协议</h2><h3 id="Http1-0,_1-1，2-0和https之间的区别">Http1.0, 1.1，2.0和https之间的区别</h3><ol>
<li><strong>HTTP1.0</strong>：规定浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个单独的TCP连接，服务器完成请求处理后立即断开释放TCP连接，服务器不跟踪每个客户也不记录过去的请求。此外，由于大多数网页的流量都比较小，一次TCP连接很少能通过slow-start区，不利于提高带宽利用率。HTTP1.0要建立长连接，可以在请求消息中包含Connection: Keep-Alive头域</li>
<li><strong>HTTP 1.1</strong>支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟。例如：一个包含有许多图像的网页文件的多个请求和应答可以在一个连接中传输，但每个单独的网页文件的请求和应答仍然需要使用各自的连接</li>
<li><strong>HTTP 1.1</strong>还允许客户端不用等待上一次请求结果返回，就可以发出下一次请求，但服务器端必须按照接收到客户端请求的先后顺序依次回送响应结果，以保证客户端能够区分出每次请求的响应内容，这样也显著地减少了整个过程所需要的时间</li>
<li><a href="https://www.jianshu.com/p/be29d679cbff" target="_blank" rel="external">三者区别参考链接</a></li>
</ol>
<h3 id="Http的get和post之间的区别">Http的get和post之间的区别</h3><h3 id="Header和响应码">Header和响应码</h3><p><img src="https://raw.githubusercontent.com/Charles-Xiao/Charles-Xiao.github.io/master/images/http1.png" class="full-image" width="100%"></p>
<p><img src="https://raw.githubusercontent.com/Charles-Xiao/Charles-Xiao.github.io/master/images/HttpRequest.jpeg" class="full-image" width="100%"></p>
<p><img src="https://raw.githubusercontent.com/Charles-Xiao/Charles-Xiao.github.io/master/images/HttpResponse.png" class="full-image" width="100%"></p>
<p><img src="https://raw.githubusercontent.com/Charles-Xiao/Charles-Xiao.github.io/master/images/http头部字段.png" class="full-image" width="100%"></p>
<h3 id="缓存对应的响应头部字段">缓存对应的响应头部字段</h3><ol>
<li><strong><a href="http://www.cnblogs.com/skynet/archive/2012/11/28/2792503.html" target="_blank" rel="external">浏览器缓存机制</a></strong><ul>
<li><strong>Expires</strong>是Web服务器响应消息头字段，在响应http请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求;不过Expires 是HTTP 1.0的东西，现在默认浏览器均默认使用HTTP 1.1，所以它的作用基本忽略</li>
<li><strong>Cache-Control</strong>与Expires的作用一致，都是指明当前资源的有效期，控制浏览器是否直接从浏览器缓存取数据还是重新发请求到服务器取数据。只不过Cache-Control的选择更多，设置更细致，如果同时设置的话，其优先级高于Expires</li>
<li><strong>Last-Modified</strong>：标示这个响应资源的最后修改时间。web服务器在响应请求时，告诉浏览器资源的最后修改时间。</li>
<li><strong>Etag</strong>：web服务器响应请求时，告诉浏览器当前资源在服务器的唯一标识（生成规则由服务器觉得）。Apache中，ETag的值，默认是对文件的索引节（INode），大小（Size）和最后修改时间（MTime）进行Hash后得到的。</li>
<li><strong>既生Last-Modified何生Etag？</strong>：<ul>
<li>Last-Modified标注的最后修改只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，它将不能准确标注文件的修改时间</li>
<li>如果某些文件会被定期生成，当有时内容并没有任何变化，但Last-Modified却改变了，导致文件没法使用缓存</li>
<li>有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致等情形</li>
<li>Etag是服务器自动生成或者由开发者生成的对应资源在服务器端的唯一标识符，能够更加准确的控制缓存。Last-Modified与ETag是可以一起使用的，服务器会优先验证ETag，一致的情况下，才会继续比对Last-Modified，最后才决定是否返回304</li>
</ul>
</li>
<li><strong>浏览器缓存检查流程</strong><br><img src="https://raw.githubusercontent.com/Charles-Xiao/Charles-Xiao.github.io/master/images/browser_cache.png" class="full-image" width="100%"></li>
</ul>
</li>
</ol>
<h2 id="Socket协议">Socket协议</h2><ol>
<li><strong>套接字（socket）</strong>是支持TCP/IP协议的网络通信的基本操作单元，也可以说是应用层和传输层之间的一个软件抽象层；<strong>它包含进行网络通信必须的五种信息</strong>：连接使用的协议，本地主机的IP地址，本地进程的协议端口，远程主机的IP地址，远程进程的协议端口。在创建Socket连接时，可以指定使用的传输层协议，Socket可以支持不同的传输层协议（TCP或UDP），当使用TCP协议进行连接时，该Socket连接就是一个TCP连接</li>
<li><strong>应用层通过传输层进行数据通信时，TCP会遇到同时为多个应用程序进程提供并发服务的问题</strong>：多个TCP连接或多个应用程序进程可能需要通过同一个TCP协议端口传输数据。为了区别不同的应用程序进程和连接，许多计算机操作系统为应用程序与TCP／IP协议交互提供了套接字(Socket)接口。应用层可以和传输层通过Socket接口，区分来自不同应用程序进程或网络连接的通信，实现数据传输的并发服务</li>
<li><strong>套接字之间的连接过程分为三个步骤：服务器监听，客户端请求，连接确认。</strong><ul>
<li><strong>服务器监听</strong>：服务器端套接字并不定位具体的客户端套接字，而是处于等待连接的状态，实时监控网络状态，等待客户端的连接请求。</li>
<li><strong>客户端请求</strong>：指客户端的套接字提出连接请求，要连接的目标是服务器端的套接字。为此，客户端的套接字必须首先描述它要连接的服务器的套接字，指出服务器端套接字的地址和端口号，然后就向服务器端套接字提出连接请求。</li>
<li><strong>连接确认</strong>：当服务器端套接字监听到或者说接收到客户端套接字的连接请求时，就响应客户端套接字的请求，建立一个新的线程，把服务器端套接字的描述发给客户端，一旦客户端确认了此描述，双方就正式建立连接。而服务器端套接字继续处于监听状态，继续接收其他客户端套接字的连接请求</li>
</ul>
</li>
<li><strong>Socket连接与HTTP连接相结合</strong><ul>
<li>通常情况下Socket连接其实就是一个TCP连接，因此Socket连接一旦建立，通信双方即可开始相互发送数据内容，直到双方连接断开。但在实际网络应用中，客户端到服务器之间的通信往往需要穿越多个中间节点，例如路由器、网关、防火墙等，大部分防火墙默认会关闭长时间处于非活跃状态的连接而导致 Socket 连接断连，因此也需要通过http轮询告诉网络，该连接处于活跃状态。</li>
<li>HTTP连接使用的是“请求—响应”的方式，不仅在请求时需要先建立连接，而且需要客户端向服务器发出请求后，服务器端才能回复数据。</li>
<li>很多情况下，我们需要服务器端主动向客户端推送数据，保持客户端与服务器数据的实时与同步。此时若双方建立的是Socket连接，服务器就可以直接将数据传送给客户端；若双方建立的是HTTP连接，则服务器需要等到客户端发送一次请求后才能将数据传回给客户端，因此，客户端定时向服务器端发送连接请求，不仅可以保持在线，同时也是在“询问”服务器是否有新的数据，如果有就将数据传给客户端<h2 id="其它协议">其它协议</h2></li>
</ul>
</li>
</ol>

        
      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="../../tags/Network/"> #Network </a>
          
        </div>
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="../../2015/03/09/Java多进程和多线程编程总结/">
                Java多进程和多线程编程总结
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2015-03-09
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分类于
            
              <a href="../../categories/java学习笔记/">java学习笔记</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="../../2015/03/09/Java多进程和多线程编程总结/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/03/09/Java多进程和多线程编程总结/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <h3 id="进程与线程之间关系">进程与线程之间关系</h3><p>一个进程对应一个程序的执行，它具有文本、数据、堆栈片段以及它自己的资源；而一个线程则是进程执行过程中的一个单独的执行序列，线程有时候也被称为轻量级进程. 一个进程可以包含多个线程，这些线程共享进程的资源。  </p>
<p>首先我们明确一点，就是我们创建的每一个Java程序都是运行在一个单独的Java虚拟机进程中的，每启动一个java程序就会同时开启一个单独对应的JVM进程(也叫做JVM实例)，然后JVM进程会开始初始化类，包括初始化静态变量和静态代码块，普通变量，构造器等；然后再去寻找main()主线程作为程序执行入口,继续执行其他线程直至结束.(Android应用程序和dalvik虚拟机的关系也一样如此)</p>
<h3 id="常见的进程间通信方式(IPC)">常见的进程间通信方式(IPC)</h3><ol>
<li><strong>管道与命名管道</strong>：管道允许一个进程和另一个与它有共同祖先的进程之间进行通信，命名管道允许无亲缘关系的进程间的通信,命名管道在文件系统中有对应的文件名,通过命令mkfifo或系统调用mkfifo来创建</li>
<li><strong>套接字</strong>：可用于不同机器之间的进程间通信</li>
<li><strong>共享内存</strong>：多个进程可以访问同一块内存空间，是最快的可用IPC形式</li>
<li><strong>内存映射</strong>：内存映射允许任何多个进程间通信，每一个使用该机制的进程通过把一个共享的文件映射到自己的进程地址空间来实现它。</li>
<li><strong>信号量</strong>：主要作为进程间以及同一进程不同线程之间的同步手段</li>
<li><strong>信号（Signal）</strong>：信号是比较复杂的通信方式，用于通知接受进程有某种事件发生，除了用于进程间通信外，进程还可以发送信号给进程本身</li>
<li><strong>消息队列</strong>：消息队列是消息的链接表，包括Posix消息队列和system V消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息</li>
</ol>
<h3 id="进程的状态:就绪-运行-阻塞">进程的状态:就绪-运行-阻塞</h3><p><img src="https://raw.githubusercontent.com/Charles-Xiao/Charles-Xiao.github.io/master/images/Linux_ps.png" class="full-image" width="100%"></p>
<h3 id="多线程之间通信方式">多线程之间通信方式</h3><ol>
<li>“共享变量”：实现Runnable接口实现线程的共享变量或者内部类共享外围类的变量</li>
<li><p>“管道流”：</p>
<pre><code><span class="comment">/* 管道输出流和生产者线程绑定, 管道输入流和消费者线程绑定,输入输出流绑定，启动两个线程互相之间通过write和read函数就行通信 */</span>
<span class="type">PipedOutputStream</span> pos = <span class="keyword">new</span> <span class="type">PipedOutputStream</span>();
<span class="type">Producer</span> p = <span class="keyword">new</span> <span class="type">Producer</span>(pos);
<span class="type">PipedInputStream</span> pis = <span class="keyword">new</span> <span class="type">PipedInputStream</span>();
<span class="type">Consumer</span> c = <span class="keyword">new</span> <span class="type">Consumer</span>(pis);
pos.connect(pis);
p.start();
c.start();

<span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Thread</span> {</span>
    <span class="keyword">private</span> <span class="type">PipedOutputStream</span> pos;
    public <span class="type">Producer</span>(<span class="type">PipedOutputStream</span> pos) {
        <span class="keyword">this</span>.pos = pos;
    }
    public void run() {
        int i = <span class="number">8</span>;
        <span class="keyword">try</span> {
            pos.write(i);
            <span class="comment">// pis.read()</span>
        } <span class="keyword">catch</span> (<span class="type">IOException</span> e) {
            e.printStackTrace();
        }
    }
}
</code></pre></li>
</ol>
<h3 id="线程的四种创建方式">线程的四种创建方式</h3><ol>
<li>定义<strong>Thread类</strong>的子类，并重写该类的run()方法；创建Thread子类的实例，即创建了线程对象，调用线程对象的start()方法来启动该线程</li>
<li>定义<strong>Runnable接口</strong>的实现类，并重写该接口的run()方法，创建Runnable实现类的实例，并以此实例作为Thread的参数来创建Thread对象，该Thread对象才是真正的线程对象；然后调用线程对象的start()方法来启动线程</li>
<li><p>创建<strong>Callable接口</strong>的实现类，并实现call()方法，该call()方法有返回值；创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值，使用FutureTask对象作为Thread对象的target创建并启动新线程，调用FutureTask对象的get()方法来获得子线程执行结束后的返回值</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> MyCallableTest <span class="keyword">implements</span> Callable&lt;Integer&gt;{
    <span class="comment">// 实现call方法，作为线程执行体</span>
    <span class="keyword">public</span> Integer <span class="keyword">call</span>(){
        <span class="keyword">int</span> i = <span class="number">0</span>;
        <span class="keyword">for</span> ( ; i &lt; <span class="number">100</span> ; i++ ){
            System.out.<span class="keyword">println</span>(Thread.currentThread().getName()+ <span class="string">"\t"</span> + i);
        }
        <span class="comment">// call()方法可以有返回值，而且可以抛出异常</span>
        <span class="keyword">return</span> i;
    }
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) {
        <span class="comment">// 创建Callable对象</span>
        MyCallableTest myCallableTest = <span class="keyword">new</span> MyCallableTest();
        <span class="comment">// 使用FutureTask来包装Callable对象</span>
        FutureTask&lt;Integer&gt; <span class="keyword">task</span> = <span class="keyword">new</span> FutureTask&lt;Integer&gt;(myCallableTest);
        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">100</span> ; i++){
            System.out.<span class="keyword">println</span>(Thread.currentThread().getName()+ <span class="string">" \t"</span> + i);
            <span class="keyword">if</span> (i == <span class="number">20</span>){
                <span class="comment">// 实质还是以Callable对象来创建、并启动线程</span>
                <span class="keyword">new</span> Thread(<span class="keyword">task</span> , <span class="string">"callable"</span>).start();
                <span class="comment">// 线程池执行FutureTask</span>
                Executor executor = Executors.newSingleThreadExecutor();
                executor.execute(<span class="keyword">task</span>);
            }
        }
        <span class="keyword">try</span>{
            <span class="comment">// 获取线程返回值</span>
            System.out.<span class="keyword">println</span>(<span class="string">"callable返回值："</span> + <span class="keyword">task</span>.get());
        }
        <span class="keyword">catch</span> (Exception ex){
            ex.printStackTrace();
        }
    }
}
</code></pre></li>
<li><p><strong>线程池</strong>: </p>
<ul>
<li>线程池的<strong>好处1</strong>在于可以更好地控制并发线程数目，提高资源利用率并防止阻塞</li>
<li><strong>好处2</strong>可以更好地重用线程, 减少线程创建和销毁带来的系统开销,可以设置线程定时定期执行</li>
<li><strong>核心构造函数ThreadPoolExecutor</strong>,可以在参数中设置核心池大小，最大线程数等</li>
<li><strong>ExecutorService接口用于实现和管理线程池,其生命周期包括三种状态：运行、关闭、终止</strong>。</li>
<li><strong>线程池四个基本组成部分</strong>：<ol>
<li><strong>线程池管理器（ThreadPool）</strong>：用于创建并管理线程池，包括 创建线程池，销毁线程池，添加新任务；</li>
<li><strong>工作线程（PoolWorker）</strong>：线程池中线程，在没有任务时处于等待状态，可以循环的执行任务；</li>
<li><strong>任务接口（Task）</strong>：每个任务必须实现的接口，以供工作线程调度任务的执行，它主要规定了任务的入口，任务执行完后的收尾工作，任务的执行状态等；</li>
<li><strong>任务队列（taskQueue）</strong>：用于存放没有处理的任务, 提供一种缓冲机制。</li>
</ol>
</li>
<li><p>四种Executors接口提供的通过ThreadFactory新建的线程池</p>
<ol>
<li><p>newFixedThreadPool(): 固定数目线程池，任意时间点最多只能有固定数目的活动线程存在；有新任务到达时创建线程，只能放在另外的队列中等待，直到达到线程池最大大小为止，有异常则补充    </p>
<pre><code>ExecutorService threadPool = Executor.newFixedThreadPool(<span class="number">3</span>);
Runnable r = <span class="keyword">new</span> Runnable() {
    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{

    }
};
<span class="comment">// 参数可以是Thread以及Runnable对象</span>
threadPool.execute(r);
</code></pre></li>
<li><p>newCachedThreadPool：缓存型线程池，新任务到达则新建线程，当线程数目大于处理需要时，则回收空闲的线程，无大小限制</p>
</li>
<li>newSingleThreadExecutor: 单线程池，只创建唯一的工作线程来执行任务，保证任务被顺序执行</li>
<li>newScheduledThreadPool: 调度型线程池，固定线程数目，而且提供任务被定时和周期性执行的功能</li>
</ol>
</li>
<li><p><strong>自定义线程池</strong></p>
<pre><code> ThreadPoolExecutor(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span> keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler)

<span class="comment">/*
corePoolSize - 核心池中所保存的线程数，包括空闲线程；也就是正在运行的线程数目。
maximumPoolSize-线程池中允许的最大线程数
keepAliveTime - 当线程池的工作线程空闲后，保持存活的时间
unit - keepAliveTime 参数的时间单位
workQueue - 执行前用于保持任务的队列。此队列仅保持由 execute方法提交的 Runnable任务
threadFactory - 执行程序创建新线程时使用的工厂
handler - 由于超出线程范围和队列容量而使新到达的任务被阻塞时采取的处理策略，
默认为AbortPolicy，表示无法处理新任务时抛出异常；DiscardPolicy：不能执行的任务将被删除
ThreadPoolExecutor是Executors类的底层实现
*/</span>

 <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolTest</span></span>{   
    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>{   
        <span class="comment">//创建等待队列   </span>
        BlockingQueue&lt;Runnable&gt; bqueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="number">20</span>);   
        <span class="comment">//创建线程池，池中保存的线程数为3，允许的最大线程数为5  </span>
        ThreadPoolExecutor pool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">3</span>,<span class="number">5</span>,<span class="number">50</span>,TimeUnit.MILLISECONDS,bqueue);   
        <span class="comment">//创建七个任务   </span>
        Runnable t1 = <span class="keyword">new</span> MyThread();   
        Runnable t2 = <span class="keyword">new</span> MyThread();   
        Runnable t3 = <span class="keyword">new</span> MyThread();   
        Runnable t4 = <span class="keyword">new</span> MyThread();   
        Runnable t5 = <span class="keyword">new</span> MyThread();   
        Runnable t6 = <span class="keyword">new</span> MyThread();   
        Runnable t7 = <span class="keyword">new</span> MyThread();   
        <span class="comment">//每个任务会在一个线程上执行  </span>
        pool.execute(t1);   
        pool.execute(t2);   
        pool.execute(t3);   
        pool.execute(t4);   
        pool.execute(t5);   
        pool.execute(t6);   
        pool.execute(t7);   
        <span class="comment">//关闭线程池   </span>
        pool.shutdown();   
    }   
}   

<span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>{   
    <span class="annotation">@Override</span>   
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>{   
        System.out.println(Thread.currentThread().getName() + <span class="string">"正在执行。。。"</span>);   
        <span class="keyword">try</span>{   
            Thread.sleep(<span class="number">100</span>);   
        }<span class="keyword">catch</span>(InterruptedException e){   
            e.printStackTrace();   
        }   
    }   
}  
</code></pre></li>
<li><strong>线程池工作流程</strong><br>   <img src="https://raw.githubusercontent.com/Charles-Xiao/Charles-Xiao.github.io/master/images/threadpool-procedure.jpg" class="full-image">    </li>
<li><p><strong>线程池的排队策略</strong>    </p>
<ol>
<li><strong>默认选项是SynchronousQueue</strong>，它将任务直接提交给线程而不保持它们，一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态</li>
<li><strong>无界队列</strong>。使用无界队列（例如，不具有预定义容量的 LinkedBlockingQueue）将导致在所有 corePoolSize 线程都忙时新任务在队列中等待。这样，创建的线程就不会超过corePoolSize。（因此，maximumPoolSize的值也就无效了。）当每个任务完全独立于其他任务，即任务执行互不影响时，适合于使用无界队列；例如，在 Web页服务器中。这种排队可用于处理瞬态突发请求，当命令以超过队列所能处理的平均数连续到达时，此策略允许无界线程具有增长的可能性。</li>
<li><strong>有界队列</strong>。当使用有限的 maximumPoolSizes时，有界队列（如 ArrayBlockingQueue）有助于防止资源耗尽，但是可能较难调整和控制。队列大小和最大池大小可能需要相互折衷：使用大型队列和小型池可以最大限度地降低 CPU 使用率、操作系统资源和上下文切换开销，但是可能导致人工降低吞吐量。如果任务频繁阻塞（例如，如果它们是 I/O边界），则系统可能为超过您许可的更多线程安排时间。使用小型队列通常要求较大的池大小，CPU使用率较高，但是可能遇到不可接受的调度开销，这样也会降低吞吐量。 </li>
<li><strong>PriorityBlockingQueue</strong>: 一个具有优先级的无限阻塞队列</li>
</ol>
</li>
<li><p><strong>线程池的风险</strong></p>
<ol>
<li>死锁: 死锁的产生是因为一组线程或者进程互相等待资源的释放而永远互相等待;线程池中容易产生一种新的死锁: 当核心池中所有线程都在等待阻塞队列中的某个线程的执行结果，但是该线程却因为池中没有空闲线程而没有办法执行，这样就导致互相等待的死锁.</li>
<li>并发错误: 线程池和其它排队机制依靠使用 wait() 和 notify() 方法,易出现问题 </li>
</ol>
</li>
<li><p><strong>线程池的执行</strong>: execute和submit两个方法都可以向线程池提交任务， <strong>execute()方法</strong>的返回类型是void，它定义在Executor接口中；<strong>submit()方法</strong>可以返回持有计算结果的Future对象，它定义在ExecutorService接口中，它扩展了Executor接口，便于捕获异常，利用FutureTask.get()函数</p>
</li>
<li><p><strong>线程池的关闭</strong></p>
<ol>
<li>通过调用线程池的shutdown或shutdownNow方法来关闭线程池，它们的原理是遍历线程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程，所以无法响应中断的任务可能永远无法终止。但是它们存在一定的区别，shutdownNow首先将线程池的状态设置成STOP，然后尝试停止所有的正在执行或暂停任务的线程，并返回等待执行任务的列表，而shutdown只是将线程池的状态设置成SHUTDOWN状态，然后中断所有没有正在执行任务的线程。</li>
</ol>
</li>
</ul>
<ol>
<li>只要调用了这两个关闭方法的其中一个，isShutdown方法就会返回true。当所有的任务都已关闭后,才表示线程池关闭成功，这时调用isTerminaed方法会返回true。至于我们应该调用哪一种方法来关闭线程池，应该由提交到线程池的任务特性决定，通常调用shutdown来关闭线程池，如果任务不一定要执行完，则可以调用shutdownNow。 </li>
</ol>
<ul>
<li><strong>合理配置线程池</strong>       <ol>
<li>任务的性质：CPU密集型任务，IO密集型任务和混合型任务；CPU密集型任务配置尽可能小的线程，如配置Ncpu+1个线程的线程池。IO密集型任务则由于线程并不是一直在执行任务，则配置尽可能多的线程，如2*Ncpu</li>
<li>任务的优先级：高，中和低；PriorityBlockingQueue会导致优先级低的线程永远不被执行</li>
<li>任务的执行时间：长，中和短；</li>
<li>任务的依赖性：是否依赖其他系统资源，如数据库连接：依赖数据库连接池的任务，因为线程提交SQL后需要等待数据库返回结果，如果等待的时间越长CPU空闲时间就越长，那么线程数应该设置越大，这样才能更好的利用CPU。    </li>
</ol>
</li>
</ul>
</li>
</ol>
<h3 id="线程的状态变化">线程的状态变化</h3><p><img src="https://raw.githubusercontent.com/Charles-Xiao/Charles-Xiao.github.io/master/images/multiThread.png" class="full-image"></p>
<h3 id="死锁及其解决办法">死锁及其解决办法</h3><pre><code><span class="comment">/**
 * 一个简单的死锁类 当DeadLock类的对象flag==1时（td1），先锁定o1,睡眠500毫秒
 * 而td1在睡眠的时候另一个flag==0的对象（td2）线程启动，先锁定o2,睡眠500毫秒
 * td1睡眠结束后需要锁定o2才能继续执行，而此时o2已被td2锁定； td2睡眠结束后需要锁定o1才能继续执行，而此时o1已被td1锁定；
 * td1、td2相互等待，都需要得到对方锁定的资源才能继续执行，从而死锁
 */</span>
<span class="keyword">public</span> class DeadLock implements Runnable {
    <span class="keyword">public</span> <span class="built_in">int</span> flag = <span class="number">1</span>;
    <span class="comment">// 静态对象是类的所有对象共享的</span>
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">Object</span> o1 = <span class="keyword">new</span> <span class="keyword">Object</span>(), o2 = <span class="keyword">new</span> <span class="keyword">Object</span>();

    <span class="keyword">public</span> <span class="keyword">void</span> run() {
        System.out.<span class="built_in">println</span>(<span class="string">"flag="</span> + flag);
        <span class="keyword">if</span> (flag == <span class="number">1</span>) {
            <span class="keyword">synchronized</span> (o1) {
                System.out.<span class="built_in">println</span>(<span class="string">"thread1锁定 o1"</span>);
                <span class="keyword">try</span> {
                    Thread.sleep(<span class="number">500</span>);
                } <span class="keyword">catch</span> (Exception e) {
                    e.printStackTrace();
                }
                <span class="comment">// thread1等待资源o2释放</span>
                <span class="keyword">synchronized</span> (o2) {
                    System.out.<span class="built_in">println</span>(<span class="string">"1"</span>);
                }
            }
        }
        <span class="keyword">if</span> (flag == <span class="number">2</span>) {
            <span class="keyword">synchronized</span> (o2) {
                System.out.<span class="built_in">println</span>(<span class="string">"thread2锁定 o2"</span>);
                <span class="keyword">try</span> {
                    Thread.sleep(<span class="number">500</span>);
                } <span class="keyword">catch</span> (Exception e) {
                    e.printStackTrace();
                }
                <span class="comment">// thread2等待资源o1释放</span>
                <span class="keyword">synchronized</span> (o1) {
                    System.out.<span class="built_in">println</span>(<span class="string">"2"</span>);
                }
            }
        }
    }

    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) {

        DeadLock td1 = <span class="keyword">new</span> DeadLock();
        DeadLock td2 = <span class="keyword">new</span> DeadLock();
        td1.flag = <span class="number">1</span>;
        td2.flag = <span class="number">2</span>;
        <span class="comment">// td1,td2都处于可执行状态，但JVM线程调度先执行哪个线程是不确定的。</span>
        <span class="comment">// td2的run()可能在td1的run()之前运行</span>
        <span class="keyword">new</span> Thread(td1).start();
        <span class="keyword">new</span> Thread(td2).start();

    }
}
</code></pre><ol>
<li><strong>死锁的必要条件</strong>死锁是指是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待对方占有的资源的现象，若无外力作用，它们都将无法推进下去。<ul>
<li><strong>互斥条件</strong>：指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。</li>
<li><strong>请求和保持条件</strong>：指进程请求新资源发生阻塞时对自己已经获得的其它资源保持不放。</li>
<li><strong>不剥夺条件</strong>：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。</li>
<li><strong>环路等待条件</strong>：指在发生死锁时，进程之间会形成一种头尾相接的循环等待资源关系，即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。</li>
</ul>
</li>
<li><strong>死锁的避免、预防和解决方法</strong><ul>
<li>采用资源有序分配法，破坏环路等待形成</li>
<li>允许进程剥夺其他进程占有的资源</li>
<li>银行家算法:把操作系统看作是银行家，操作系统管理的资源相当于银行家管理的资金，进程向操作系统请求分配资源相当于用户向银行家贷款。操作系统按照银行家制定的规则为进程分配资源，当进程首次申请资源时，要测试该进程对资源的最大需求量，如果系统现存的资源可以满足它的最大需求量则按当前的申请量分配资源，否则就推迟分配。当进程在执行中继续申请资源时，先测试该进程已占用的资源数与本次申请的资源数之和是否超过了该进程对资源的最大需求量。若超过则拒绝分配资源，若没有超过则再测试系统现存的资源能否满足该进程尚需的最大资源量，若能满足则按当前的申请量分配资源，否则也要推迟分配。</li>
<li>互斥条件无法被破坏</li>
</ul>
</li>
</ol>
<h3 id="多线程相关问题">多线程相关问题</h3><ol>
<li><strong>yield</strong>表示暂停当前线程，执行其他线程(包括自身线程)由cpu决定</li>
<li><strong>join</strong>：阻塞所在线程，等调用它的线程执行完毕，再向下执行</li>
<li><strong>sleep()方法</strong>属于Thread类中的，而<strong>wait()方法</strong>则是属于Object类；sleep()方法导致了程序暂停执行指定的时间，让出cpu给其他线程，但是他的监控状态依然保持，当指定的时间到了又会自动恢复运行状态，线程不会释放对象锁；而当调用wait()方法的时候，线程会放弃对象锁，只有针对此对象调用notify()方法后本线程才进入对象锁定池准备就绪</li>
</ol>
<h3 id="多线程同步的方法">多线程同步的方法</h3><ol>
<li>Synchronized代码块</li>
<li>Synchronized方法</li>
<li>RetrantLock可重入锁</li>
<li>ThreadLocal线程局部变量</li>
<li>Volatile可见变量</li>
</ol>

        
      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="../../tags/java/"> #java </a>
          
            <a href="../../tags/多线程/"> #多线程 </a>
          
        </div>
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
  </div>

  
  <div class="pagination">
    <a class="extend prev" rel="prev" href="../8/">&laquo;</a><a class="page-number" href="../..//">1</a><span class="space">&hellip;</span><a class="page-number" href="../8/">8</a><span class="page-number current">9</span>
  </div>


        </div>

        
      </div>


      
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <div id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      <div class="site-overview">
        <div class="site-author motion-element">
          <img class="site-author-image" src="/images/avatar.jpg" alt="CharlesXiao" />
          <p class="site-author-name">CharlesXiao</p>
        </div>
        <p class="site-description motion-element">在码农炼成之路不断挣扎……stay hungry……keep learning……</p>
        <div class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="../..//archives">
              <span class="site-state-item-count">67</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            <a href="../..//categories">
              <span class="site-state-item-count">17</span>
              <span class="site-state-item-name">分类</span>
              </a>
          </div>

          <div class="site-state-item site-state-tags">
            <a href="../..//tags">
              <span class="site-state-item-count">69</span>
              <span class="site-state-item-name">标签</span>
              </a>
          </div>

        </div>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
              <a href="https://github.com/Charles-Xiao" target="_blank">github</a>
            </span>
            
              <span class="links-of-author-item">
              <a href="http://weibo.com/2262300105/profile?topnav=1&wvr=6" target="_blank">weibo</a>
            </span>
            
              <span class="links-of-author-item">
              <a href="http://daijiale.github.io/" target="_blank">Daijiale的个人站点</a>
            </span>
            
          
        </div>

        
        

      </div>

      

    </div>
  </div>


    </div>

    <div id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; &nbsp;  2015.05.16 - 
  2018
  <span class="with-love">
    <i class="icon-heart"></i>
  </span>
  <span class="author">CharlesXiao</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>



      </div>
    </div>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="../../vendors/jquery/index.js?v=2.1.3"></script>

  
  

  
  <script type="text/javascript" src="../../vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript">
    $(document).ready(function() {
      $('.content img').each(function () {
        var $image = $(this);
        var $imageWrapLink = $image.parent('a');

        if ($imageWrapLink.size() < 1) {
          $imageWrapLink = $image.wrap('<a href="' + this.getAttribute('src') + '"></a>').parent('a');
        }
        $imageWrapLink.addClass('fancybox');
      });
    });
    $('.fancybox').fancybox({
      helpers: {
        overlay: {
          locked: false
        }
      }
    });
  </script>


  <script type="text/javascript">
  function hasMobileUA () {
    var nav = window.navigator;
    var ua = nav.userAgent;
    var pa = /iPad|iPhone|Android|Opera Mini|BlackBerry|webOS|UCWEB|Blazer|PSP|IEMobile|Symbian/g;

    return pa.test(ua);
  }

  function isDesktop () {
    return screen.width > 991 && !hasMobileUA();
  }

  function isTablet () {
    return screen.width < 992 && screen.width > 767 && hasMobileUA();
  }

  function isMobile () {
    return screen.width < 767 && hasMobileUA();
  }

  function escapeSelector (selector) {
    return selector.replace(/[!"$%&'()*+,.\/:;<=>?@[\\\]^`{|}~]/g, "\\$&")
  }
</script>

  

  <script type="text/javascript" src="../../vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="../../vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" id="motion.global">
  $(document).ready(function () {
    var body = $('body');
    var isSidebarVisible = false;
    var sidebarToggle = $('.sidebar-toggle');
    var sidebarToggleLine1st = $('.sidebar-toggle-line-first')
    var sidebarToggleLine2nd = $('.sidebar-toggle-line-middle');
    var sidebarToggleLine3rd = $('.sidebar-toggle-line-last');
    var sidebar = $('.sidebar');

    var SIDEBAR_WIDTH = '320px';
    var SIDEBAR_DISPLAY_DURATION = 300;

    var sidebarToogleLineStatusInit = {width: '100%', opacity: 1, left: 0, rotateZ: 0, top: 0};

    var sidebarToggleLine1stStatusInit = sidebarToogleLineStatusInit;
    var sidebarToggleLine1stStatusArrow = {width: '50%', rotateZ: '-45deg', top: '2px'};
    var sidebarToogleLine1stStatusClose = {width: '100%', rotateZ: '-45deg', top: '5px'};

    var sidebarToggleLine2ndStatusInit = sidebarToogleLineStatusInit;
    var sidebarToggleLine2ndStatusArrow = {width: '90%'};
    var sidebarToogleLine2ndStatusClose = {opacity: 0};

    var sidebarToggleLine3rdStatusInit = sidebarToogleLineStatusInit;
    var sidebarToggleLine3rdStatusArrow = {width: '50%', rotateZ: '45deg', top: '-2px'};
    var sidebarToogleLine3rdStatusClose = {width: '100%', rotateZ: '45deg', top: '-5px'};

    LogoAndMenuMotion();
    sidebatToggleMotion();
    postsListMotion();
    backToTopMotion();


    $(document)
      .on('sidebar.isShowing', function () {
        isDesktop() && body.velocity(
          {paddingRight: SIDEBAR_WIDTH},
          SIDEBAR_DISPLAY_DURATION
        );
        sidebarContentMotion();
      })
      .on('sidebar.isHiding', function () {});

    function LogoAndMenuMotion() {
      $.Velocity.RunSequence([
        { e: $('.brand'), p: { opacity: 1 }, o: { duration: 100 } },
        { e: $('.logo'), p: { opacity: 1, top: 0 }, o: { duration: 50} },
        
        { e: $('.logo-line-before i'), p: { translateX: "100%" }, o: { duration: 500, sequenceQueue: false } },
        { e: $('.logo-line-after i'), p: { translateX: "-100%" }, o: { duration: 500, sequenceQueue: false } },
        
        { e: $('.site-title'), p: { opacity: 1, top: 0 }, o: { duration: 200 } }
      ]);
      $('.menu-item').velocity('transition.slideDownIn', {display: null});
    }


    function backToTopMotion () {
      var b2top = $('.back-to-top');
      b2top.on('click', function () {
        body.velocity('scroll');
      });
    }

    function sidebarShowMotion () {

      sidebarToggleLine1st.velocity(sidebarToogleLine1stStatusClose);
      sidebarToggleLine2nd.velocity(sidebarToogleLine2ndStatusClose);
      sidebarToggleLine3rd.velocity(sidebarToogleLine3rdStatusClose);

      sidebar.velocity({width: SIDEBAR_WIDTH}, {
        display: 'block',
        duration: SIDEBAR_DISPLAY_DURATION,
        complete: function () {
          sidebar.addClass('sidebar-active');
          sidebar.trigger('sidebar.didShow');
        }
      });
      sidebar.trigger('sidebar.isShowing');
    }

    function sidebarHideMotion () {
      isDesktop() && body.velocity({paddingRight: 0});
      sidebar.velocity('reverse');

      sidebarToggleLine1st.velocity(sidebarToggleLine1stStatusInit);
      sidebarToggleLine2nd.velocity(sidebarToggleLine2ndStatusInit);
      sidebarToggleLine3rd.velocity(sidebarToggleLine3rdStatusInit);

      sidebar.removeClass('sidebar-active');
      sidebar.trigger('sidebar.isHiding');
    };

    function sidebarContentMotion () {
      $('.sidebar .motion-element').velocity(
        'transition.slideRightIn',
        {stagger: 50, drag: true}
      );
    }

    function postsListMotion () {
      var postMotionOptions = window.postMotionOptions || {stagger: 300, drag: true};
      $('.post').velocity('transition.slideDownIn', postMotionOptions);
    }

    function sidebatToggleMotion () {
      sidebarToggle.on('click', function () {
        isSidebarVisible ? sidebarHideMotion() : sidebarShowMotion();
        isSidebarVisible = !isSidebarVisible;
      });

      sidebarToggle.hover(function () {
        if (isSidebarVisible) {return}
        sidebarToggleLine1st.velocity('stop').velocity(sidebarToggleLine1stStatusArrow);
        sidebarToggleLine2nd.velocity('stop').velocity(sidebarToggleLine2ndStatusArrow);
        sidebarToggleLine3rd.velocity('stop').velocity(sidebarToggleLine3rdStatusArrow);
      }, function () {
        if (isSidebarVisible) {return}
        sidebarToggleLine1st.velocity('stop').velocity(sidebarToggleLine1stStatusInit);
        sidebarToggleLine2nd.velocity('stop').velocity(sidebarToggleLine2ndStatusInit);
        sidebarToggleLine3rd.velocity('stop').velocity(sidebarToggleLine3rdStatusInit);
      });
    }
  });

</script>





  

  
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
  });
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for (i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>


  
  
  


  

  
</body>
</html>
