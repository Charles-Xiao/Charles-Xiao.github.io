<!doctype html>
<html class="theme-next use-motion theme-next-mist">
<head><meta name="generator" content="Hexo 3.8.0">
  

<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">






  <link rel="stylesheet" type="text/css" href="vendors/fancybox/source/jquery.fancybox.css?v=2.1.5">


<link rel="stylesheet" type="text/css" href="css/main.css?v=0.4.2">


    <meta name="description" content="在码农炼成之路不断挣扎……stay hungry……keep learning……">



  <meta name="keywords" content="java,android,life,CharlesXiao">





  <link rel="shorticon icon" type="image/x-icon" href="/favicon.ico?v=0.4.2">



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?6749450";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>


  <title> CharlesXiao‘s Blog </title>
</head>

<body>
<!--[if lte IE 8]> <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'> <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode"><img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820" alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari." style='margin-left:auto;margin-right:auto;display: block;'/></a></div> <![endif]-->
  <div class="container one-column 
  
">
    <div class="headband"></div>
    <!-- fork me github icon  -->
    <a href="https://github.com/Charles-Xiao" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewbox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <div id="header" class="header">
      <div class="header-inner">
        <h1 class="site-meta">
  <span class="logo-line-before"><i></i></span>
  <a href="/" class="brand">
      <span class="logo">
        <i class="icon-logo"></i>
      </span>
      <span class="site-title">CharlesXiao‘s Blog</span>
  </a>
  <span class="logo-line-after"><i></i></span>
</h1>


  <ul id="menu" class="menu">
     
    <!--增加swiftype搜索功能-->
    <form class="menu-item menu-item-search">
      <input type="text" id="st-search-input" class="st-search-input st-default-search-input">
    </form>
    
    <script type="text/javascript">
      (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
      (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
      e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
      })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

      _st('install','yxUhPQ2aHyszT_1btxX9','2.0.0');
    </script>
    <!--增加swiftype搜索功能end-->
    
    
      
      <li class="menu-item menu-item-home">
        <a href="/">
          <i class="menu-item-icon icon-home"></i> <br>
          首页
        </a>
      </li>
    
      
      <li class="menu-item menu-item-categories">
        <a href="/categories">
          <i class="menu-item-icon icon-categories"></i> <br>
          分类
        </a>
      </li>
    
      
      <li class="menu-item menu-item-about">
        <a href="/about">
          <i class="menu-item-icon icon-about"></i> <br>
          关于
        </a>
      </li>
    
      
      <li class="menu-item menu-item-archives">
        <a href="/archives">
          <i class="menu-item-icon icon-archives"></i> <br>
          归档
        </a>
      </li>
    
      
      <li class="menu-item menu-item-tags">
        <a href="/tags">
          <i class="menu-item-icon icon-tags"></i> <br>
          标签
        </a>
      </li>
    
  </ul>


      </div>
    </div>

    <div id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content">
          
  <div id="posts" class="posts-expand">
    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              NewSQL数据库探秘
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2018-11-11
        </span>

        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="2018/11/11/NewSQL数据库探秘/#comments">
              <span class="post-comments-count ds-thread-count" data-thread-key="2018/11/11/NewSQL数据库探秘/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        <h2 id="SQL关系型数据库">SQL关系型数据库</h2><p><a href="https://charles-xiao.github.io/2015/05/19/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%87%8D%E9%9A%BE%E7%82%B9%E9%9B%86%E9%94%A6/">数据库重难点集锦</a></p>
<h2 id="NoSQL">NoSQL</h2><h3 id="键值型">键值型</h3><p>键值数据库的代表是Redis，面对通过主键查询的场景，Redis的效率非常高，但对于内容的查询，则无能为力。分布式只能靠根据主键进行分片，不支持ACID事务。</p>
<h3 id="文档型">文档型</h3><p>文档数据库的代表是MongoDB，查询灵活，拥有自由度极高的Schema模型，可以方便的与JSON数据映射，不支持ACID事务。</p>
<h3 id="列式存储型">列式存储型</h3><p>HBase用于处理海量数据，不支持ACID事务，并且只能通过行键来查询数据。</p>
<h2 id="NewSQL">NewSQL</h2><p>NewSQL is a class of modern relational database management systems that seek to provide the same scalable performance of NoSQL systems for online transaction processing (OLTP) read-write workloads while still maintaining the ACID guarantees of a traditional database system.</p>
<p>一种新式的关系型数据库管理系统，具有以下特性：</p>
<ol>
<li>针对OLTP（读-写）工作负载，追求提供和NoSQL系统相同的扩展性能</li>
<li>保持ACID和SQL查询等关系数据库特性</li>
</ol>
<p>目前业界最流行的分布式数据库有三类：新架构（New Architecture）、透明化分片中间件（Transparent Sharding Middleware）和云数据库（Database-as-a-Service）, 2016年Andrew Pavlo与Matthew Aslett发布了一篇论文专门讲述NewSQL，<a href="https://db.cs.cmu.edu/papers/2016/pavlo-newsql-sigmodrec2016.pdf" target="_blank" rel="noopener">What’s Really New with NewSQL?</a>；<strong>新架构</strong>以Google Spanner为代表(Share-Nothing)，<strong>云数据库</strong>以AWS Auraro为代表(Shard-Disk)，<strong>透明化中间件</strong>以Sharding-Proxy为代表，下文我们一一阐述。</p>
<h3 id="新架构">新架构</h3><ol>
<li>主要产品代表为Spanner、TiDB、CockroachDB、OceanBase、TafDB。</li>
<li>主要特点包括弹性扩展、分布式事务、基于Raft/Paxos的多副本复制技术保证一致性、故障容灾高可用；一般会包括master主备节点管理集群元信息、调度数据、负载均衡、分配全局事务ID，SQL节点负责接受用户的SQL并解析以及其它计算工作、访问master元信息去找到存储数据的节点，KV节点负责存储一致性多副本数据(像OB还会把存储节点分为基准数据节点和增量数据节点, 增量数据节点和master共用)。</li>
</ol>
<h3 id="透明化分片中间件">透明化分片中间件</h3><p>增加一层proxy，隐藏分库分表的细节，包括MyCat等中间件系统。其实后端还是单机节点中一个MySQL实例内核同时负责存储和计算。</p>
<h3 id="云数据库">云数据库</h3><ol>
<li>主要产品代表为Auraro、PolarDB、X-DB</li>
<li>主要特点为计算和存储分离：计算节点基于MySQL内核，并提供主计算节点和多个只读节点来进行容错，计算节点通过RDMA与存储节点连通解决IO性能问题，存储节点基于Raft或者Quorum来做多副本存储，存储其实是共享的(多个数据库实例共享一个分布式存储层)。</li>
</ol>

      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="tags/分布式系统/"> #分布式系统 </a>
          
            <a href="tags/NewSQL/"> #NewSQL </a>
          
            <a href="tags/数据库/"> #数据库 </a>
          
            <a href="tags/MySQL/"> #MySQL </a>
          
        </div>
      

      

      
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              Golang实现读写缓冲池
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2018-10-29
        </span>

        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="2018/10/29/Golang实现读写缓冲池/#comments">
              <span class="post-comments-count ds-thread-count" data-thread-key="2018/10/29/Golang实现读写缓冲池/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        <p>所谓读写缓冲池的本质是生产者消费者模型的实际应用。目的是为了避免频繁分配和释放内存，复用最初new出来的固定数目缓冲slice，减少GC压力。</p>
<h3 id="Channel+WaitGroup">Channel+WaitGroup</h3><p>Golang并发基本都是这两者搭配使用，通过for+select循环监听发布事件、订阅事件、取消事件。</p>
<h3 id="AsyncReader">AsyncReader</h3><h4 id="数据结构">数据结构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">// 接口核心方法Begin和Next, Begin用于写数据到blockBuf，Next从blockBuf读取出来数据</span><br><span class="line">type AsyncReader interface &#123;</span><br><span class="line">	Begin() error</span><br><span class="line">	Stop()</span><br><span class="line">	Next() ([]byte, error)</span><br><span class="line">	SetTimeoutMs(t uint32)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type asyncReader struct &#123;</span><br><span class="line">	// 数据来源</span><br><span class="line">	reader io.Reader</span><br><span class="line"></span><br><span class="line">	// buffer配置信息</span><br><span class="line">	blockNum       uint32</span><br><span class="line">	bufferBlockNum uint32 /* blockNum-1 */</span><br><span class="line">	blockSize      uint32</span><br><span class="line">	firstBlockSize uint32</span><br><span class="line">	clientTimeout  time.Duration</span><br><span class="line">	innerTimeout   time.Duration</span><br><span class="line"></span><br><span class="line">	// buffer</span><br><span class="line">	blocks []blockBuf</span><br><span class="line"></span><br><span class="line">	// channal and event</span><br><span class="line">    // struct&#123;&#125;不消耗内存空间，一般用来做信号</span><br><span class="line">	chRecieve   chan struct&#123;&#125; // 读reader数据写到buffer</span><br><span class="line">	chStop      chan struct&#123;&#125;</span><br><span class="line">	chReadEvent chan event // 从buffer读数据</span><br><span class="line">	isEof       bool</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 缓存block</span><br><span class="line">type blockBuf struct &#123;</span><br><span class="line">	data []byte</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type event struct &#123;</span><br><span class="line">	/* 在err != nil的时候，readBlockIdx,readLen,isEof的值都是undefined */</span><br><span class="line">	readBlockIdx uint32</span><br><span class="line">	readLen      uint32</span><br><span class="line">	isEof        bool</span><br><span class="line">	err          error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="核心函数">核心函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line">func NewAsyncReader(reader io.Reader, blockSize uint32, blockNum uint32, logId uint32) *asyncReader &#123;</span><br><span class="line">	this := &amp;asyncReader&#123;&#125;</span><br><span class="line"></span><br><span class="line">	/* asyncReader 有多个block作为异步读取数据的缓冲池,</span><br><span class="line">	 * 当用户调用next读取数据时，会把底层内存块以slice的方式交给调用方读取，</span><br><span class="line">	 * 所以需要多开辟1块block，避免正在缓冲的block同时被用户读取，产生竞态</span><br><span class="line">	 * this.blockNum 是asyncReader里实际开辟的block数</span><br><span class="line">	 * this.bufferBlockNum 是asyncReader 里用来异步缓冲的block数</span><br><span class="line">	 */</span><br><span class="line">	this.blockNum = blockNum + 1</span><br><span class="line">	this.bufferBlockNum = this.blockNum - 1</span><br><span class="line"></span><br><span class="line">    // 开辟缓存空间</span><br><span class="line">	this.blocks = make([]blockBuf, this.blockNum)</span><br><span class="line">	for i := uint32(0); i &lt; this.blockNum; i++ &#123;</span><br><span class="line">		this.blocks[i].data = nil</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	this.chRecieve = make(chan struct&#123;&#125;, this.bufferBlockNum)</span><br><span class="line">	this.chStop = make(chan struct&#123;&#125;, 1)</span><br><span class="line">	this.chReadEvent = make(chan event, this.blockNum)</span><br><span class="line"></span><br><span class="line">	// default:</span><br><span class="line">	this.firstBlockSize = this.blockSize</span><br><span class="line">	this.SetTimeoutMs(1000)</span><br><span class="line">	this.isEof = false</span><br><span class="line">	return this</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 异步读取数据 */</span><br><span class="line">func (this *asyncReader) Begin() error &#123;</span><br><span class="line"></span><br><span class="line">	for i := uint32(0); i &lt; this.bufferBlockNum; i++ &#123;</span><br><span class="line">		this.chRecieve &lt;- struct&#123;&#125;&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	go func() &#123;</span><br><span class="line">		isFirstBlock := true</span><br><span class="line">		blockIdx := uint32(0)</span><br><span class="line">		for &#123;</span><br><span class="line">			select &#123;</span><br><span class="line">			case &lt;-this.chStop: // 终止信号</span><br><span class="line">				return</span><br><span class="line">			case &lt;-time.After(this.innerTimeout):</span><br><span class="line">				// 默认协程异步读数据等待客户端读毕的超时时间，是客户端超时的2倍</span><br><span class="line">				this.chReadEvent &lt;- NewEvent(fmt.Errorf(&quot;asyncReader begin() timeout&quot;))</span><br><span class="line">				return</span><br><span class="line">			case &lt;-this.chRecieve: // 监听receive信号</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			toReadLen := this.blockSize</span><br><span class="line"></span><br><span class="line">			len, isEof, err := this.ReadOneBlock(blockIdx, toReadLen)</span><br><span class="line">			if err != nil &#123;</span><br><span class="line">				this.chReadEvent &lt;- NewEvent(err)</span><br><span class="line">				return</span><br><span class="line">			&#125;</span><br><span class="line">            // 读取成功一个block，就发送一个read event到通道，后续Next函数会主动获取</span><br><span class="line">			if len &gt; 0 &#123;</span><br><span class="line">				this.chReadEvent &lt;- event&#123;blockIdx, len, isEof, nil&#125;</span><br><span class="line">				blockIdx = (blockIdx + 1) % this.blockNum // 接着写下一个block</span><br><span class="line">			&#125;</span><br><span class="line">			if isEof &#123;</span><br><span class="line">				this.chReadEvent &lt;- event&#123;0, 0, true, nil&#125;</span><br><span class="line">				break</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	return nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 读取toReadLen长度的数据，直到满足长度或者EOF */</span><br><span class="line">/* 返回参数 readLen,isEof,error */</span><br><span class="line">func (this *asyncReader) ReadOneBlock(blockIdx uint32, toReadLen uint32) (uint32, bool, error) &#123;</span><br><span class="line">	var haveReadLen uint32</span><br><span class="line">	for haveReadLen = 0; haveReadLen &lt; toReadLen; &#123;</span><br><span class="line">		if this.blocks[blockIdx].data == nil &#123;</span><br><span class="line">			this.blocks[blockIdx].data = make([]byte, this.blockSize)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		readLen, err := this.reader.Read(this.blocks[blockIdx].data[haveReadLen:toReadLen])</span><br><span class="line">		if readLen &gt; 0 &#123;</span><br><span class="line">			haveReadLen += uint32(readLen)</span><br><span class="line">		&#125;</span><br><span class="line">		if err == io.EOF &#123;</span><br><span class="line">			return haveReadLen, true, nil</span><br><span class="line">		&#125; else if err != nil &#123;</span><br><span class="line">			log.Logger.Warn(&quot;[logid:%d] async reader readLen:%d, error:%s&quot;,</span><br><span class="line">				this.logId, haveReadLen, err)</span><br><span class="line">			return haveReadLen, true, err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return haveReadLen, false, nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*   1. asyncReader只支持一个协程读取数据</span><br><span class="line"> *   2. 返回的slice是asyncReader底层的buffer，数据有效期到下次调用next之前，</span><br><span class="line"> *      返回的slice不允许做写操作，如果有写需求，请copy</span><br><span class="line"> *   3. Next一般放在for循环中调用, 直到返回数据为nil</span><br><span class="line"> */</span><br><span class="line">func (this *asyncReader) Next() ([]byte, error) &#123;</span><br><span class="line">	if this.isEof &#123;</span><br><span class="line">		return nil, nil</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	select &#123;</span><br><span class="line">	case &lt;-time.After(this.clientTimeout):</span><br><span class="line">		return nil, TimeOutError</span><br><span class="line">	case event := &lt;-this.chReadEvent:</span><br><span class="line">		if event.err != nil &#123;</span><br><span class="line">			return nil, fmt.Errorf(&quot;asyncReaderAll.next error. %s&quot;, event.err)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if event.isEof &#123;</span><br><span class="line">			this.isEof = true</span><br><span class="line">			if event.readLen &gt; 0 &#123;</span><br><span class="line">				return this.blocks[event.readBlockIdx].data[0:event.readLen], nil</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				return nil, nil</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">            // 发送继续写buffer的信号，Begin函数里边的协程继续从reader读取下一个block写到缓存; 如果blockNum==bufferBlockNum，此处会出现竞态</span><br><span class="line">			this.chRecieve &lt;- struct&#123;&#125;&#123;&#125;</span><br><span class="line">			return this.blocks[event.readBlockIdx].data[0:event.readLen], nil</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="BufferPool">BufferPool</h3><p>读写缓冲池,Bodybufs是缓冲区，多个slice</p>
<h4 id="数据结构-1">数据结构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">type BufferPool interface &#123;</span><br><span class="line">	Write(start []byte, length int, err error) BosErrorCodeType</span><br><span class="line">	Read() ([]byte, int, error)</span><br><span class="line">	SendCanWriteSignal(signal int) BosErrorCodeType</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type BufferPoolImp struct &#123;</span><br><span class="line">	Bodybufs         []BodyBuf</span><br><span class="line">	bufWraps         chan BufWrap // 读写通道，buffer内容指针</span><br><span class="line">	writeSignals     chan int // 决定是否可写</span><br><span class="line">	currentIndex     int // 写入当前的Bodybufs[index]</span><br><span class="line">	maxBufferSize    int</span><br><span class="line">	timeout          int</span><br><span class="line">	needMallocMemory bool //pre malloc memory or not</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type BodyBuf struct &#123;</span><br><span class="line">	data []byte</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type BufWrap struct &#123;</span><br><span class="line">	index int //index of bodyBufs</span><br><span class="line">	n     int //size has read from r.Body</span><br><span class="line">	err   error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="核心函数-1">核心函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">func (bp *BufferPoolImp) Write(start []byte, length int, err error) BosErrorCodeType &#123;</span><br><span class="line">	select &#123;</span><br><span class="line">	case writeSignal := &lt;-bp.writeSignals:</span><br><span class="line">		log.Logger.Debug(&quot;[logid:%d] read can write signal ok: %d&quot;, bp.logId, writeSignal)</span><br><span class="line">		if writeSignal != 0 &#123;</span><br><span class="line">			return BosErrorCodeType(writeSignal)</span><br><span class="line">		&#125;</span><br><span class="line">	case &lt;-time.After(time.Duration(bp.timeout) * time.Second * 2):</span><br><span class="line">		log.Logger.Error(&quot;[logid:%d] wait writeSignal timeout&quot;, bp.logId)</span><br><span class="line">		return CODE_INTERNAL_ERROR</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    // start数据写入到BodyBufs, 并往bufWraps chan写内容指针，read函数会监听该通道</span><br><span class="line">	bp.Bodybufs[bp.currentIndex] = BodyBuf&#123;start&#125;</span><br><span class="line">	bufWrap := BufWrap&#123;bp.currentIndex, length, err&#125;</span><br><span class="line"></span><br><span class="line">	select &#123;</span><br><span class="line">	case bp.bufWraps &lt;- bufWrap:</span><br><span class="line">		log.Logger.Debug(&quot;[logid:%d] write buffers, index[%d]&quot;, bp.logId, bp.currentIndex)</span><br><span class="line">		bp.currentIndex = (bp.currentIndex + 1) % bp.maxBufferSize</span><br><span class="line">	case &lt;-time.After(time.Duration(bp.timeout) * time.Second):</span><br><span class="line">		log.Logger.Error(&quot;[logid:%d] write buffers timeout&quot;, bp.logId)</span><br><span class="line">		return CODE_INTERNAL_ERROR</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return CODE_OK</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// read一般放在for循环中调用, 直到返回数据为nil</span><br><span class="line">func (bp *BufferPoolImp) Read() ([]byte, int, error) &#123;</span><br><span class="line">	select &#123;</span><br><span class="line">	case bufWrap := &lt;-bp.bufWraps: // 获取写的内容</span><br><span class="line">		log.Logger.Debug(&quot;[logid:%d] read buffers, index[%d], len[%d]&quot;,</span><br><span class="line">			bp.logId, bufWrap.index, bufWrap.n)</span><br><span class="line">		if bufWrap.index &lt; 0 || bufWrap.index &gt; bp.maxBufferSize-1 &#123;</span><br><span class="line">			return nil, -1, bufWrap.err</span><br><span class="line">		&#125;</span><br><span class="line">		return bp.Bodybufs[bufWrap.index].data, bufWrap.n, bufWrap.err</span><br><span class="line">	case &lt;-time.After(time.Duration(bp.timeout) * time.Second):</span><br><span class="line">		log.Logger.Error(&quot;[logid:%d] read buffers timeout&quot;, bp.logId)</span><br><span class="line">		return nil, -1, ReadTimeOutError</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 调用read函数时需要同时调用这个函数，以确保write函数可以继续写buffer</span><br><span class="line">// read之后再调用该函数，所以不像async_reader可能出现竞争状态</span><br><span class="line">func (bp *BufferPoolImp) SendCanWriteSignal(signal int) BosErrorCodeType &#123;</span><br><span class="line">	select &#123;</span><br><span class="line">	case bp.writeSignals &lt;- signal:</span><br><span class="line">		log.Logger.Debug(&quot;[logid:%d] send can write signal ok&quot;, bp.logId)</span><br><span class="line">	case &lt;-time.After(time.Duration(bp.timeout) * time.Second * 2):</span><br><span class="line">		log.Logger.Error(&quot;[logid:%d] write writeSignal timeout&quot;, bp.logId)</span><br><span class="line">		return CODE_INTERNAL_ERROR</span><br><span class="line">	&#125;</span><br><span class="line">	return CODE_OK</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="tags/Golang/"> #Golang </a>
          
        </div>
      

      

      
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              C++并发编程揭秘
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2018-10-20
        </span>

        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="2018/10/20/C++并发编程揭秘/#comments">
              <span class="post-comments-count ds-thread-count" data-thread-key="2018/10/20/C++并发编程揭秘/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        <h3 id="并发级别">并发级别</h3><p>蓝色是阻塞的算法，绿色是非阻塞算法，金字塔越上方，并发级别越高，性能越好，右边的金字塔是实现工具（原子操作、锁、互斥体等）</p>
<p><img src="https://raw.githubusercontent.com/Charles-Xiao/Charles-Xiao.github.io/master/images/concurrency.png" class="full-image"></p>
<h4 id="Wait-freedom_无等待并发">Wait-freedom 无等待并发</h4><p>每一个线程都一直运行下去而无须等待外部条件，整个流程中任何操作都能在一个有限的步骤内完成，这是最高的并发级别，没有任何阻塞。可以简单认为能够直接调用一个原子操作实现的算法或程序就属于Wait-free，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 多个线程可以同时调用这个函数对同一个内存变量进行自增，而无须任何阻塞</span><br><span class="line">//（其实也是有阻塞的，是总线锁级别）</span><br><span class="line">void increment_reference_counter(rc_base* obj) &#123; </span><br><span class="line">atomic_increment(obj-&gt;rc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Lock-freedom_无锁并发">Lock-freedom 无锁并发</h4><p>整个系统作为一个整体一直运行下去，系统内部单个线程某段时间内可能会饥饿，这是比wait-freedom弱的并发级别，但系统整体上看依然是没有阻塞的。所有wait-free的算法显然都满足lock-free的要求。通常可以通过同步原语CAS实现, 例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">void stack_push(stack* s, node* n)</span><br><span class="line">&#123;</span><br><span class="line">    node* head;</span><br><span class="line">    do</span><br><span class="line">    &#123;</span><br><span class="line">        head = s-&gt;head;</span><br><span class="line">        n-&gt;next = head;</span><br><span class="line">    &#125;</span><br><span class="line">    while (!atomic_compare_exchange(s-&gt;head, head, n)); </span><br><span class="line">    // atomic_compare_exchange如果内存位置的s-&gt;head值和head相等则s-&gt;head的值设置成n</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// increment_reference_counter的lock-free实现，某些线程可能会因为CAS失败而回绕若干次循环</span><br><span class="line">void increment_reference_counter(rc_base* obj)</span><br><span class="line">&#123;</span><br><span class="line">       Int rc;</span><br><span class="line">       do &#123;</span><br><span class="line">       	rc = obj-&gt;rc;</span><br><span class="line">		&#125; while(!atomic_compare_exchange(obj-&gt;rc,rc,rc+1));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Obstruction-freedom_无阻塞并发">Obstruction-freedom 无阻塞并发</h4><p>指在任何时间点，一个孤立运行线程的每一个操作可以在有限步之内结束。只要没有竞争，线程就可以持续运行，一旦共享数据被修改，Obstruction-free 要求中止已经完成的部分操作，并进行回滚，obstruction-free 是并发级别更低的非阻塞并发，该算法在不出现冲突性操作的情况下提供单线程式的执行进度保证，所有 Lock-Free 的算法都是 Obstruction-free 的。</p>
<h4 id="Blocking_algoithms_阻塞并发">Blocking algoithms 阻塞并发</h4><p>可以简单认为基于锁的实现是blocking的算法。Lock-based 和 Lockless-based 两者之间的区别仅仅是加锁粒度的不同。Lock-based方案就是大家经常使用的 mutex 和 semaphore 等方案，代码复杂度低，但运行效率也最低。</p>
<h4 id="CAS原语">CAS原语</h4><p>CAS原语负责将某处内存地址的值（1 个字节）与一个期望值进行比较，如果相等，则将该内存地址处的值替换为新值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">do&#123; </span><br><span class="line">       备份旧数据；</span><br><span class="line">       基于旧数据构造新数据；</span><br><span class="line">&#125;while(!CAS( 内存地址，备份的旧数据，新数据 ))</span><br></pre></td></tr></table></figure>
<p>当两者进行比较时，如果相等，则证明共享数据没有被修改，替换成新值，然后继续往下运行；如果不相等，说明共享数据已经被修改，放弃已经所做的操作，然后重新执行刚才的操作。容易看出 CAS 操作是基于共享数据不会被修改的假设，采用了类似于数据库的 commit-retry 的模式。当同步冲突出现的机会很少时，这种假设能带来较大的性能提升。</p>

      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="tags/C/"> #C++ </a>
          
        </div>
      

      

      
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              分布式系统常见问题和解决方案
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2018-08-25
        </span>

        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="2018/08/25/分布式系统常见问题和解决方案/#comments">
              <span class="post-comments-count ds-thread-count" data-thread-key="2018/08/25/分布式系统常见问题和解决方案/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        <h4 id="如何从零开始造个云存储系统？"><a href="https://levy.at/blog/19" target="_blank" rel="noopener">如何从零开始造个云存储系统？</a></h4><p>单硬盘扩展成RAID磁盘阵列，再从单机RAID扩展到集群多机器，再到引入副本存储提高可靠性，再到引入一致性哈希进行动态扩展，再到跨机房多AZ备份和CDN区域加速。</p>
<h4 id="如何实现靠谱的分布式锁？"><a href="https://mp.weixin.qq.com/s/emEuhftLbAQmdn1LQYOSBw" target="_blank" rel="noopener">如何实现靠谱的分布式锁？</a></h4><p>分布式锁是用来控制分布式系统中互斥访问共享资源的一种手段(进程之间共享资源)，避免多线程并行访问导致结果不可控。基本的实现原理和单进程锁是一致的，通过一个共享标识来确定唯一性，对共享标识进行修改时能够保证原子性和和对锁服务调用方的可见性。由于分布式环境需要考虑各种异常因素，为实现一个靠谱的分布式锁服务引入了一定的复杂度。</p>
<p><strong>分布式锁一般需要能够保证以下几点：</strong></p>
<ol>
<li><p>同一时刻只能有一个线程持有锁</p>
</li>
<li><p>锁能够可重入</p>
</li>
<li><p>不会发生死锁</p>
</li>
<li><p>具备阻塞锁特性，且能够及时从阻塞状态被唤醒</p>
</li>
<li><p>锁服务保证高性能和高可用</p>
</li>
<li><p>锁数据本身的安全性</p>
</li>
</ol>
<h5 id="基于_Redis_实现的锁服务">基于 Redis 实现的锁服务</h5><ol>
<li>加锁：<code>SETNX key value</code>资源不存在时才能够成功执行 set 操作，用于保证锁持有者的唯一性；同时设置过期时间用于防止死锁；记录锁的持有者，用于防止解锁时解掉了不符合预期的锁。</li>
<li>解锁：只需要删除这个key就可以了，不过删除之前需要判断，这个key对应的value是当初自己设置的那个</li>
<li>Lua脚本对比解锁者是否所有者、解锁是一个原子操作</li>
<li>通过过期时间<code>PX millisecond</code>来避免死锁，时间选择很关键</li>
<li>Redis 的主从异步复制机制可能丢失数据，造成 A、B 两个线程并发访问同一个资源</li>
</ol>
<h5 id="基于_ZooKeeper_实现的锁服务">基于 ZooKeeper 实现的锁服务</h5><ol>
<li>加锁是线程去zookeeper上的某个指定节点的目录下创建一个唯一的临时有序节点，确定当前线程创建节点序号是否最小，是则加锁成功；否则去序列中寻找并监听序号较小的前一个节点。当监听到这个节点被删除了，那就再去判断一次自己当初创建的节点是否变成了序列中最小的。如果是，则获取锁，如果不是，则重复上述步骤。</li>
<li><strong>解锁流程是</strong>删除当前线程创建的临时接点。</li>
</ol>
<h5 id="基于数据库实现的锁服务">基于数据库实现的锁服务</h5><ol>
<li>乐观锁机制：表中每条记录添加version字段，每次更新操作需要CAS</li>
<li>悲观锁机制：在Mysql中是基于 for update 来实现加锁的</li>
</ol>
<h4 id="如何实现分布式文件系？"><a href="https://mp.weixin.qq.com/s/uGx-rq0-P1xxgt4CVW7pVg" target="_blank" rel="noopener">如何实现分布式文件系？</a></h4><p>分布式文件系统是分布式领域的一个基础应用，其中最著名的毫无疑问是 HDFS/GFS。</p>
<h5 id="DFS特性要求">DFS特性要求</h5><ul>
<li>符合 POSIX 的文件接口标准，兼容易用</li>
<li>对用户透明，能够像使用本地文件系统那样直接使用</li>
<li>持久化，保证数据不会丢失</li>
<li>具有伸缩性，当数据压力逐渐增长时能顺利水平扩容</li>
<li>具有可靠的安全机制，保证数据安全</li>
<li><p>数据一致性，只要文件内容不发生变化，什么时候去读，得到的内容应该都是一样的</p>
</li>
<li><p>支持的空间越大越好</p>
</li>
<li>支持的并发访问请求越多越好</li>
<li>性能越快越好</li>
<li>硬件资源的利用率越高越合理，就越好</li>
</ul>
<h5 id="DFS架构">DFS架构</h5><p>从业务模型和逻辑架构上，分布式文件系统需要这几类组件：</p>
<ul>
<li>存储组件：负责存储文件数据，它要保证文件的持久化、副本间数据一致、数据块的分配 / 合并等等；</li>
<li>管理组件：负责 meta 信息，即文件数据的元信息，包括文件存放在哪台服务器上、文件大小、权限等，除此之外，还要负责对存储组件的管理，包括存储组件所在的服务器是否正常存活、是否需要数据迁移等；</li>
<li>接口组件：提供接口服务给应用使用，形态包括 SDK(Java/C/C++ 等)、CLI 命令行终端、以及支持 FUSE 挂载机制。</li>
</ul>
<h5 id="GFS_—-_有中心节点">GFS —- 有中心节点</h5><p>中心节点负责文件定位、维护文件 meta 信息、故障检测、数据迁移等管理控制的职能。一般中心节点并不参与真正的数据读写，而是将文件 meta 信息返回给 Client 之后，即由 Client 与数据节点直接通信。其主要目的是降低中心节点的负载，防止其成为瓶颈。这种有中心节点的方案，在各种存储类系统中得到了广泛应用，因为中心节点易控制、功能强大。</p>
<h5 id="Ceph_—-_无中心节点">Ceph —- 无中心节点</h5><p>每个节点都是自治的、自管理的，整个 ceph 集群只包含一类节点 —-  RADOS 就是 ceph 定义的“同时包含 meta 数据和文件数据”的节点。无中心化的最大优点是解决了中心节点自身的瓶颈，这也就是 ceph 号称可以无限向上扩容的原因。<a href="http://www.xuxiaopang.com/2016/11/08/easy-ceph-CRUSH/" target="_blank" rel="noopener">CRUSH算法解决meta查找数据位置的问题</a></p>
<h5 id="内部DFS">内部DFS</h5><p>原来大量使用SAS磁盘和Raid卡。SAS盘+Raid的成本直逼SSD，但性能比SSD有数量级的落后。如果这些业务 把状态从本地磁盘转移到分布式文件系统，则不再依赖本地磁盘的可靠性，不再需要SAS盘和Raid卡。因此诞生了NFS。</p>
<p>NFS提供Posix接口，支持随机写操作，并针对这种访问模式做了大量的 优化工作；而AFS提供API访问接口，不支持文件的随机写操作。因此两者没有替代关系。<strong>从长远来看，NFS和AFS会长期并存，独立发展，不存在谁取代谁的关系</strong>。不仅如此，在实现上，NFS是AFS的底层，AFS自身的元信息，是存储在下层的NFS集群的。因此NFS除了继续提供Posix访问接口，取代本地硬盘这一目标外，还会进一步优化可用性。</p>
<h5 id="持久化数据">持久化数据</h5><ul>
<li>如何保证每个副本的数据是一致的? 同步写入或者W+R&gt;N 的方式</li>
<li>如何分散副本，以使灾难发生时，不至于所有副本都被损坏? 两地三中心</li>
<li>怎么检测被损坏或数据过期的副本，以及如何处理?<ul>
<li>如果有中心节点，则数据节点定期和中心节点进行通信，汇报自己的数据块的相关信息，中心节点将其与自己维护的信息进行对比</li>
<li>如果没有中心节点，以 ceph 为例，它在自己的节点集群中维护了一个比较小的 monitor 集群，数据节点向这个 monitor 集群汇报自己的情况，由其来判定是否被损坏或过期</li>
<li>FailOver机制</li>
</ul>
</li>
<li>该返回哪个副本给 Client? round-robin、速度最快的节点、成功率最高的节点、CPU 资源最空闲的节点、甚至就固定选第一个作为主节点，也可以选择离自己最近的一个</li>
</ul>
<h5 id="存储节点的伸缩性">存储节点的伸缩性</h5><ul>
<li>如何尽量使各存储节点的负载相对均衡?</li>
<li>怎样保证新加入的节点，不会因短期负载压力过大而崩塌? 预热时间</li>
<li>如果需要数据迁移，那如何使其对业务层透明?</li>
</ul>
<h5 id="中心节点的伸缩性">中心节点的伸缩性</h5><p>HDFS 的数据块的大小是 64M，ceph 的的数据块的大小是 4M，都远远超过单机文件系统的 4k。它的意义在于大幅减少 meta data 的数量，使中心节点的单机内存就能够支持足够多的磁盘空间 meta 信息</p>
<h5 id="中心节点的高可用">中心节点的高可用</h5><p>当前内存服务 + 日志文件持久化是主流方式。为了解决日志文件会随着时间增长越来越大的问题，以让系统能以尽快启动和恢复，需要辅助以内存快照的方式——定期将内存 dump 保存，只保留在 dump 时刻之后的日志文件</p>
<p>万兆网卡每秒传输大约 1250M 字节的数据，而 SATA 磁盘的读写速度这些年基本达到瓶颈，在 300-500M/s 附近。</p>
<h5 id="安全性">安全性</h5><p>主流文件系统的权限模型：DAC、MAC、RBAC</p>
<h5 id="面向小文件的分布式文件系统">面向小文件的分布式文件系统</h5><p>主流的实现方式是仍然是以大数据块的形式存储，小文件以逻辑存储的方式存在，即文件 meta 信息记录其是在哪个大数据块上，以及在该数据块上的 offset 和 length 是多少，形成一个逻辑上的独立文件。这样既复用了大数据块系统的优势和技术积累，又减少了 meta 信息。</p>
<h5 id="文件指纹和去重">文件指纹和去重</h5><p>文件指纹就是根据文件内容，经过算法，计算出文件的唯一标识。如果两个文件的指纹相同，则文件内容相同。在使用网络云盘的时候，发现有时候上传文件非常地快，就是文件指纹发挥作用。云盘服务商通过判断该文件的指纹，发现之前已经有人上传过了，则不需要真的上传该文件，只要增加一个引用即可。在文件系统中，通过文件指纹可以用来去重、也可以用来判断文件内容是否损坏、或者对比文件副本内容是否一致，是一个基础组件。指纹算法有md5、sha256、simhash 和 minhash</p>

      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="tags/存储/"> #存储 </a>
          
            <a href="tags/分布式系统/"> #分布式系统 </a>
          
            <a href="tags/数据库/"> #数据库 </a>
          
        </div>
      

      

      
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              HDFS入门
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2018-08-25
        </span>

        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="2018/08/25/HDFS入门/#comments">
              <span class="post-comments-count ds-thread-count" data-thread-key="2018/08/25/HDFS入门/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        <h5 id=""> </h5><h4 id="HDFS">HDFS</h4><p>HDFS 从设计上来说，主要考虑以下的特征：<strong>超大文件</strong>，最大能支持 PB 级别的数据；<strong>流式数据访问</strong>，一次写入，多次读取；在不可靠的文件，<strong>故障率高的商用硬件上能运行</strong>。Hadoop 的不利之处，是不适应低时间延迟的数据访问，不适应大量的小文件，也不适应多用户写入任意修改文件的情况。</p>
<p>NameNode 是 HDFS 的管理者。HDFS 将大文件分割成数据块，每个数据块是 64M，也可以设置成 128M或者 256M，然后将这些数据块以普通文件的形式存放到数据节点上，为了防止 DataNode 意外失效，HDFS 会将每个数据块复制若干份放到不同的数据节点。</p>
<h4 id="HDFS-Client">HDFS-Client</h4><h4 id="HDFS-VFS">HDFS-VFS</h4><p>VFS 是Linux 内核和真正文件系统之间的抽象层，它提供统一的接口，真正的文件系统和 Linxu 内核必须通过 VFS 的接口进行沟通。内核的 I\O 路径是这样的：user space -&gt; VFS -&gt; FS -&gt; I\O layer -&gt; I\O scheduler(optional) -&gt; block_driver -&gt; block_device, 一个 I\O 经过了这些才真正到达了对应的存储上。一个用户态的系统调用先通过 VFS 找到对应的文件系统再向下传递 I\O，这是 I\O 的一般路径。对于用户来说，一切都是操作文件。</p>
<p>Hadoop VFS兼容层，可以把HDFS当作一个标准的文件系统mount到本地的Linux文件系统上。这样用户便可以使用标准Unix命令，例如“ls”、“cd”、“cp”、“mkdir”、“find”、“grep”等，来操作一个hdfs的实例；也可以使用标准POSIX的开发库，例如C、C++、Python、Perl、JAVA、bash等的打开、写、读、关闭方法来操作一个hdfs的实例。</p>
<h5 id="HDFS-VFS特性">HDFS-VFS特性</h5><ul>
<li>最好情况下，单线程读速度能达100MB/s，写速度能达70MB/s</li>
<li>不支持tail –f、chown、chgrp、make、link、mmap命令，以及pwrite等随机写函数</li>
<li>不要在HDFS挂载点目录下执行scp、wget等会在当前路径下创建临时文件的操作</li>
</ul>

      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="tags/HDFS/"> #HDFS </a>
          
            <a href="tags/存储/"> #存储 </a>
          
            <a href="tags/分布式系统/"> #分布式系统 </a>
          
        </div>
      

      

      
      
    </div>
  </div>


    
  </div>

  
  <div class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="page/17/">17</a><a class="extend next" rel="next" href="page/2/">&raquo;</a>
  </div>


        </div>

        
      </div>


      
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <div id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      <div class="site-overview">
        <div class="site-author motion-element">
          <img class="site-author-image" src="/images/avatar.jpg" alt="CharlesXiao">
          <p class="site-author-name">CharlesXiao</p>
        </div>
        <p class="site-description motion-element">在码农炼成之路不断挣扎……stay hungry……keep learning……</p>
        <div class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">84</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            <a href="/categories">
              <span class="site-state-item-count">17</span>
              <span class="site-state-item-name">分类</span>
              </a>
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">76</span>
              <span class="site-state-item-name">标签</span>
              </a>
          </div>

        </div>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
              <a href="https://github.com/Charles-Xiao" target="_blank">github</a>
            </span>
            
              <span class="links-of-author-item">
              <a href="http://weibo.com/2262300105/profile?topnav=1&wvr=6" target="_blank">weibo</a>
            </span>
            
              <span class="links-of-author-item">
              <a href="http://daijiale.github.io/" target="_blank">Daijiale的个人站点</a>
            </span>
            
          
        </div>

        
        

      </div>

      

    </div>
  </div>


    </div>

    <div id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">
  
  &copy; &nbsp;  2015.05.16 - 
  2018
  <span class="with-love">
    <i class="icon-heart"></i>
  </span>
  <span class="author">CharlesXiao</span>
</div>

<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_pv">
  本站访客数:<span id="busuanzi_value_site_pv"></span>
</span>
</div>

<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共165.6k字</span>
</div>
<!--
<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>
-->



      </div>
    </div>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="vendors/jquery/index.js?v=2.1.3"></script>

  
  

  
  <script type="text/javascript" src="vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript">
    $(document).ready(function() {
      $('.content img').each(function () {
        var $image = $(this);
        var $imageWrapLink = $image.parent('a');

        if ($imageWrapLink.size() < 1) {
          $imageWrapLink = $image.wrap('<a href="' + this.getAttribute('src') + '"></a>').parent('a');
        }
        $imageWrapLink.addClass('fancybox');
      });
    });
    $('.fancybox').fancybox({
      helpers: {
        overlay: {
          locked: false
        }
      }
    });
  </script>


  <script type="text/javascript">
  function hasMobileUA () {
    var nav = window.navigator;
    var ua = nav.userAgent;
    var pa = /iPad|iPhone|Android|Opera Mini|BlackBerry|webOS|UCWEB|Blazer|PSP|IEMobile|Symbian/g;

    return pa.test(ua);
  }

  function isDesktop () {
    return screen.width > 991 && !hasMobileUA();
  }

  function isTablet () {
    return screen.width < 992 && screen.width > 767 && hasMobileUA();
  }

  function isMobile () {
    return screen.width < 767 && hasMobileUA();
  }

  function escapeSelector (selector) {
    return selector.replace(/[!"$%&'()*+,.\/:;<=>?@[\\\]^`{|}~]/g, "\\$&")
  }
</script>

  

  <script type="text/javascript" src="vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" id="motion.global">
  $(document).ready(function () {
    var body = $('body');
    var isSidebarVisible = false;
    var sidebarToggle = $('.sidebar-toggle');
    var sidebarToggleLine1st = $('.sidebar-toggle-line-first')
    var sidebarToggleLine2nd = $('.sidebar-toggle-line-middle');
    var sidebarToggleLine3rd = $('.sidebar-toggle-line-last');
    var sidebar = $('.sidebar');

    var SIDEBAR_WIDTH = '320px';
    var SIDEBAR_DISPLAY_DURATION = 300;

    var sidebarToogleLineStatusInit = {width: '100%', opacity: 1, left: 0, rotateZ: 0, top: 0};

    var sidebarToggleLine1stStatusInit = sidebarToogleLineStatusInit;
    var sidebarToggleLine1stStatusArrow = {width: '50%', rotateZ: '-45deg', top: '2px'};
    var sidebarToogleLine1stStatusClose = {width: '100%', rotateZ: '-45deg', top: '5px'};

    var sidebarToggleLine2ndStatusInit = sidebarToogleLineStatusInit;
    var sidebarToggleLine2ndStatusArrow = {width: '90%'};
    var sidebarToogleLine2ndStatusClose = {opacity: 0};

    var sidebarToggleLine3rdStatusInit = sidebarToogleLineStatusInit;
    var sidebarToggleLine3rdStatusArrow = {width: '50%', rotateZ: '45deg', top: '-2px'};
    var sidebarToogleLine3rdStatusClose = {width: '100%', rotateZ: '45deg', top: '-5px'};

    LogoAndMenuMotion();
    sidebatToggleMotion();
    postsListMotion();
    backToTopMotion();


    $(document)
      .on('sidebar.isShowing', function () {
        isDesktop() && body.velocity(
          {paddingRight: SIDEBAR_WIDTH},
          SIDEBAR_DISPLAY_DURATION
        );
        sidebarContentMotion();
      })
      .on('sidebar.isHiding', function () {});

    function LogoAndMenuMotion() {
      $.Velocity.RunSequence([
        { e: $('.brand'), p: { opacity: 1 }, o: { duration: 100 } },
        { e: $('.logo'), p: { opacity: 1, top: 0 }, o: { duration: 50} },
        
        { e: $('.logo-line-before i'), p: { translateX: "100%" }, o: { duration: 500, sequenceQueue: false } },
        { e: $('.logo-line-after i'), p: { translateX: "-100%" }, o: { duration: 500, sequenceQueue: false } },
        
        { e: $('.site-title'), p: { opacity: 1, top: 0 }, o: { duration: 200 } }
      ]);
      $('.menu-item').velocity('transition.slideDownIn', {display: null});
    }


    function backToTopMotion () {
      var b2top = $('.back-to-top');
      b2top.on('click', function () {
        body.velocity('scroll');
      });
    }

    function sidebarShowMotion () {

      sidebarToggleLine1st.velocity(sidebarToogleLine1stStatusClose);
      sidebarToggleLine2nd.velocity(sidebarToogleLine2ndStatusClose);
      sidebarToggleLine3rd.velocity(sidebarToogleLine3rdStatusClose);

      sidebar.velocity({width: SIDEBAR_WIDTH}, {
        display: 'block',
        duration: SIDEBAR_DISPLAY_DURATION,
        complete: function () {
          sidebar.addClass('sidebar-active');
          sidebar.trigger('sidebar.didShow');
        }
      });
      sidebar.trigger('sidebar.isShowing');
    }

    function sidebarHideMotion () {
      isDesktop() && body.velocity({paddingRight: 0});
      sidebar.velocity('reverse');

      sidebarToggleLine1st.velocity(sidebarToggleLine1stStatusInit);
      sidebarToggleLine2nd.velocity(sidebarToggleLine2ndStatusInit);
      sidebarToggleLine3rd.velocity(sidebarToggleLine3rdStatusInit);

      sidebar.removeClass('sidebar-active');
      sidebar.trigger('sidebar.isHiding');
    };

    function sidebarContentMotion () {
      $('.sidebar .motion-element').velocity(
        'transition.slideRightIn',
        {stagger: 50, drag: true}
      );
    }

    function postsListMotion () {
      var postMotionOptions = window.postMotionOptions || {stagger: 300, drag: true};
      $('.post').velocity('transition.slideDownIn', postMotionOptions);
    }

    function sidebatToggleMotion () {
      sidebarToggle.on('click', function () {
        isSidebarVisible ? sidebarHideMotion() : sidebarShowMotion();
        isSidebarVisible = !isSidebarVisible;
      });

      sidebarToggle.hover(function () {
        if (isSidebarVisible) {return}
        sidebarToggleLine1st.velocity('stop').velocity(sidebarToggleLine1stStatusArrow);
        sidebarToggleLine2nd.velocity('stop').velocity(sidebarToggleLine2ndStatusArrow);
        sidebarToggleLine3rd.velocity('stop').velocity(sidebarToggleLine3rdStatusArrow);
      }, function () {
        if (isSidebarVisible) {return}
        sidebarToggleLine1st.velocity('stop').velocity(sidebarToggleLine1stStatusInit);
        sidebarToggleLine2nd.velocity('stop').velocity(sidebarToggleLine2ndStatusInit);
        sidebarToggleLine3rd.velocity('stop').velocity(sidebarToggleLine3rdStatusInit);
      });
    }
  });

</script>





  

  
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
  });
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for (i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>


  
  
  


  

  
</body>
</html>
