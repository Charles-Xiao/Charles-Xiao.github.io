<!doctype html>
<html class="theme-next use-motion theme-next-mist">
<head>
  

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






  <link rel="stylesheet" type="text/css" href="vendors/fancybox/source/jquery.fancybox.css?v=2.1.5"/>


<link rel="stylesheet" type="text/css" href="css/main.css?v=0.4.2"/>


    <meta name="description" content="在码农炼成之路不断挣扎……stay hungry……keep learning……" />



  <meta name="keywords" content="java,android,life,CharlesXiao" />





  <link rel="shorticon icon" type="image/x-icon" href="/favicon.ico?v=0.4.2" />



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?6749450";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>


  <title> CharlesXiao‘s Blog </title>
</head>

<body>
<!--[if lte IE 8]> <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'> <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode"><img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820" alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari." style='margin-left:auto;margin-right:auto;display: block;'/></a></div> <![endif]-->
  <div class="container one-column 
   page-home 
">
    <div class="headband"></div>

    <div id="header" class="header">
      <div class="header-inner">
        <h1 class="site-meta">
  <span class="logo-line-before"><i></i></span>
  <a href="/" class="brand">
      <span class="logo">
        <i class="icon-logo"></i>
      </span>
      <span class="site-title">CharlesXiao‘s Blog</span>
  </a>
  <span class="logo-line-after"><i></i></span>
</h1>


  <ul id="menu" class="menu">
     
    <!--增加swiftype搜索功能-->
    <form class="menu-item menu-item-search">
      <input type="text" id="st-search-input" class="st-search-input st-default-search-input" />
    </form>
    
    <script type="text/javascript">
      (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
      (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
      e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
      })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

      _st('install','yxUhPQ2aHyszT_1btxX9','2.0.0');
    </script>
    <!--增加swiftype搜索功能end-->
    
    
      
      <li class="menu-item menu-item-home">
        <a href="/">
          <i class="menu-item-icon icon-home"></i> <br />
          首页
        </a>
      </li>
    
      
      <li class="menu-item menu-item-categories">
        <a href="/categories">
          <i class="menu-item-icon icon-categories"></i> <br />
          分类
        </a>
      </li>
    
      
      <li class="menu-item menu-item-about">
        <a href="/about">
          <i class="menu-item-icon icon-about"></i> <br />
          关于
        </a>
      </li>
    
      
      <li class="menu-item menu-item-archives">
        <a href="/archives">
          <i class="menu-item-icon icon-archives"></i> <br />
          归档
        </a>
      </li>
    
      
      <li class="menu-item menu-item-tags">
        <a href="/tags">
          <i class="menu-item-icon icon-tags"></i> <br />
          标签
        </a>
      </li>
    
  </ul>


      </div>
    </div>

    <div id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content">
          
  <div id="posts" class="posts-expand">
    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="2018/09/22/C++手稿集锦/">
                未命名
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2018-09-22
        </span>

        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="2018/09/22/C++手稿集锦/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2018/09/22/C++手稿集锦/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <p>title: “C++手稿集锦”<br>date: 2018-06-11 11:36:53</p>
<h2 id="tags:_[C++]">tags: [C++]</h2><h3 id="哪些变量会自动初始化？"><a href="https://harttle.land/2015/10/05/cpp-variable-init.html" target="_blank" rel="external">哪些变量会自动初始化？</a></h3><p>在C语言中的<strong>全局变量和静态变量都是会自动初始化为0，堆和栈中的局部变量不会初始化而拥有不可预测的值（C++默认初始化策略也是如此）。 C++保证了所有对象与对象成员都会初始化</strong>，无论是否写了圆括号或者是否写了参数列表，但其中基本数据类型的初始化还得依赖于构造函数。</p>
<p>成员变量分为成员对象和内置类型成员，其中成员对象总是会被初始化的。我们通常会在构造函数中初始化所有内置类型的成员。例如：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    A(): v(0);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="对象的生命周期，构造与析构">对象的生命周期，构造与析构</h3><h4 id="对象实例化">对象实例化</h4><p>可以直接定义对象变量，在栈中分配并初始化对象；也可以定义对象指针，从堆中分配空间并初始化对象。</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CPerson p1;</span><br><span class="line"><span class="function">CPerson <span class="title">p2</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">CPerson* p3 = <span class="keyword">new</span> CPerson(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<h4 id="析构函数">析构函数</h4><p>类的声明中，签名为<code>~CPerson()</code>的方法称为析构函数。析构函数没有参数和返回值。当对象生命周期结束时被调用，通常用来释放资源。一个类只能由一个析构函数。析构函数与构造函数类似，用户不指定时编译器会生成一个缺省的析构（构造）函数， 缺省的析构（构造）函数是空函数。</p>
<h4 id="对象指针数组">对象指针数组</h4><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CPerson *p[<span class="number">3</span>] = &#123;<span class="keyword">new</span> CPerson(<span class="number">1</span>), <span class="keyword">new</span> CPerson(<span class="number">2</span>)&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="复制构造函数">复制构造函数</h4><p>类的声明中，签名为<code>CPerson(CPerson&amp;)</code>的方法称为复制构造函数，用来从一个已存在的对象复制生成一个新的对象。 在如下三种情况下会被调用：</p>
<ol>
<li><p>用一个对象初始化另一个对象时。例如：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CPerson p2<span class="list">(<span class="keyword">p1</span>)</span><span class="comment">;</span></span><br><span class="line">CPerson p2 = p1<span class="comment">;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>对象作为参数传递时。例如：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void <span class="func"><span class="keyword">func</span><span class="params">(A a)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>对象作为返回值时。例如：</p>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">A</span> func()&#123; <span class="literal">A</span> <span class="literal">a</span><span class="comment">; return a;&#125;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>只有一个参数的复制构造函数可以被称为<strong>转换构造函数</strong>。当需要类型转换时，会被调用：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="constant">CPerson</span> = <span class="number">2</span>;    <span class="comment">// CPerson(int) called</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意区分赋值和初始化：<strong>对象变量间赋值不会调用复制构造函数</strong>。赋值只会按位拷贝对象所在的内存。当然你也可以重载<code>operator=</code>来改变它的行为。</p>
</blockquote>
<h4 id="对象生命周期">对象生命周期</h4><p>如下程序解释了对象的声明周期何时开始，以及何时结束。涉及到了：全局对象、静态对象、栈中的对象、堆中的对象。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">CPerson</span> p1;             <span class="comment">// main执行前，构造函数被调用</span></span><br><span class="line">void <span class="func"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">CPerson</span> p2;  <span class="comment">// func第一次执行前，构造函数被调用</span></span><br><span class="line">    <span class="type">CPerson</span> p3;         <span class="comment">// p3的构造函数被调用</span></span><br><span class="line">                        <span class="comment">// func结束时，p3的析构函数被调用</span></span><br><span class="line">&#125;  </span><br><span class="line">int main()&#123;</span><br><span class="line">    <span class="type">CPerson</span> p4, *p5;    <span class="comment">// 调用p4的构造函数</span></span><br><span class="line">    <span class="func"><span class="keyword">func</span><span class="params">()</span></span>;</span><br><span class="line">    p5 = <span class="keyword">new</span> <span class="type">CPerson</span>;   <span class="comment">// 调用p5的构造函数</span></span><br><span class="line">    delete p5;          <span class="comment">// 调用p5的析构函数</span></span><br><span class="line">                        <span class="comment">// main结束时，p4的析构函数被调用</span></span><br><span class="line">&#125;</span><br><span class="line">                        <span class="comment">// 程序结束前，p1, p2的析构函数被调用</span></span><br></pre></td></tr></table></figure>
<h3 id="栈对象和堆对象的创建方式">栈对象和堆对象的创建方式</h3><p>C++中，内存划分为三个逻辑区域：堆、栈和静态存储区，对象分为堆对象，栈对象以及静态对象。而类的对象建立分为两种，一种是静态建立，如A a；另一种是动态建立，如A* ptr=new A；两者都要执行构造函数。</p>
<ol>
<li><p><strong>静态建立类对象</strong>：是由编译器为对象在栈空间中分配内存，是通过直接移动栈顶指针，挪出适当的空间，然后在这片内存空间上调用构造函数形成一个栈对象。使用这种方法，<strong>直接调用类的构造函数</strong>，内存空间自动释放</p>
<p>。</p>
</li>
<li><p><strong>动态建立类对象</strong>：是使用new运算符将对象建立在堆空间中。这个过程分为两步，第一步是执行operator new()函数，在堆空间中搜索合适的内存并进行分配；第二步是调用构造函数构造对象，初始化这片内存空间。这种方法，<strong>间接调用类的构造函数</strong>，内存空间需要手动释放。</p>
</li>
<li><p><strong>注意点</strong>：</p>
</li>
</ol>
<blockquote>
<ol>
<li><p><a href="https://blog.csdn.net/hbtj_1216/article/details/65934865" target="_blank" rel="external">栈对象和堆对象区别和优劣</a> : 栈对象的创建速度一般较堆对象快，它仅仅需要移动栈顶指针就可以被创建，递归函数中最好不要使用栈对象以避免栈溢出；程序员对堆对象的生命具有完全的控制权。比如，我们需要创建一个对象，能够被多个函数所访问，但是又不想使其成为全局的，那么这个时候创建一个堆对象无疑是良好的选择，然后在各个函数之间传递这个堆对象的指针，便可以实现对该对象的共享。</p>
</li>
<li><p><strong>如何限制类对象只能在堆上建立? </strong>编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性，其实不光是析构函数，只要是非静态的函数，编译器都会进行检查。如果类的析构函数是私有的，则编译器不会在栈空间上为类对象分配内存（如果我们将构造函数设置为私有，那么我们也就不能用new来直接产生堆对象了，因为new在为对象分配空间后也会调用它的构造函数）。为了统一，可以将构造函数设为protected，然后提供一个public的static函数来完成构造，这样不使用new，而是使用一个函数来构造，使用一个函数来析构。</p>
</li>
<li><p>构造函数设置为私有会限制继承。如果一个类不打算作为基类，可以将其析构函数声明为private。为了限制栈对象，却不限制继承，我们可以将析构函数声明为protected，这样就两全其美。</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt;    <span class="class"><span class="keyword">class</span> <span class="title">NoStackObject</span> </span>&#123; </span><br><span class="line">&gt;    <span class="keyword">protected</span>: </span><br><span class="line">&gt;        NoStackObject() &#123; &#125; </span><br><span class="line">&gt;        ~NoStackObject() &#123; &#125; </span><br><span class="line">&gt;    <span class="keyword">public</span>: </span><br><span class="line">&gt;        <span class="keyword">static</span> NoStackObject* creatInstance() &#123;</span><br><span class="line">&gt;        <span class="keyword">return</span> <span class="keyword">new</span> NoStackObject() ;<span class="comment">//调用保护的构造函数 </span></span><br><span class="line">&gt;    &#125; </span><br><span class="line">&gt;        <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&gt;            delete <span class="keyword">this</span> ;<span class="comment">//调用保护的析构函数 </span></span><br><span class="line">&gt;        &#125; </span><br><span class="line">&gt;    &#125;;</span><br><span class="line">&gt;    NoStackObject* hash_ptr = NoStackObject::creatInstance() ;  </span><br><span class="line">&gt;    hash_ptr-&gt;destroy() ; </span><br><span class="line">&gt;    hash_ptr = NULL ; <span class="comment">//防止使用悬挂指针</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</blockquote>
<p>&gt;</p>
<blockquote>
<ol>
<li><p><strong>只要禁用new运算符就可以实现类对象只能建立在栈上</strong>: 你不能影响new operator的能力（因为那是C++语言内建的），但是new operator 总是先调用 operator new,而后者我们是可以自行声明重写的。因此，将operator new()设为私有即可禁止对象被new在堆上；如果也想禁止堆对象数组，可以把operator new[]和operator delete[]也声明为private。</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;    <span class="class"><span class="keyword">class</span> <span class="title">A</span>    </span><br><span class="line">&gt;    </span>&#123;    </span><br><span class="line">&gt;    <span class="keyword">private</span>:    </span><br><span class="line">&gt;        <span class="keyword">void</span>* operator <span class="keyword">new</span>(size_t t)&#123;&#125;     <span class="comment">// 注意函数的第一个参数和返回值都是固定的    </span></span><br><span class="line">&gt;        <span class="keyword">void</span> <span class="function">operator <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* ptr)</span></span>&#123;&#125; <span class="comment">// 重载了new就需要重载delete    </span></span><br><span class="line">&gt;    <span class="keyword">public</span>:    </span><br><span class="line">&gt;        A()&#123;&#125;    </span><br><span class="line">&gt;        ~A()&#123;&#125;    </span><br><span class="line">&gt;    &#125;; </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</blockquote>
<p>&gt;</p>
<blockquote>
</blockquote>
<h3 id="C++_智能指针与裸指针">C++ 智能指针与裸指针</h3><p>我们知道c++的内存管理是让很多人头疼的事，当我们写一个new语句时，一般就会立即把delete语句直接也写了，但是我们不能避免程序还未执行到delete时就跳转了或者在函数中没有执行到最后的delete语句就返回了，如果我们不在每一个可能跳转或者返回的语句前释放资源，就会造成内存泄露。<strong>智能指针就是一个类，当超出了类的作用域，类会自动调用析构函数，析构函数会自动释放资源。</strong></p>
<h4 id="为什么要用智能指针？">为什么要用智能指针？</h4><ol>
<li>难以区分裸指针指向的是单个对象还是一个数组，也无法确定到底是用delete(销毁单个对象)还是delete[]销毁一个数组；</li>
<li>使用完指针之后无法判断是否应该销毁指针，因为无法判断指针是否“拥有”指向的对象，也无法确定销毁指针的方式；</li>
<li>遗漏销毁指正可能导致内存泄露，而销毁多次则会导致未定义行为。</li>
</ol>
<h4 id="四种智能指针">四种智能指针</h4><ol>
<li><strong>std::auto_ptr和std::unique_ptr</strong>：auto_ptr是c++ 98遗留的关键字，已经不建议使用，auto_ptr的功能都可以由unique_ptr更加高效的做到。<ul>
<li>auto_ptr智能指针可以像类的原始指针一样访问类的public成员，成员函数get()返回一个原始的指针，成员函数reset()重新绑定指向的对象，而原来的对象则会被释放。注意我们访问auto_ptr的成员函数时用的是“.”，访问指向对象的成员时用的是“-&gt;”。</li>
<li>auto_ptr指针当我们对智能指针进行赋值时，如ptest2 = ptest，ptest2会接管ptest原来的内存管理权，ptest会变为空指针，如果ptest2原来不为空，则它会释放原来的资源，基于这个原因，应该避免把auto_ptr放到容器中，因为算法对容器操作时，很难避免STL内部对容器实现了赋值传递操作，这样会使容器中很多元素被置为NULL。判断一个智能指针是否为空不能使用if(ptest == NULL)，应该使用if(ptest.get() == NULL)。</li>
<li>unique_ptr指针永远“拥有”其指向的对象，unique_ptr是一个move-only类型，一个unique_ptr指针无法被复制，只能将“所有权”在两个unique_ptr指针之间转移，转移完成后源unique_ptr将被设为null。unique_ptr默认的销毁方式是通过对unique_ptr中的裸指针进行delete操作，它可以无缝地转换成shared_ptr。不能使用两个unique_ptr智能指针赋值操作，应该使用std::move，例如foo(std::move(ptest))</li>
</ul>
</li>
<li><strong><a href="https://segmentfault.com/a/1190000006860811" target="_blank" rel="external">std::shared_ptr</a>和std::weak_ptr</strong>：<ul>
<li>shared_ptr使用计数机制来表明资源被几个指针共享，可以自动管理对象的生命周期和GC，shared_ptr的引用计数增减是原子操作</li>
<li>一个对象可以被多个shared_ptr指向和访问，这些shared_ptr类型的指针共同享有该对象的所有权，当最后一个指向该对象的shared_ptr生命周期结束的时候，对象被销毁</li>
<li>shared_ptr的构造将引用计数加1，销毁的时候引用计数减1，而赋值则将源指针引用计数加1，目标指针引用计数减1，例如P1=P2，P1指向对象的引用计数减1，P2指向对象的引用计数加1。当引用计数减1之后为0的时候，shared_ptr将会销毁指向的对象。</li>
<li>由于control_block的存在，shared_ptr的size通常是2倍裸指针或unique_ptr的大小</li>
<li>weak_ptr是用来解决shared_ptr相互引用时的死锁问题,如果说两个shared_ptr相互引用,那么这两个指针的引用计数永远不可能下降为0,资源永远不会释放。它是对对象的一种弱引用，不会增加对象的引用计数，和shared_ptr之间可以相互转化，shared_ptr可以直接赋值给它，它可以通过调用lock函数来获得shared_ptr。不能通过weak_ptr直接访问对象的方法，应该先把它转化为shared_ptr</li>
</ul>
</li>
</ol>

        
      
    </div>

    <div class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="2018/08/25/分布式系统常见问题和解决方案/">
                分布式系统常见问题和解决方案
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2018-08-25
        </span>

        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="2018/08/25/分布式系统常见问题和解决方案/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2018/08/25/分布式系统常见问题和解决方案/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <h4 id="如何从零开始造个云存储系统？"><a href="https://levy.at/blog/19" target="_blank" rel="external">如何从零开始造个云存储系统？</a></h4><p>单硬盘扩展成RAID磁盘阵列，再从单机RAID扩展到集群多机器，再到引入副本存储提高可靠性，再到引入一致性哈希进行动态扩展，再到跨机房多AZ备份和CDN区域加速。</p>
<h4 id="如何实现靠谱的分布式锁？"><a href="https://mp.weixin.qq.com/s/emEuhftLbAQmdn1LQYOSBw" target="_blank" rel="external">如何实现靠谱的分布式锁？</a></h4><p>分布式锁是用来控制分布式系统中互斥访问共享资源的一种手段(进程之间共享资源)，避免多线程并行访问导致结果不可控。基本的实现原理和单进程锁是一致的，通过一个共享标识来确定唯一性，对共享标识进行修改时能够保证原子性和和对锁服务调用方的可见性。由于分布式环境需要考虑各种异常因素，为实现一个靠谱的分布式锁服务引入了一定的复杂度。</p>
<p><strong>分布式锁一般需要能够保证以下几点：</strong></p>
<ol>
<li><p>同一时刻只能有一个线程持有锁</p>
</li>
<li><p>锁能够可重入</p>
</li>
<li><p>不会发生死锁</p>
</li>
<li><p>具备阻塞锁特性，且能够及时从阻塞状态被唤醒</p>
</li>
<li><p>锁服务保证高性能和高可用</p>
</li>
<li><p>锁数据本身的安全性</p>
</li>
</ol>
<h5 id="基于_Redis_实现的锁服务">基于 Redis 实现的锁服务</h5><ol>
<li>加锁：<code>SETNX key value</code>资源不存在时才能够成功执行 set 操作，用于保证锁持有者的唯一性；同时设置过期时间用于防止死锁；记录锁的持有者，用于防止解锁时解掉了不符合预期的锁。</li>
<li>解锁：只需要删除这个key就可以了，不过删除之前需要判断，这个key对应的value是当初自己设置的那个</li>
<li>Lua脚本对比解锁者是否所有者、解锁是一个原子操作</li>
<li>通过过期时间<code>PX millisecond</code>来避免死锁，时间选择很关键</li>
<li>Redis 的主从异步复制机制可能丢失数据，造成 A、B 两个线程并发访问同一个资源</li>
</ol>
<h5 id="基于_ZooKeeper_实现的锁服务">基于 ZooKeeper 实现的锁服务</h5><ol>
<li>加锁是线程去zookeeper上的某个指定节点的目录下创建一个唯一的临时有序节点，确定当前线程创建节点序号是否最小，是则加锁成功；否则去序列中寻找并监听序号较小的前一个节点。当监听到这个节点被删除了，那就再去判断一次自己当初创建的节点是否变成了序列中最小的。如果是，则获取锁，如果不是，则重复上述步骤。</li>
<li><strong>解锁流程是</strong>删除当前线程创建的临时接点。</li>
</ol>
<h5 id="基于数据库实现的锁服务">基于数据库实现的锁服务</h5><ol>
<li>乐观锁机制：表中每条记录添加version字段，每次更新操作需要CAS</li>
<li>悲观锁机制：在Mysql中是基于 for update 来实现加锁的</li>
</ol>
<h4 id="如何实现分布式文件系？"><a href="https://mp.weixin.qq.com/s/uGx-rq0-P1xxgt4CVW7pVg" target="_blank" rel="external">如何实现分布式文件系？</a></h4><p>分布式文件系统是分布式领域的一个基础应用，其中最著名的毫无疑问是 HDFS/GFS。</p>
<h5 id="DFS特性要求">DFS特性要求</h5><ul>
<li>符合 POSIX 的文件接口标准，兼容易用</li>
<li>对用户透明，能够像使用本地文件系统那样直接使用</li>
<li>持久化，保证数据不会丢失</li>
<li>具有伸缩性，当数据压力逐渐增长时能顺利水平扩容</li>
<li>具有可靠的安全机制，保证数据安全</li>
<li><p>数据一致性，只要文件内容不发生变化，什么时候去读，得到的内容应该都是一样的</p>
</li>
<li><p>支持的空间越大越好</p>
</li>
<li>支持的并发访问请求越多越好</li>
<li>性能越快越好</li>
<li>硬件资源的利用率越高越合理，就越好</li>
</ul>
<h5 id="DFS架构">DFS架构</h5><p>从业务模型和逻辑架构上，分布式文件系统需要这几类组件：</p>
<ul>
<li>存储组件：负责存储文件数据，它要保证文件的持久化、副本间数据一致、数据块的分配 / 合并等等；</li>
<li>管理组件：负责 meta 信息，即文件数据的元信息，包括文件存放在哪台服务器上、文件大小、权限等，除此之外，还要负责对存储组件的管理，包括存储组件所在的服务器是否正常存活、是否需要数据迁移等；</li>
<li>接口组件：提供接口服务给应用使用，形态包括 SDK(Java/C/C++ 等)、CLI 命令行终端、以及支持 FUSE 挂载机制。</li>
</ul>
<h5 id="GFS_—-_有中心节点">GFS —- 有中心节点</h5><p>中心节点负责文件定位、维护文件 meta 信息、故障检测、数据迁移等管理控制的职能。一般中心节点并不参与真正的数据读写，而是将文件 meta 信息返回给 Client 之后，即由 Client 与数据节点直接通信。其主要目的是降低中心节点的负载，防止其成为瓶颈。这种有中心节点的方案，在各种存储类系统中得到了广泛应用，因为中心节点易控制、功能强大。</p>
<h5 id="Ceph_—-_无中心节点">Ceph —- 无中心节点</h5><p>每个节点都是自治的、自管理的，整个 ceph 集群只包含一类节点 —-  RADOS 就是 ceph 定义的“同时包含 meta 数据和文件数据”的节点。无中心化的最大优点是解决了中心节点自身的瓶颈，这也就是 ceph 号称可以无限向上扩容的原因。<a href="http://www.xuxiaopang.com/2016/11/08/easy-ceph-CRUSH/" target="_blank" rel="external">CRUSH算法解决meta查找数据位置的问题</a></p>
<h5 id="内部DFS">内部DFS</h5><p>原来大量使用SAS磁盘和Raid卡。SAS盘+Raid的成本直逼SSD，但性能比SSD有数量级的落后。如果这些业务 把状态从本地磁盘转移到分布式文件系统，则不再依赖本地磁盘的可靠性，不再需要SAS盘和Raid卡。因此诞生了NFS。</p>
<p>NFS提供Posix接口，支持随机写操作，并针对这种访问模式做了大量的 优化工作；而AFS提供API访问接口，不支持文件的随机写操作。因此两者没有替代关系。<strong>从长远来看，NFS和AFS会长期并存，独立发展，不存在谁取代谁的关系</strong>。不仅如此，在实现上，NFS是AFS的底层，AFS自身的元信息，是存储在下层的NFS集群的。因此NFS除了继续提供Posix访问接口，取代本地硬盘这一目标外，还会进一步优化可用性。</p>
<h5 id="持久化数据">持久化数据</h5><ul>
<li>如何保证每个副本的数据是一致的? 同步写入或者W+R&gt;N 的方式</li>
<li>如何分散副本，以使灾难发生时，不至于所有副本都被损坏? 两地三中心</li>
<li>怎么检测被损坏或数据过期的副本，以及如何处理?<ul>
<li>如果有中心节点，则数据节点定期和中心节点进行通信，汇报自己的数据块的相关信息，中心节点将其与自己维护的信息进行对比</li>
<li>如果没有中心节点，以 ceph 为例，它在自己的节点集群中维护了一个比较小的 monitor 集群，数据节点向这个 monitor 集群汇报自己的情况，由其来判定是否被损坏或过期</li>
<li>FailOver机制</li>
</ul>
</li>
<li>该返回哪个副本给 Client? round-robin、速度最快的节点、成功率最高的节点、CPU 资源最空闲的节点、甚至就固定选第一个作为主节点，也可以选择离自己最近的一个</li>
</ul>
<h5 id="存储节点的伸缩性">存储节点的伸缩性</h5><ul>
<li>如何尽量使各存储节点的负载相对均衡?</li>
<li>怎样保证新加入的节点，不会因短期负载压力过大而崩塌? 预热时间</li>
<li>如果需要数据迁移，那如何使其对业务层透明?</li>
</ul>
<h5 id="中心节点的伸缩性">中心节点的伸缩性</h5><p>HDFS 的数据块的大小是 64M，ceph 的的数据块的大小是 4M，都远远超过单机文件系统的 4k。它的意义在于大幅减少 meta data 的数量，使中心节点的单机内存就能够支持足够多的磁盘空间 meta 信息</p>
<h5 id="中心节点的高可用">中心节点的高可用</h5><p>当前内存服务 + 日志文件持久化是主流方式。为了解决日志文件会随着时间增长越来越大的问题，以让系统能以尽快启动和恢复，需要辅助以内存快照的方式——定期将内存 dump 保存，只保留在 dump 时刻之后的日志文件</p>
<p>万兆网卡每秒传输大约 1250M 字节的数据，而 SATA 磁盘的读写速度这些年基本达到瓶颈，在 300-500M/s 附近。</p>
<h5 id="安全性">安全性</h5><p>主流文件系统的权限模型：DAC、MAC、RBAC</p>
<h5 id="面向小文件的分布式文件系统">面向小文件的分布式文件系统</h5><p>主流的实现方式是仍然是以大数据块的形式存储，小文件以逻辑存储的方式存在，即文件 meta 信息记录其是在哪个大数据块上，以及在该数据块上的 offset 和 length 是多少，形成一个逻辑上的独立文件。这样既复用了大数据块系统的优势和技术积累，又减少了 meta 信息。</p>
<h5 id="文件指纹和去重">文件指纹和去重</h5><p>文件指纹就是根据文件内容，经过算法，计算出文件的唯一标识。如果两个文件的指纹相同，则文件内容相同。在使用网络云盘的时候，发现有时候上传文件非常地快，就是文件指纹发挥作用。云盘服务商通过判断该文件的指纹，发现之前已经有人上传过了，则不需要真的上传该文件，只要增加一个引用即可。在文件系统中，通过文件指纹可以用来去重、也可以用来判断文件内容是否损坏、或者对比文件副本内容是否一致，是一个基础组件。指纹算法有md5、sha256、simhash 和 minhash</p>

        
      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="tags/分布式系统/"> #分布式系统 </a>
          
            <a href="tags/存储/"> #存储 </a>
          
            <a href="tags/数据库/"> #数据库 </a>
          
        </div>
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="2018/08/25/HDFS入门/">
                HDFS入门
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2018-08-25
        </span>

        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="2018/08/25/HDFS入门/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2018/08/25/HDFS入门/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <h5 id=""> </h5><h4 id="HDFS">HDFS</h4><p>HDFS 从设计上来说，主要考虑以下的特征：<strong>超大文件</strong>，最大能支持 PB 级别的数据；<strong>流式数据访问</strong>，一次写入，多次读取；在不可靠的文件，<strong>故障率高的商用硬件上能运行</strong>。Hadoop 的不利之处，是不适应低时间延迟的数据访问，不适应大量的小文件，也不适应多用户写入任意修改文件的情况。</p>
<p>NameNode 是 HDFS 的管理者。HDFS 将大文件分割成数据块，每个数据块是 64M，也可以设置成 128M或者 256M，然后将这些数据块以普通文件的形式存放到数据节点上，为了防止 DataNode 意外失效，HDFS 会将每个数据块复制若干份放到不同的数据节点。</p>
<h4 id="HDFS-Client">HDFS-Client</h4><h4 id="HDFS-VFS">HDFS-VFS</h4><p>VFS 是Linux 内核和真正文件系统之间的抽象层，它提供统一的接口，真正的文件系统和 Linxu 内核必须通过 VFS 的接口进行沟通。内核的 I\O 路径是这样的：user space -&gt; VFS -&gt; FS -&gt; I\O layer -&gt; I\O scheduler(optional) -&gt; block_driver -&gt; block_device, 一个 I\O 经过了这些才真正到达了对应的存储上。一个用户态的系统调用先通过 VFS 找到对应的文件系统再向下传递 I\O，这是 I\O 的一般路径。对于用户来说，一切都是操作文件。</p>
<p>Hadoop VFS兼容层，可以把HDFS当作一个标准的文件系统mount到本地的Linux文件系统上。这样用户便可以使用标准Unix命令，例如“ls”、“cd”、“cp”、“mkdir”、“find”、“grep”等，来操作一个hdfs的实例；也可以使用标准POSIX的开发库，例如C、C++、Python、Perl、JAVA、bash等的打开、写、读、关闭方法来操作一个hdfs的实例。</p>
<h5 id="HDFS-VFS特性">HDFS-VFS特性</h5><ul>
<li>最好情况下，单线程读速度能达100MB/s，写速度能达70MB/s</li>
<li>不支持tail –f、chown、chgrp、make、link、mmap命令，以及pwrite等随机写函数</li>
<li>不要在HDFS挂载点目录下执行scp、wget等会在当前路径下创建临时文件的操作</li>
</ul>

        
      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="tags/HDFS/"> #HDFS </a>
          
            <a href="tags/分布式系统/"> #分布式系统 </a>
          
            <a href="tags/存储/"> #存储 </a>
          
        </div>
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="2018/05/10/Ruby net http库默认重试一次请求问题/">
                Ruby net::http库默认重试一次请求问题
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2018-05-10
        </span>

        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="2018/05/10/Ruby net http库默认重试一次请求问题/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2018/05/10/Ruby net http库默认重试一次请求问题/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <ol>
<li><strong>问题描述</strong>：并发20个线程，每个线程使用一个单独的BosClient去执行5G文件的PUT/GET操作，并比较下载文件和原文件的MD5，发现偶尔出现文件MD5对不上，文件大小大于5G的情况的情况，出现几率大概1%；</li>
<li><strong>问题定位</strong>：<ul>
<li>查看sdk日志和BOS日志，发现该情况下client发送了2次GET请求，第一次返回200但是err msg是PartialContentError</li>
<li>进一步查看nginx error log发现是客户端主动关闭了连接，可能是因为TCP连接超时等原因导致client主动关闭连接</li>
<li>但是从client日只看并没有触发重试机制，那么多出来的GET请求可能就是sdk用到的http库主动发起的</li>
</ul>
</li>
<li><strong>问题原因</strong>：<ul>
<li>定位发现sdk引用了第三方库rest-client，rest-client又引用了ruby语言自带的net::http库来发起http请求</li>
<li>查看net::http库源码发现，默认自带了一次重试机制；重试时不会对重置读取到的body stream，而是会继续追加写，导致文件大小大于5G</li>
<li><a href="https://github.com/ankane/the-ultimate-guide-to-ruby-timeouts/issues/8" target="_blank" rel="external">Net::HTTP read_timeout causes double requests</a></li>
</ul>
</li>
<li><p><strong>解决方案</strong>：<br>net::http库默认重试一次的机制不合理，因此有用户提出了bug，建议retry次数可配置<a href="https://bugs.ruby-lang.org/issues/10674" target="_blank" rel="external">Net::HTTP retries idempotent requests once after a timeout, but its not configurable</a>；AWS ruby sdk也发现了这一问题，提交了<a href="">PR</a>，不过要到ruby 2.5版本才支持直接设置重试次数。考虑到版本向下兼容问题，我们采取monkey patching的方式来解决这一问题，两个思路：</p>
<ul>
<li><p><strong>方案一</strong>：第二次重试的时候将body stream重置到起始位置</p>
<pre><code>module Net
class HTTP
def transport_request(req)
      count = <span class="number">0</span>
      begin
        begin_transport req
        res = <span class="keyword">catch</span>(:response) {
          req.exec @<span class="built_in">socket</span>, @curr_http_version, edit_path(req.path)
          begin
            res = HTTPResponse.read_new(@<span class="built_in">socket</span>)
            res.decode_content = req.decode_content
          <span class="function"><span class="keyword">end</span> <span class="title">while</span> <span class="title">res</span>.<span class="title">kind_of</span>?(<span class="title">HTTPContinue</span>)</span>
          res.uri = req.uri
          res
        }
        res.reading_body(@<span class="built_in">socket</span>, req.response_body_permitted?) {
          yield res <span class="keyword">if</span> block_given?
        }
      rescue Net::OpenTimeout
        raise
      rescue Net::ReadTimeout, IOError, EOFError,
             Errno::ECONNRESET, Errno::ECONNABORTED, Errno::EPIPE,
             <span class="comment"># avoid a dependency on OpenSSL</span>
             defined?(OpenSSL::SSL) ? OpenSSL::SSL::SSLError : IOError,
             Timeout::Error =&gt; exception
        <span class="keyword">if</span> count == <span class="number">0</span> &amp;&amp; IDEMPOTENT_METHODS_.<span class="built_in">include</span>?(req.method)
          count += <span class="number">1</span>
          @<span class="built_in">socket</span>.<span class="built_in">close</span> <span class="keyword">if</span> @<span class="built_in">socket</span> <span class="operator">and</span> <span class="operator">not</span> @<span class="built_in">socket</span>.closed?
          D <span class="string">"Conn close because of error #{exception}, and retry"</span>
         <span class="comment"> // 添加重置body_stream操作</span>
          <span class="keyword">if</span> req.body_stream
            <span class="keyword">if</span> req.body_stream.respond_to?(:rewind)
              req.body_stream.rewind
            <span class="keyword">else</span>
              raise
            <span class="function"><span class="keyword">end</span></span>
          <span class="function"><span class="keyword">end</span></span>
          retry
        <span class="function"><span class="keyword">end</span></span>
        D <span class="string">"Conn close because of error #{exception}"</span>
        @<span class="built_in">socket</span>.<span class="built_in">close</span> <span class="keyword">if</span> @<span class="built_in">socket</span> <span class="operator">and</span> <span class="operator">not</span> @<span class="built_in">socket</span>.closed?
        raise
      <span class="function"><span class="keyword">end</span></span>
      end_transport req, res
      res
    rescue =&gt; exception
      D <span class="string">"Conn close because of error #{exception}"</span>
      @<span class="built_in">socket</span>.<span class="built_in">close</span> <span class="keyword">if</span> @<span class="built_in">socket</span> <span class="operator">and</span> <span class="operator">not</span> @<span class="built_in">socket</span>.closed?
      raise exception
    <span class="function"><span class="keyword">end</span></span>
<span class="function"><span class="keyword">end</span></span>
<span class="function"><span class="keyword">end</span></span>
</code></pre></li>
<li><strong>方案二</strong>：去除重试机制，删掉retry语句 </li>
</ul>
</li>
<li><p><strong>参考链接</strong></p>
<ul>
<li><a href="https://github.com/aws/aws-sdk-ruby/issues/1167" target="_blank" rel="external">What is the purpose of monkey patching global HTTP stack?</a></li>
<li><a href="https://github.com/aws/aws-sdk-ruby/pull/1756" target="_blank" rel="external">Update Net::HTTP patching for Ruby 2.5 #1756</a></li>
<li><a href="https://github.com/aws/aws-sdk-ruby/blob/master/gems/aws-sdk-core/lib/seahorse/client/net_http/patches.rb" target="_blank" rel="external">AWS猴子补丁</a></li>
<li><a href="https://github.com/ruby/ruby/blob/v2_5_0/lib/net/http.rb" target="_blank" rel="external">各版本Ruby http.rb源码</a></li>
</ul>
</li>
</ol>

        
      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="tags/Ruby/"> #Ruby </a>
          
            <a href="tags/http/"> #http </a>
          
        </div>
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="2018/04/04/初探Golang内存管理和垃圾回收机制/">
                初探Golang内存管理和垃圾回收机制
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2018-04-04
        </span>

        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="2018/04/04/初探Golang内存管理和垃圾回收机制/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2018/04/04/初探Golang内存管理和垃圾回收机制/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <h3 id="内存管理">内存管理</h3><h4 id="堆与栈">堆与栈</h4><p>Go语言与CPP类似，也有栈和堆的概念，栈就是函数使用的栈，函数局部变量都在栈里，而new出来的变量大部分在堆上，当然这还取决于变量是会在作用域外被使用(注：编译器通过静态分析技术Escape Analysis来确定变量的作用范围)。</p>
<h4 id="堆内存管理机制">堆内存管理机制</h4><p>Go的内存管理是基于<a href="http://legendtkl.com/2015/12/11/go-memory/" target="_blank" rel="external">tcmalloc</a>实现的，tcmalloc核心思想是多级缓存、定长分配和管理.</p>
<h4 id="参考文章">参考文章</h4><p><a href="http://legendtkl.com/2017/04/02/golang-alloc/" target="_blank" rel="external">Golang内存管理</a></p>
<h3 id="垃圾回收GC">垃圾回收GC</h3><h4 id="常用GC算法">常用GC算法</h4><h4 id="Golang的三色标注-清除法">Golang的三色标注-清除法</h4><h4 id="Golang_垃圾回收剖析"><a href="http://legendtkl.com/2017/04/28/golang-gc/" target="_blank" rel="external">Golang 垃圾回收剖析</a></h4><blockquote>
<p>Unlike GHC’s stop-the-world collector, Go’s collector runs concurrently with the program to achieve short GC pauses.it means that the pause times become a scheduling problem.</p>
<p>In practice, the pause times of these phases to be &lt;1ms with very large heaps. With a concurrent GC, there is also potential for running the GC in parallel on multiple processors.</p>
<p>Low latency has costs. The most important cost is reduced throughput. Concurrency requires extra work for synchronization and duplication, which eats into the time the program can be doing useful work. GHC’s garbage collector is optimized for throughput, but Go’s is optimized for latency. At Pusher, we care about latency, so this is an excellent tradeoff for us.</p>
<p>A second cost of concurrent garbage collection is unpredictable heap growth. The program can allocate arbitrary amounts of memory while the GC is running. This means the GC must be run before the heap reaches the target maximum size.</p>
<p>GC times tend to be proportional to the number of pointers rather than the number of bytes. we would expect pauses of around 1ms for our heap size of 200MB, according to the go team. The heap size is kept large, which is important because the heap must be traversed in order to detect which objects are still referenced. This is why GC running time is proportional to the number of live objects/pointers between them.</p>
<p><code>go tool trace</code> observe gc phase state.</p>
</blockquote>
<h3 id="参考链接">参考链接</h3><ol>
<li><a href="https://www.jianshu.com/p/91d2956f22c1" target="_blank" rel="external">ptmalloc/tcmalloc/jemalloc内存分配策略</a></li>
<li><a href="https://making.pusher.com/golangs-real-time-gc-in-theory-and-practice/" target="_blank" rel="external">Golang’s Real-time GC in Theory and Practice</a></li>
<li><a href="https://blog.cloudflare.com/recycling-memory-buffers-in-go/" target="_blank" rel="external">Recycling memory buffers in Go</a></li>
</ol>

        
      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="tags/Golang/"> #Golang </a>
          
        </div>
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="2018/03/26/初探Goroutine调度机制/">
                初探Goroutine调度机制
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2018-03-26
        </span>

        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="2018/03/26/初探Goroutine调度机制/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2018/03/26/初探Goroutine调度机制/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <h3 id="何为Goroutine调度">何为Goroutine调度</h3><p>Goroutine是Go语言原生支持并发的具体实现，所有代码都跑在goroutine里，我们可以启动许多goroutine，多个goroutine对应一个os thread，不过最多只能允许创建10000个os线程, 如果超过10000个会抛异常。  </p>
<p><strong>Goroutine调度</strong>就是决定何时哪个goroutine将获得资源开始执行、哪个goroutine应该停止执行让出资源、哪个goroutine应该被唤醒恢复执行等。</p>
<h3 id="Goroutine调度器">Goroutine调度器</h3><p>传统语言中往往是代码负责创建线程，然后交给OS来进行线程调度。操作系统调度器会将系统中的多个线程or进程按照一定算法调度到物理CPU上去运行。这样会带来一些问题，例如</p>
<ul>
<li>线程创建容易退出难，因为退出时要判断线程状态</li>
<li>并发单元间通信困难，易错，一旦涉及到shared memory，就会用到各种lock，死锁便成为家常便饭</li>
<li>相对于协程而言，线程开销依然很大，OS切换线程上下文的代价不小</li>
</ul>
<p>在Golang中，goroutine可以认为是一种”轻量级线程” —- 协程，占用资源少。一个Go程序中可以创建成千上万个并发的goroutine，包括golang runtime在内的所有代码都跑在goroutine中，不涉及OS内核态。OS完全不知道goroutine的存在，go代码运行在一个或多个操作系统线程上。因此golang需要有<strong>调度器</strong>来负责调度这些goroutine，go scheduler负责将程序内的goroutines按照一定算法调度到不同的线程中去执行。</p>
<h3 id="Go调度模型">Go调度模型</h3><h4 id="G-M模型">G-M模型</h4><p>Go 1.0版本的简单调度模型，G指代goroutine，对应于runtime中的一个抽象结构；M指machine，代表一个操作系统线程。该模型存在一些问题。例如单一全局互斥锁(Sched.Lock)，意味着每个协程创建和调度都要加锁；M会做内存缓存，而且goroutine在M之间传递，造成调度延迟、、内存消耗、性能损耗。</p>
<h4 id="G-P-M模型">G-P-M模型</h4><ul>
<li><p>1.1版本之后沿用至今的调度模型，内部采用work stealing算法。模型图如下：<br><img src="https://raw.githubusercontent.com/Charles-Xiao/Charles-Xiao.github.io/master/images/goroutine-scheduler-model.png" class="full-image"></p>
</li>
<li><blockquote>
<p>M represents an OS thread. It’s the thread of execution managed by the OS and works pretty much like your standard POSIX thread. In the runtime code, it’s called M for machine.</p>
<p>G represents a goroutine. It includes the stack, the instruction pointer and other information important for scheduling goroutines, like any channel it might be blocked on. In the runtime code, it’s called a G.</p>
<p>P represents a context for scheduling. You can look at it as a localized version of the scheduler which runs Go code on a single thread. It’s the important part that lets us go from a N:1 scheduler to a M:N scheduler. In the runtime code, it’s called P for processor.     </p>
</blockquote>
</li>
<li>可以看到G和M之间加了个中间层P—-逻辑Processor，对于G而言，它只与P打交道，多个G会被平均分配到多个P上执行，一旦一部分G被分派到某个P上边执行，它就会存在于P的本地队列中等待被执行；而P与M的关系，可以认为是每个P绑定唯一一个M的关系，启动时的P默认数目为系统物理处理器个数。</li>
</ul>
<h4 id="G-P-M调度机制">G-P-M调度机制</h4><ul>
<li><strong>抢占式调度</strong>：<ul>
<li>当一个G中出现死循环或永久循环的代码逻辑，那么G将永久占用分配给它的P和M，位于同一个P中的其他G将得不到调度，出现“饿死”的情况；因此Go 1.2实现了抢占式调度机制，在每个函数或方法的入口，加上一段额外的代码，让runtime有机会检查是否需要执行抢占调；然而对于没有函数调用，纯循环计算的G，无法抢占调度。Go的具体实现是启动一个sysmon的监控线程，不绑定P，每20us~10ms启动一次，向长时间运行的G任务发出抢占调度。  </li>
<li>如果一个G任务运行10ms，sysmon就会认为其运行时间太久而发出抢占式调度的请求。一旦G的抢占标志位被设为true，那么待这个G下一次调用函数或方法时，runtime便可以将G抢占，并移出运行状态，放入P的local runq中，等待下一次被调度。</li>
</ul>
</li>
<li><strong>网络IO/channel阻塞调度</strong>：<ul>
<li>Go runtime通过实现netpoller机制来实现当goroutine发起网络I/O操作也不会导致M被阻塞（仅阻塞G），从而不会导致大量M被创建出来。</li>
<li>对于G被网络IO/channel阻塞，调度器会将当前G放入等待队列，等到阻塞操作完成之后再次被分配给某个P执行，而此时的M会去执行下一个runnable的G；如果此时没有runnable的G供M运行，那么M将解绑P，并进入sleep状态。</li>
</ul>
</li>
<li><p><strong>系统调用阻塞</strong>：</p>
<ul>
<li>当G去执行一个文件IO类似的系统调用时会导致系统G和线程M都被阻塞，P就会与M分离，去寻找其他的idle的M，没有就去创建，从而可能导致大量创建新的M的问题</li>
<li>Go 1.9增加了Poller for os package来实现在G操作支持pollable的fd时，仅阻塞G，而不阻塞M，不过对regular file无效</li>
</ul>
</li>
<li><p><strong>Tips</strong>：Go提供了调度器当前状态的查看方法, 使用Go运行时环境变量GODEBUG，例如<code>GODEBUG=schedtrace=1000 godoc -http=:6060</code></p>
</li>
</ul>
<blockquote>
<p>Go programs run with multiple threads, even when GOMAXPROCS is 1. The runtime uses goroutines that call syscalls, leaving threads behind.</p>
<p>In order to run goroutines, a thread must hold a context.</p>
<p>There are 3 usual models for threading. One is N:1 where several userspace threads are run on one OS thread. This has the advantage of being very quick to context switch but cannot take advantage of multi-core systems. Another is 1:1 where one thread of execution matches one OS thread. It takes advantage of all of the cores on the machine, but context switching is slow because it has to trap through the OS.</p>
<p>Go tries to get the best of both worlds by using a M:N scheduler. It schedules an arbitrary number of goroutines onto an arbitrary number of OS threads. You get quick context switches and you take advantage of all the cores in your system. The main disadvantage of this approach is the complexity it adds to the scheduler. </p>
</blockquote>
<h3 id="netpooler">netpooler</h3><p>当系统出现高并发的IO访问时，如一个网络服务器通常要并发处理成百上千的链接，每个链接可能都是由一个用户任务执行的，那么将会出现大量阻塞的IO操作，如果为每个阻塞操作都单独分配一个OS线程，那么将会增加系统的负载。因此在Golang中针对网络IO实现了netpooler来做特别的优化，只阻塞G，不阻塞M。</p>
<p>当goroutine读或写阻塞时会被放到等待队列，goroutine失去运行权，而M继续执行其它的G。后台的poller不停地poll，所有的文件描述符都被添加到了这个poller中，当某个时刻一个文件描述符准备好了，poller就会唤醒之前因它而阻塞的goroutine，于是goroutine重新被分配给某个P执行。</p>
<p>和使用Unix系统中的select或是poll方法不同地是，Golang的netpoller查询的是能被调度的goroutine而不是那些函数指针、包含了各种状态变量的struct等，这样你就不用管理这些状态，也不用重新检查函数指针等，这些都是你在传统Unix网络I/O需要操心的问题。</p>
<h3 id="参考链接">参考链接</h3><ol>
<li><a href="https://morsmachine.dk/go-scheduler" target="_blank" rel="external">The Go scheduler</a></li>
<li><a href="https://morsmachine.dk/netpoller" target="_blank" rel="external">The Go netpoller</a></li>
</ol>

        
      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="tags/Golang/"> #Golang </a>
          
        </div>
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="2018/02/07/高并发系统的限流策略/">
                高并发系统的限流策略
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2018-02-07
        </span>

        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="2018/02/07/高并发系统的限流策略/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2018/02/07/高并发系统的限流策略/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <p>一个高并发的系统，保护系统的方法一般有三种：<strong>缓存、降级和限流</strong>，本文主要讲一讲常见的限流策略。限流的目的是通过对并发访问进行限速或者一个时间窗口内的的请求进行限速来保护系统，一旦达到限制速率则可以拒绝服务（定向到错误页或告知资源没有了）、排队或等待（比如秒杀、评论、下单）、降级（返回兜底数据或默认数据，如商品详情页库存默认有货）</p>
<h4 id="单机限流">单机限流</h4><h5 id="常见限流措施">常见限流措施</h5><ul>
<li>限制总并发数（比如数据库连接池、线程池）</li>
<li>限制瞬时并发数（如nginx的limit_conn模块，用来限制瞬时并发连接数）</li>
<li>限制时间窗口内的平均速率（如Guava的RateLimiter、nginx的limit_req模块，限制每秒的平均速率）</li>
<li>限制远程接口调用速率</li>
<li>限制消息队列的消费速率</li>
<li>根据网络连接数、网络流量、CPU或内存负载等来限流</li>
</ul>
<h5 id="限流算法">限流算法</h5><ol>
<li><p><strong>令牌桶算法</strong>：令牌桶是按照固定速率往桶中添加令牌，请求是否被处理需要看桶中令牌是否足够，当令牌数减为零时则拒绝新的请求（Nginx限速模块的实现/Guava RateLimiter SmoothBursty）</p>
</li>
<li><p><strong>漏桶算法</strong>：漏桶则是按照常量固定速率流出请求，流入请求速率任意，当流入的请求数累积到漏桶容量时，则新流入的请求被拒绝(Guava RateLimiter SmoothWarmingUp)</p>
</li>
<li><p><strong>计数器限流：</strong>主要用来限制总并发数，比如数据库连接池、线程池、秒杀的并发数；只要全局总请求数或者一定时间段的总请求数设定的阀值则进行限流，是简单粗暴的总数量限流，而不是平均速率限流（atomic.incrementAndGet() + atomic.decrementAndGet()）</p>
</li>
</ol>
<h4 id="分布式系统限流">分布式系统限流</h4><h5 id="分布式限流_—_redis技术/一致性hash流量分片">分布式限流 — redis技术/一致性hash流量分片</h5><ol>
<li><strong>分布式系统</strong>：基于 REDIS 实现，存储两个 KEY，一个用于计时，一个用于计数。请求每调用一次，计数器增加 1，若在计时器时间内计数器未超过阈值，则可以处理任务。</li>
<li><strong>单机</strong>：使用Guava的Cache来存储计数器，过期时间设置为2秒（保证1秒内的计数器是有的），然后我们获取当前时间戳然后取秒数来作为KEY进行计数统计和限流</li>
</ol>
<h5 id="接入层限流_—_nginx限速模块">接入层限流 — nginx限速模块</h5><h4 id="参考链接">参考链接</h4><ol>
<li><a href="https://www.jianshu.com/p/2596e559db5c" target="_blank" rel="external">聊聊高并发系统之限流特技</a></li>
</ol>

        
      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="tags/并发/"> #并发 </a>
          
        </div>
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="2018/02/07/Golang学习总结/">
                Golang学习总结
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2018-02-07
        </span>

        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="2018/02/07/Golang学习总结/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2018/02/07/Golang学习总结/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <h3 id="基础语法">基础语法</h3><h4 id="Channel+WaitGroup">Channel+WaitGroup</h4><ol>
<li>实现发布/订阅Server：for+select循环监听发布事件、订阅事件、取消事件</li>
<li>工作调度器：</li>
</ol>
<h4 id="interface">interface</h4><ol>
<li><p><strong>go 没有显式的关键字用来实现 interface，如果一个类型实现了一个 interface 中所有方法，我们说类型实现了该 interface</strong></p>
</li>
<li><p>go 允许不带任何方法的 interface ，这种类型的 interface 叫 <strong>empty interface</strong>。<strong>go 不会对类型是interface{} 的 slice 进行转换</strong> 。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错：cannot use names (type []string) as type []interface &#123;&#125; in argument to printAll</span></span><br><span class="line"><span class="comment">// 原因：interface&#123;&#125; 会占用两个字长的存储空间，一个是自身的 methods 数据，一个是指向其存储值的指针，也就是 interface 变量存储的值；slice []interface&#123;&#125; 其长度是固定的N*2，但是 []T 的长度是N*sizeof(T)，两种 slice 实际存储值的大小是有区别的</span></span><br><span class="line"><span class="keyword">func</span> printAll(vals []<span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">	<span class="keyword">for</span> _, val := <span class="keyword">range</span> vals &#123;</span><br><span class="line">		fmt.Println(val)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">func</span> main()&#123;</span><br><span class="line">	names := []<span class="typename">string</span>&#123;<span class="string">"stanley"</span>, <span class="string">"david"</span>, <span class="string">"oscar"</span>&#125;</span><br><span class="line">	printAll(names)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 手动转换成[]interface&#123;&#125;</span></span><br><span class="line"><span class="keyword">var</span> dataSlice []<span class="typename">int</span> = foo()</span><br><span class="line"><span class="keyword">var</span> interfaceSlice []<span class="keyword">interface</span>&#123;&#125; = <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="built_in">len</span>(dataSlice))</span><br><span class="line"><span class="keyword">for</span> i, d := <span class="keyword">range</span> dataSlice &#123;</span><br><span class="line">	interfaceSlice[i] = d</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>interface 变量存储的是实现者的值，也就是可以申明一个interface，然后把具体的struct赋值给其进行初始化。</p>
</li>
<li><p><a href="https://tour.golang.org/methods/15" target="_blank" rel="external">Type assertions</a> (类型断言)，用于区分 interface 的变量究竟存储哪种类型的值</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">s :</span>= S&#123;&#125;</span><br><span class="line">var i I <span class="comment">//声明 i </span></span><br><span class="line">i = &amp;s <span class="comment">//赋值 s 到 i</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方案一</span></span><br><span class="line"><span class="keyword">if</span> t, <span class="string">ok :</span>= i.(*S); ok &#123;</span><br><span class="line">    fmt.Println(<span class="string">"s implements I"</span>, t)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方案二</span></span><br><span class="line"><span class="keyword">switch</span> <span class="string">t :</span>= i.(type) &#123;</span><br><span class="line"><span class="keyword">case</span> *<span class="string">S:</span></span><br><span class="line">    fmt.Println(<span class="string">"i store *S"</span>, t)</span><br><span class="line"><span class="keyword">case</span> *<span class="string">R:</span></span><br><span class="line">    fmt.Println(<span class="string">"i store *R"</span>, t)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>interface 定义时并没有严格规定实现者的方法 receiver 是个 value receiver 还是 pointer receiver。interface 的实现者 ss的方法 receiver 都是 value receiver，执行函数<code>func(i)</code>可以无论是 pointer 还是 value 都可以正确执行，也就是<code>func(&amp;ss)或者func(ss)</code>；如果ss的方法receiver存在pointer receiver，则不能调用<code>func(ss)</code>，因为根据value找不到地址</p>
</li>
<li><strong>go 中函数都是按值传递即 passed by value</strong>。对于 receiver 是 value 的 method，任何在 method 内部对 value 做出的改变都不影响调用者看到的 value，这就是按值传递。</li>
</ol>
<h4 id="参考链接">参考链接</h4><h3 id="其它">其它</h3><h4 id="gofmt与goimports">gofmt与goimports</h4><p>gofmt follows a simple rule that works for all use cases: imports may be separated by<br>blank lines, and each set of blank lines is sorted independently.  </p>
<p>goimports, which does more than just formatting, applies a different rule: it groups<br>imports according to whether they are standard imports, appengine imports, or other<br>imports.  It emits each group separately.  Then the gofmt algorithm kicks in and sorts<br>each group independently.<br>The goimports and gofmt programs do different jobs and it is not a goal that they<br>produce identical results.</p>

        
      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="tags/Golang/"> #Golang </a>
          
        </div>
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
  </div>

  
  <div class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="page/10/">10</a><a class="extend next" rel="next" href="page/2/">&raquo;</a>
  </div>


        </div>

        
      </div>


      
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <div id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      <div class="site-overview">
        <div class="site-author motion-element">
          <img class="site-author-image" src="/images/avatar.jpg" alt="CharlesXiao" />
          <p class="site-author-name">CharlesXiao</p>
        </div>
        <p class="site-description motion-element">在码农炼成之路不断挣扎……stay hungry……keep learning……</p>
        <div class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">80</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            <a href="/categories">
              <span class="site-state-item-count">17</span>
              <span class="site-state-item-name">分类</span>
              </a>
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">75</span>
              <span class="site-state-item-name">标签</span>
              </a>
          </div>

        </div>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
              <a href="https://github.com/Charles-Xiao" target="_blank">github</a>
            </span>
            
              <span class="links-of-author-item">
              <a href="http://weibo.com/2262300105/profile?topnav=1&wvr=6" target="_blank">weibo</a>
            </span>
            
              <span class="links-of-author-item">
              <a href="http://daijiale.github.io/" target="_blank">Daijiale的个人站点</a>
            </span>
            
          
        </div>

        
        

      </div>

      

    </div>
  </div>


    </div>

    <div id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; &nbsp;  2015.05.16 - 
  2018
  <span class="with-love">
    <i class="icon-heart"></i>
  </span>
  <span class="author">CharlesXiao</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>



      </div>
    </div>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="vendors/jquery/index.js?v=2.1.3"></script>

  
  

  
  <script type="text/javascript" src="vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript">
    $(document).ready(function() {
      $('.content img').each(function () {
        var $image = $(this);
        var $imageWrapLink = $image.parent('a');

        if ($imageWrapLink.size() < 1) {
          $imageWrapLink = $image.wrap('<a href="' + this.getAttribute('src') + '"></a>').parent('a');
        }
        $imageWrapLink.addClass('fancybox');
      });
    });
    $('.fancybox').fancybox({
      helpers: {
        overlay: {
          locked: false
        }
      }
    });
  </script>


  <script type="text/javascript">
  function hasMobileUA () {
    var nav = window.navigator;
    var ua = nav.userAgent;
    var pa = /iPad|iPhone|Android|Opera Mini|BlackBerry|webOS|UCWEB|Blazer|PSP|IEMobile|Symbian/g;

    return pa.test(ua);
  }

  function isDesktop () {
    return screen.width > 991 && !hasMobileUA();
  }

  function isTablet () {
    return screen.width < 992 && screen.width > 767 && hasMobileUA();
  }

  function isMobile () {
    return screen.width < 767 && hasMobileUA();
  }

  function escapeSelector (selector) {
    return selector.replace(/[!"$%&'()*+,.\/:;<=>?@[\\\]^`{|}~]/g, "\\$&")
  }
</script>

  

  <script type="text/javascript" src="vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" id="motion.global">
  $(document).ready(function () {
    var body = $('body');
    var isSidebarVisible = false;
    var sidebarToggle = $('.sidebar-toggle');
    var sidebarToggleLine1st = $('.sidebar-toggle-line-first')
    var sidebarToggleLine2nd = $('.sidebar-toggle-line-middle');
    var sidebarToggleLine3rd = $('.sidebar-toggle-line-last');
    var sidebar = $('.sidebar');

    var SIDEBAR_WIDTH = '320px';
    var SIDEBAR_DISPLAY_DURATION = 300;

    var sidebarToogleLineStatusInit = {width: '100%', opacity: 1, left: 0, rotateZ: 0, top: 0};

    var sidebarToggleLine1stStatusInit = sidebarToogleLineStatusInit;
    var sidebarToggleLine1stStatusArrow = {width: '50%', rotateZ: '-45deg', top: '2px'};
    var sidebarToogleLine1stStatusClose = {width: '100%', rotateZ: '-45deg', top: '5px'};

    var sidebarToggleLine2ndStatusInit = sidebarToogleLineStatusInit;
    var sidebarToggleLine2ndStatusArrow = {width: '90%'};
    var sidebarToogleLine2ndStatusClose = {opacity: 0};

    var sidebarToggleLine3rdStatusInit = sidebarToogleLineStatusInit;
    var sidebarToggleLine3rdStatusArrow = {width: '50%', rotateZ: '45deg', top: '-2px'};
    var sidebarToogleLine3rdStatusClose = {width: '100%', rotateZ: '45deg', top: '-5px'};

    LogoAndMenuMotion();
    sidebatToggleMotion();
    postsListMotion();
    backToTopMotion();


    $(document)
      .on('sidebar.isShowing', function () {
        isDesktop() && body.velocity(
          {paddingRight: SIDEBAR_WIDTH},
          SIDEBAR_DISPLAY_DURATION
        );
        sidebarContentMotion();
      })
      .on('sidebar.isHiding', function () {});

    function LogoAndMenuMotion() {
      $.Velocity.RunSequence([
        { e: $('.brand'), p: { opacity: 1 }, o: { duration: 100 } },
        { e: $('.logo'), p: { opacity: 1, top: 0 }, o: { duration: 50} },
        
        { e: $('.logo-line-before i'), p: { translateX: "100%" }, o: { duration: 500, sequenceQueue: false } },
        { e: $('.logo-line-after i'), p: { translateX: "-100%" }, o: { duration: 500, sequenceQueue: false } },
        
        { e: $('.site-title'), p: { opacity: 1, top: 0 }, o: { duration: 200 } }
      ]);
      $('.menu-item').velocity('transition.slideDownIn', {display: null});
    }


    function backToTopMotion () {
      var b2top = $('.back-to-top');
      b2top.on('click', function () {
        body.velocity('scroll');
      });
    }

    function sidebarShowMotion () {

      sidebarToggleLine1st.velocity(sidebarToogleLine1stStatusClose);
      sidebarToggleLine2nd.velocity(sidebarToogleLine2ndStatusClose);
      sidebarToggleLine3rd.velocity(sidebarToogleLine3rdStatusClose);

      sidebar.velocity({width: SIDEBAR_WIDTH}, {
        display: 'block',
        duration: SIDEBAR_DISPLAY_DURATION,
        complete: function () {
          sidebar.addClass('sidebar-active');
          sidebar.trigger('sidebar.didShow');
        }
      });
      sidebar.trigger('sidebar.isShowing');
    }

    function sidebarHideMotion () {
      isDesktop() && body.velocity({paddingRight: 0});
      sidebar.velocity('reverse');

      sidebarToggleLine1st.velocity(sidebarToggleLine1stStatusInit);
      sidebarToggleLine2nd.velocity(sidebarToggleLine2ndStatusInit);
      sidebarToggleLine3rd.velocity(sidebarToggleLine3rdStatusInit);

      sidebar.removeClass('sidebar-active');
      sidebar.trigger('sidebar.isHiding');
    };

    function sidebarContentMotion () {
      $('.sidebar .motion-element').velocity(
        'transition.slideRightIn',
        {stagger: 50, drag: true}
      );
    }

    function postsListMotion () {
      var postMotionOptions = window.postMotionOptions || {stagger: 300, drag: true};
      $('.post').velocity('transition.slideDownIn', postMotionOptions);
    }

    function sidebatToggleMotion () {
      sidebarToggle.on('click', function () {
        isSidebarVisible ? sidebarHideMotion() : sidebarShowMotion();
        isSidebarVisible = !isSidebarVisible;
      });

      sidebarToggle.hover(function () {
        if (isSidebarVisible) {return}
        sidebarToggleLine1st.velocity('stop').velocity(sidebarToggleLine1stStatusArrow);
        sidebarToggleLine2nd.velocity('stop').velocity(sidebarToggleLine2ndStatusArrow);
        sidebarToggleLine3rd.velocity('stop').velocity(sidebarToggleLine3rdStatusArrow);
      }, function () {
        if (isSidebarVisible) {return}
        sidebarToggleLine1st.velocity('stop').velocity(sidebarToggleLine1stStatusInit);
        sidebarToggleLine2nd.velocity('stop').velocity(sidebarToggleLine2ndStatusInit);
        sidebarToggleLine3rd.velocity('stop').velocity(sidebarToggleLine3rdStatusInit);
      });
    }
  });

</script>





  

  
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
  });
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for (i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>


  
  
  


  

  
</body>
</html>
